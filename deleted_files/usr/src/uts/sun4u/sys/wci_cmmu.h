/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License, Version 1.0 only
 * (the "License").  You may not use this file except in compliance
 * with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright 2005 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 * Automatically Generated file based on CSR definitions
 *
 */

/*
 * This file automatically generated from
 *    wci_sram.csr
 *    03/27/2000 13:46:00
 *    Using  ./csr_filter.pl by pcw
 */

/* **DO NOT EDIT THIS FILE**  */
/*
 * File ../../../design/wci/include/cmmu.h *
 */

#ifndef _SYS_WCI_CMMU_H
#define	_SYS_WCI_CMMU_H

#pragma ident	"%Z%%M%	%I%	%E% SMI"

#ifdef __cplusplus
extern "C" {
#endif

/*
 * Include any headers you depend on.
 */



/*
 * wci_sram_array_as_cmmu_1_addr
 */
typedef union {
	struct wci_sram_array_as_cmmu_1_addr {
		uint32_t error				: 1;	/* 63 */
		uint32_t filler				: 15;	/* 62:48 */
		uint32_t ecc_syndrome			: 7;	/* 47:41 */
		uint32_t ecc_check			: 7;	/* 40:34 */
		uint32_t reserved1			: 2;	/* 33:32 */
		uint32_t reserved2			: 3;	/* 31:29 */
		uint32_t lpa_page			: 29;	/* 28:0 */
	} bit;
	uint64_t val;
} wci_sram_array_as_cmmu_1_addr_u;

#define	wci_sram_array_as_cmmu_1_addr_error	\
	bit.error
#define	wci_sram_array_as_cmmu_1_addr_ecc_syndrome	\
	bit.ecc_syndrome
#define	wci_sram_array_as_cmmu_1_addr_ecc_check	\
	bit.ecc_check
#define	wci_sram_array_as_cmmu_1_addr_reserved	\
	bit.reserved
#define	wci_sram_array_as_cmmu_1_addr_lpa_page	\
	bit.lpa_page


/*
 * wci_sram_array_as_cmmu_1_int
 */
typedef union {
	struct wci_sram_array_as_cmmu_1_int {
		uint32_t error				: 1;	/* 63 */
		uint32_t filler				: 15;	/* 62:48 */
		uint32_t ecc_syndrome			: 7;	/* 47:41 */
		uint32_t ecc_check			: 7;	/* 40:34 */
		uint32_t reserved1			: 2;	/* 33:32 */
		uint32_t reserved2			: 3;	/* 31:29 */
		uint32_t lpa_page_1			: 2;	/* 28:27 */
		uint32_t mondo				: 16;	/* 26:11 */
		uint32_t lpa_page_2			: 11;	/* 10:0 */
	} bit;
	uint64_t val;
} wci_sram_array_as_cmmu_1_int_u;

#define	wci_sram_array_as_cmmu_1_int_error	\
	bit.error
#define	wci_sram_array_as_cmmu_1_int_ecc_syndrome	\
	bit.ecc_syndrome
#define	wci_sram_array_as_cmmu_1_int_ecc_check	\
	bit.ecc_check
#define	wci_sram_array_as_cmmu_1_int_reserved	\
	bit.reserved
#define	wci_sram_array_as_cmmu_1_int_lpa_page_1	\
	bit.lpa_page_1
#define	wci_sram_array_as_cmmu_1_int_mondo	\
	bit.mondo
#define	wci_sram_array_as_cmmu_1_int_lpa_page_2	\
	bit.lpa_page_2


/*
 * wci_sram_array_as_cmmu_0
 */
typedef union {
	struct wci_sram_array_as_cmmu_0 {
		uint32_t error				: 1;	/* 63 */
		uint32_t filler				: 15;	/* 62:48 */
		uint32_t ecc_syndrome			: 7;	/* 47:41 */
		uint32_t ecc_check			: 7;	/* 40:34 */
		uint32_t reserved1			: 2;	/* 33:31 */
		uint32_t reserved2			: 3;	/* 31:29 */
		uint32_t writable			: 1;	/* 28 */
		uint32_t from_all			: 1;	/* 27 */
		uint32_t valid				: 1;	/* 26 */
		uint32_t type				: 2;	/* 25:24 */
		uint32_t from_node			: 8;	/* 23:16 */
		uint32_t atomic_orig_id			: 12;	/* 15:4 */
		uint32_t count_enable			: 1;	/* 3 */
		uint32_t large_page			: 1;	/* 2 */
		uint32_t user_err			: 1;	/* 1 */
		uint32_t lpa_page			: 1;	/* 0 */
	} bit;
	uint64_t val;
} wci_sram_array_as_cmmu_0_u;

#define	wci_sram_array_as_cmmu_0_error	\
	bit.error
#define	wci_sram_array_as_cmmu_0_ecc_syndrome	\
	bit.ecc_syndrome
#define	wci_sram_array_as_cmmu_0_ecc_check	\
	bit.ecc_check
#define	wci_sram_array_as_cmmu_0_reserved	\
	bit.reserved
#define	wci_sram_array_as_cmmu_0_writable	\
	bit.writable
#define	wci_sram_array_as_cmmu_0_from_all	\
	bit.from_all
#define	wci_sram_array_as_cmmu_0_valid	\
	bit.valid
#define	wci_sram_array_as_cmmu_0_type	\
	bit.type
#define	wci_sram_array_as_cmmu_0_from_node	\
	bit.from_node
#define	wci_sram_array_as_cmmu_0_atomic_orig_id	\
	bit.atomic_orig_id
#define	wci_sram_array_as_cmmu_0_count_enable	\
	bit.count_enable
#define	wci_sram_array_as_cmmu_0_large_page	\
	bit.large_page
#define	wci_sram_array_as_cmmu_0_user_err	\
	bit.user_err
#define	wci_sram_array_as_cmmu_0_lpa_page	\
	bit.lpa_page






#ifdef __cplusplus
}
#endif

#endif /* _SYS_WCI_CMMU_H */
