'\" te
.\" Copyright (c) 2000, 2001, 2002, 2003, 2004 by Martin C. Shepherd.
.\" All Rights Reserved.
.\" Permission is hereby granted, free of charge, to any person obtaining
.\" a copy of this software and associated documentation files (the
.\" "Software"), to deal in the Software without restriction, including
.\" without limitation the rights to use, copy, modify, merge, publish,
.\" distribute, and/or sell copies of the Software, and to permit persons
.\" to whom the Software is furnished to do so, provided that the above
.\" copyright notice(s) and this permission notice appear in all copies of
.\" the Software and that both the above copyright notice(s) and this
.\" permission notice appear in supporting documentation.
.\"
.\" THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
.\" OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
.\" MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT
.\" OF THIRD PARTY RIGHTS. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
.\" HOLDERS INCLUDED IN THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL
.\" INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING
.\" FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
.\" NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
.\" WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
.\"
.\" Except as contained in this notice, the name of a copyright holder
.\" shall not be used in advertising or otherwise to promote the sale, use
.\" or other dealings in this Software without prior written authorization
.\" of the copyright holder.
.\" Portions Copyright (c) 2007, Sun Microsystems, Inc. All Rights Reserved.
.\" Copyright (c) 2012-2013, J. Schilling
.\" Copyright (c) 2013, Andreas Roehler
.TH gl_get_line 3TECLA "28 Nov 2007" "SunOS 5.11" "Interactive Command-line Input Library Functions"
.SH NAME
gl_get_line, new_GetLine, del_GetLine, gl_customize_completion,
gl_change_terminal, gl_configure_getline, gl_load_history, gl_save_history,
gl_group_history, gl_show_history, gl_watch_fd, gl_inactivity_timeout,
gl_terminal_size, gl_set_term_size, gl_resize_history, gl_limit_history,
gl_clear_history, gl_toggle_history, gl_lookup_history, gl_state_of_history,
gl_range_of_history, gl_size_of_history, gl_echo_mode, gl_replace_prompt,
gl_prompt_style, gl_ignore_signal, gl_trap_signal, gl_last_signal,
gl_completion_action, gl_register_action, gl_display_text, gl_return_status,
gl_error_message, gl_catch_blocked, gl_list_signals, gl_bind_keyseq,
gl_erase_terminal, gl_automatic_history, gl_append_history, gl_query_char,
gl_read_char \- allow the user to compose an input line
.SH SYNOPSIS
.LP
.nf
cc [ \fIflag\fR\&.\|.\|. ] \fIfile\fR\&.\|.\|. \fB-ltecla\fR [ \fIlibrary\fR\&.\|.\|. ]
#include <stdio.h>
#include <libtecla.h>

\fBGetLine *\fBnew_GetLine\fR(\fBsize_t\fR \fIlinelen\fR, \fBsize_t\fR \fIhistlen\fR);
.fi

.LP
.nf
\fBGetLine *\fBdel_GetLine\fR(\fBGetLine *\fIgl\fR);
.fi

.LP
.nf
\fBchar *\fBgl_get_line\fR(\fBGetLine *\fIgl\fR, \fBconst char *\fIprompt\fR,
     \fBconst char *\fIstart_line\fR, \fBint\fR \fIstart_pos\fR);
.fi

.LP
.nf
\fBint\fR \fBgl_query_char\fR(\fBGetLine *\fIgl\fR, \fBconst char *\fIprompt\fR, \fBchar\fR \fIdefchar\fR);
.fi

.LP
.nf
\fBint\fR \fBgl_read_char\fR(\fBGetLine *\fIgl\fR);
.fi

.LP
.nf
\fBint\fR \fBgl_customize_completion\fR(\fBGetLine *\fIgl\fR, \fBvoid *\fIdata\fR,
     \fBCplMatchFn *\fImatch_fn\fR);
.fi

.LP
.nf
\fBint\fR \fBgl_change_terminal\fR(\fBGetLine *\fIgl\fR, \fBFILE *\fIinput_fp\fR,
     \fBFILE *\fIoutput_fp\fR, \fBconst char *\fIterm\fR);
.fi

.LP
.nf
\fBint\fR \fBgl_configure_getline\fR(\fBGetLine *\fIgl\fR, \fBconst char *\fIapp_string\fR,
     \fBconst char *\fIapp_file\fR,\ \fBconst char *\fIuser_file\fR);
.fi

.LP
.nf
\fBint\fR \fBgl_bind_keyseq\fR(\fBGetLine *\fIgl\fR, \fBGlKeyOrigin\fR \fIorigin\fR,
     \fBconst char *\fIkeyseq\fR, \fBconst char *\fIaction\fR);
.fi

.LP
.nf
\fBint\fR \fBgl_save_history\fR(\fBGetLine *\fIgl\fR, \fBconst char *\fIfilename\fR,
     \fBconst char *\fIcomment\fR, \fBint\fR \fImax_lines\fR);
.fi

.LP
.nf
\fBint\fR \fBgl_load_history\fR(\fBGetLine *\fIgl\fR, \fBconst char *\fIfilename\fR,
     \fBconst char *\fIcomment\fR);
.fi

.LP
.nf
\fBint\fR \fBgl_watch_fd\fR(\fBGetLine *\fIgl\fR, \fBint\fR \fIfd\fR, \fBGlFdEvent\fR \fIevent\fR,
     \fBGlFdEventFn *\fIcallback\fR, \fBvoid *\fIdata\fR);
.fi

.LP
.nf
\fBint\fR \fBgl_inactivity_timeout\fR(\fBGetLine *\fIgl\fR, \fBGlTimeoutFn *\fIcallback\fR,
     \fBvoid *\fIdata\fR, \fBunsigned long\fR \fIsec\fR, \fBunsigned long\fR \fInsec\fR);
.fi

.LP
.nf
\fBint\fR \fBgl_group_history\fR(\fBGetLine *\fIgl\fR, \fBunsigned\fR \fIstream\fR);
.fi

.LP
.nf
\fBint\fR \fBgl_show_history\fR(\fBGetLine *\fIgl\fR, \fBFILE *\fIfp\fR, \fBconst char *\fIfmt\fR,
     \fBint\fR \fIall_groups\fR, \fBint\fR \fImax_lines\fR);
.fi

.LP
.nf
\fBint\fR \fBgl_resize_history\fR(\fBGetLine *\fIgl\fR, \fBsize_t\fR \fIbufsize\fR);
.fi

.LP
.nf
\fBvoid\fR \fBgl_limit_history\fR(\fBGetLine *\fIgl\fR, \fBint\fR \fImax_lines\fR);
.fi

.LP
.nf
\fBvoid\fR \fBgl_clear_history\fR(\fBGetLine *\fIgl\fR, \fBint\fR \fIall_groups\fR);
.fi

.LP
.nf
\fBvoid\fR \fBgl_toggle_history\fR(\fBGetLine *\fIgl\fR, \fBint\fR \fIenable\fR);
.fi

.LP
.nf
\fBGlTerminalSize\fR \fBgl_terminal_size\fR(\fBGetLine *\fIgl\fR, \fBint\fR \fIdef_ncolumn\fR,
     \fBint\fR \fIdef_nline\fR);
.fi

.LP
.nf
\fBint\fR \fBgl_set_term_size\fR(\fBGetLine *\fIgl\fR, \fBint\fR \fIncolumn\fR, \fBint\fR \fInline\fR);
.fi

.LP
.nf
\fBint\fR \fBgl_lookup_history\fR(\fBGetLine *\fIgl\fR, \fBunsigned long\fR \fIid\fR,
     \fBGlHistoryLine *\fIhline\fR);
.fi

.LP
.nf
\fBvoid\fR \fBgl_state_of_history\fR(\fBGetLine *\fIgl\fR, \fBGlHistoryState *\fIstate\fR);
.fi

.LP
.nf
\fBvoid\fR \fBgl_range_of_history\fR(\fBGetLine *\fIgl\fR, \fBGlHistoryRange *\fIrange\fR);
.fi

.LP
.nf
\fBvoid\fR \fBgl_size_of_history\fR(\fBGetLine *\fIgl\fR, \fBGlHistorySize *\fIsize\fR);
.fi

.LP
.nf
\fBvoid\fR \fBgl_echo_mode\fR(\fBGetLine *\fIgl\fR, \fBint\fR \fIenable\fR);
.fi

.LP
.nf
\fBvoid\fR \fBgl_replace_prompt\fR(\fBGetLine *\fIgl\fR, \fBconst char *\fIprompt\fR);
.fi

.LP
.nf
\fBvoid\fR \fBgl_prompt_style\fR(\fBGetLine *\fIgl\fR, \fBGlPromptStyle\fR \fIstyle\fR);
.fi

.LP
.nf
\fBint\fR \fBgl_ignore_signal\fR(\fBGetLine *\fIgl\fR, \fBint\fR \fIsigno\fR);
.fi

.LP
.nf
\fBint\fR \fBgl_trap_signal\fR(\fBGetLine *\fIgl\fR, \fBint\fR \fIsigno\fR, \fBunsigned\fR \fIflags\fR,
     \fBGlAfterSignal\fR \fIafter\fR, \fBint\fR \fIerrno_value\fR);
.fi

.LP
.nf
\fBint\fR \fBgl_last_signal\fR(\fBGetLine *\fIgl\fR);
.fi

.LP
.nf
\fBint\fR \fBgl_completion_action\fR(\fBGetLine *\fIgl\fR, \fBvoid *\fIdata\fR,
     \fBCplMatchFn *\fImatch_fn\fR, \fBint\fR \fIlist_only\fR, \fBconst char *\fIname\fR,
     \fBconst char *\fIkeyseq\fR);
.fi

.LP
.nf
\fBint\fR \fBgl_register_action\fR(\fBGetLine *\fIgl\fR, \fBvoid *\fIdata\fR, \fBGlActionFn *\fIfn\fR,
     \fBconst char *\fIname\fR, \fBconst char *\fIkeyseq\fR);
.fi

.LP
.nf
\fBint\fR \fBgl_display_text\fR(\fBGetLine *\fIgl\fR, \fBint\fR \fIindentation\fR,
     \fBconst char *\fIprefix\fR, \fBconst char *\fIsuffix\fR, \fBint\fR \fIfill_char\fR,
     \fBint\fR \fIdef_width\fR, \fBint\fR \fIstart\fR, \fBconst char *\fIstring\fR);
.fi

.LP
.nf
\fBGlReturnStatus\fR \fBgl_return_status\fR(\fBGetLine *\fIgl\fR);
.fi

.LP
.nf
\fBconst char *\fBgl_error_message\fR(\fBGetLine *\fIgl\fR, \fBchar *\fIbuff\fR, \fBsize_t\fR \fIn\fR);
.fi

.LP
.nf
\fBvoid\fR \fBgl_catch_blocked\fR(\fBGetLine *\fIgl\fR);
.fi

.LP
.nf
\fBint\fR \fBgl_list_signals\fR(\fBGetLine *\fIgl\fR, \fBsigset_t *\fIset\fR);
.fi

.LP
.nf
\fBint\fR \fBgl_append_history\fR(\fBGetLine *\fIgl\fR, \fBconst char *\fIline\fR);
.fi

.LP
.nf
\fBint\fR \fBgl_automatic_history\fR(\fBGetLine *\fIgl\fR, \fBint\fR \fIenable\fR);
.fi

.LP
.nf
\fBint\fR \fBgl_erase_terminal\fR(\fBGetLine *\fIgl\fR);
.fi

.SH DESCRIPTION
.sp
.LP
The
.B gl_get_line()
function is part of the
.BR libtecla (3LIB)
library. If the user is typing at a terminal, each call prompts them for an
line of input, then provides interactive editing facilities, similar to
those of the UNIX
.B tcsh
shell. In addition to simple command-line
editing, it supports recall of previously entered command lines, TAB
completion of file names, and in-line wild-card expansion of filenames.
Documentation of both the user-level command-line editing features and all
user configuration options can be found on the
.BR tecla (5)
manual page.
.SS "An Example"
.sp
.LP
The following shows a complete example of how to use the
.B gl_get_line()
function to get input from the user:
.sp
.in +2
.nf
#include <stdio.h>
#include <locale.h>
#include <libtecla.h>

int main(int argc, char *argv[])
{
  char *line;    /* The line that the user typed */
  GetLine *gl;   /* The gl_get_line() resource object */

  setlocale(LC_CTYPE, ""); /* Adopt the user's choice */
                           /* of character set. */

  gl = new_GetLine(1024, 2048);
  if(!gl)
    return 1;
  while((line=gl_get_line(gl, "$ ", NULL, -1)) != NULL &&
         strcmp(line, "exit\en") != 0)
    printf("You typed: %s\en", line);

  gl = del_GetLine(gl);
  return 0;
}
.fi
.in -2

.sp
.LP
In the example, first the resources needed by the
.B gl_get_line()
function are created by calling
.BR new_GetLine() .
This allocates the
memory used in subsequent calls to the
.B gl_get_line()
function,
including the history buffer for recording previously entered lines. Then
one or more lines are read from the user, until either an error occurs, or
the user types exit. Then finally the resources that were allocated by
.BR new_GetLine() ,
are returned to the system by calling
.BR del_GetLine() .
Note the use of the
.I NULL
return value of
.B del_GetLine()
to make
.IR "gl NULL" .
This is a safety
precaution. If the program subsequently attempts to pass
.I gl
to
.BR gl_get_line() ,
said function will complain, and return an error,
instead of attempting to use the deleted resource object.
.SS "The Functions Used In The Example"
.sp
.LP
The
.B new_GetLine()
function creates the resources used by the
.B gl_get_line()
function and returns an opaque pointer to the object
that contains them. The maximum length of an input line is specified by the
.I linelen
argument, and the number of bytes to allocate for storing
history lines is set by the
.I histlen
argument. History lines are stored
back-to-back in a single buffer of this size. Note that this means that the
number of history lines that can be stored at any given time, depends on the
lengths of the individual lines. If you want to place an upper limit on the
number of lines that can be stored, see the description of the
.B gl_limit_history()
function. If you do not want history at all,
specify
.I histlen
as zero, and no history buffer will be allocated.
.sp
.LP
On error, a message is printed to
.B stderr
and
.I NULL
is
returned.
.sp
.LP
The
.B del_GetLine()
function deletes the resources that were returned
by a previous call to
.BR new_GetLine() .
It always returns
.I NULL
(for
example, a deleted object). It does nothing if the
.I gl
argument is
.IR NULL .
.sp
.LP
The
.B gl_get_line()
function can be called any number of times to read
input from the user. The gl argument must have been previously returned by a
call to
.BR new_GetLine() .
The
.I prompt
argument should be a normal
null-terminated string, specifying the prompt to present the user with. By
default prompts are displayed literally, but if enabled with the
.B gl_prompt_style()
function, prompts can contain directives to do
underlining, switch to and from bold fonts, or turn highlighting on and
off.
.sp
.LP
If you want to specify the initial contents of the line for the user to
edit, pass the desired string with the
.I start_line
argument. You can
then specify which character of this line the cursor is initially positioned
over by using the
.I start_pos
argument. This should be -1 if you want
the cursor to follow the last character of the start line. If you do not
want to preload the line in this manner, send
.I start_line
as
.IR NULL ,
and set
.I start_pos
to -1.
.sp
.LP
The
.B gl_get_line()
function returns a pointer to the line entered by
the user, or
.I NULL
on error or at the end of the input. The returned
pointer is part of the specified
.I gl
resource object, and thus should
not be freed by the caller, or assumed to be unchanging from one call to the
next. When reading from a user at a terminal, there will always be a newline
character at the end of the returned line. When standard input is being
taken from a pipe or a file, there will similarly be a newline unless the
input line was too long to store in the internal buffer. In the latter case
you should call
.B gl_get_line()
again to read the rest of the line. Note
that this behavior makes
.B gl_get_line()
similar to
.BR fgets (3C).
When
.B stdin
is not connected to a terminal,
.B gl_get_line()
simply
calls
.BR fgets() .
.SS "The Return Status Of \fBgl_get_line()\fR"
.sp
.LP
The
.B gl_get_line()
function has two possible return values: a pointer
to the completed input line, or
.IR NULL .
Additional information about
what caused
.B gl_get_line()
to return is available both by inspecting
.B errno
and by calling the
.B gl_return_status()
function.
.sp
.LP
The following are the possible enumerated values returned by
.BR gl_return_status() :
.sp
.ne 2
.mk
.na
.B GLR_NEWLINE
.ad
.RS 15n
.rt
The last call to
.B gl_get_line()
successfully returned a completed
input line.
.RE

.sp
.ne 2
.mk
.na
.B GLR_BLOCKED
.ad
.RS 15n
.rt
The
.B gl_get_line()
function was in non-blocking server mode, and
returned early to avoid blocking the process while waiting for terminal I/O.
The
.B gl_pending_io()
function can be used to see what type of I/O
.B gl_get_line()
was waiting for. See the
.BR gl_io_mode (3TECLA).
.RE

.sp
.ne 2
.mk
.na
.B GLR_SIGNAL
.ad
.RS 15n
.rt
A signal was caught by
.B gl_get_line()
that had an after-signal
disposition of
.BR GLS_ABORT .
See
.BR gl_trap_signal() .
.RE

.sp
.ne 2
.mk
.na
.B GLR_TIMEOUT
.ad
.RS 15n
.rt
The inactivity timer expired while
.B gl_get_line()
was waiting for
input, and the timeout callback function returned
.BR GLTO_ABORT .
See
.B gl_inactivity_timeout()
for information about timeouts.
.RE

.sp
.ne 2
.mk
.na
.B GLR_FDABORT
.ad
.RS 15n
.rt
An application I/O callback returned
.BR GLFD_ABORT .
Ssee
.BR gl_watch_fd() .
.RE

.sp
.ne 2
.mk
.na
.B GLR_EOF
.ad
.RS 15n
.rt
End of file reached. This can happen when input is coming from a file or a
pipe, instead of the terminal. It also occurs if the user invokes the
list-or-eof or del-char-or-list-or-eof actions at the start of a new line.
.RE

.sp
.ne 2
.mk
.na
.B GLR_ERROR
.ad
.RS 15n
.rt
An unexpected error caused
.B gl_get_line()
to abort (consult
.B errno
and/or
.B gl_error_message()
for details.
.RE

.sp
.LP
When
.B gl_return_status()
returns
.B GLR_ERROR
and the value of
.B errno
is not sufficient to explain what happened, you can use the
.B gl_error_message()
function to request a description of the last error
that occurred.
.sp
.LP
The return value of
.B gl_error_message()
is a pointer to the message
that occurred. If the
.I buff
argument is
.IR NULL ,
this will be a
pointer to a buffer within
.I gl
whose value will probably change on the
next call to any function associated with
.BR gl_get_line() .
Otherwise, if
a non-null
.I buff
argument is provided, the error message, including a
\&'\e0' terminator, will be written within the first
.I n
elements of
this buffer, and the return value will be a pointer to the first element of
this buffer. If the message will not fit in the provided buffer, it will be
truncated to fit.
.SS "Optional Prompt Formatting"
.sp
.LP
Whereas by default the prompt string that you specify is displayed
literally without any special interpretation of the characters within it,
the
.B gl_prompt_style()
function can be used to enable optional
formatting directives within the prompt.
.sp
.LP
The
.I style
argument, which specifies the formatting style, can take
any of the following values:
.sp
.ne 2
.mk
.na
.B GL_FORMAT_PROMPT
.ad
.RS 21n
.rt
In this style, the formatting directives described below, when included in
prompt strings, are interpreted as follows:
.sp
.ne 2
.mk
.na
.B %B
.ad
.RS 6n
.rt
Display subsequent characters with a bold font.
.RE

.sp
.ne 2
.mk
.na
.B %b
.ad
.RS 6n
.rt
Stop displaying characters with the bold font.
.RE

.sp
.ne 2
.mk
.na
.B %F
.ad
.RS 6n
.rt
Make subsequent characters flash.
.RE

.sp
.ne 2
.mk
.na
.B %f
.ad
.RS 6n
.rt
Turn off flashing characters.
.RE

.sp
.ne 2
.mk
.na
.B %U
.ad
.RS 6n
.rt
Underline subsequent characters.
.RE

.sp
.ne 2
.mk
.na
.B %u
.ad
.RS 6n
.rt
Stop underlining characters.
.RE

.sp
.ne 2
.mk
.na
.B %P
.ad
.RS 6n
.rt
Switch to a pale (half brightness) font.
.RE

.sp
.ne 2
.mk
.na
.B %p
.ad
.RS 6n
.rt
Stop using the pale font.
.RE

.sp
.ne 2
.mk
.na
.B %S
.ad
.RS 6n
.rt
Highlight subsequent characters (also known as standout mode).
.RE

.sp
.ne 2
.mk
.na
.B %s
.ad
.RS 6n
.rt
Stop highlighting characters.
.RE

.sp
.ne 2
.mk
.na
.B %V
.ad
.RS 6n
.rt
Turn on reverse video.
.RE

.sp
.ne 2
.mk
.na
.B %v
.ad
.RS 6n
.rt
Turn off reverse video.
.RE

.sp
.ne 2
.mk
.na
.B %%
.ad
.RS 6n
.rt
Display a single % character.
.RE

For example, in this mode, a prompt string like "%UOK%u$" would display the
prompt "OK$", but with the OK part underlined.
.sp
Note that although a pair of characters that starts with a % character, but
does not match any of the above directives is displayed literally, if a new
directive is subsequently introduced which does match, the displayed prompt
will change, so it is better to always use %% to display a literal %.
.sp
Also note that not all terminals support all of these text attributes, and
that some substitute a different attribute for missing ones.
.RE

.sp
.ne 2
.mk
.na
.B GL_LITERAL_PROMPT
.ad
.RS 21n
.rt
In this style, the prompt string is printed literally. This is the default
style.
.RE

.SS "Alternate Configuration Sources"
.sp
.LP
By default users have the option of configuring the behavior of
.B gl_get_line()
with a configuration file called \fB\&.teclarc\fR in
their home directories. The fact that all applications share this same
configuration file is both an advantage and a disadvantage. In most cases it
is an advantage, since it encourages uniformity, and frees the user from
having to configure each application separately. In some applications,
however, this single means of configuration is a problem. This is
particularly true of embedded software, where there's no filesystem to read
a configuration file from, and also in applications where a radically
different choice of keybindings is needed to emulate a legacy keyboard
interface. To cater for such cases, the
.B gl_configure_getline()
function allows the application to control where configuration information
is read from.
.sp
.LP
The
.B gl_configure_getline()
function allows the configuration commands
that would normally be read from a user's
.B ~/.teclarc
file, to be read
from any or none of, a string, an application specific configuration file,
and/or a user-specific configuration file. If this function is called before
the first call to
.BR gl_get_line() ,
the default behavior of reading
.B ~/.teclarc
on the first call to
.B gl_get_line()
is disabled, so
all configurations must be achieved using the configuration sources
specified with this function.
.sp
.LP
If
.I app_string
!=
.IR NULL ,
then it is interpreted as a string
containing one or more configuration commands, separated from each other in
.RI "the string by embedded newline  characters. If " app_file " != " NULL 
then it is interpreted as the full pathname of an application-specific
configuration file. If user_file !=
.I NULL
then it is interpreted as the
full path name of a user-specific configuration file, such as
.BR ~/.teclarc .
For example, in the call
.sp
.in +2
.nf
gl_configure_getline(gl, "edit-mode vi \en nobeep",
                     "/usr/share/myapp/teclarc", "~/.teclarc");
.fi
.in -2

.sp
.LP
The
.I app_string
argument causes the calling application to start in
.BR vi (1)
edit-mode, instead of the default
.B emacs
mode, and turns
off the use of the terminal bell by the library. It then attempts to read
system-wide configuration commands from an optional file called
.BR /usr/share/myapp/teclarc ,
then finally reads user-specific
configuration commands from an optional \fB\&.teclarc\fR file in the user's
home directory. Note that the arguments are listed in ascending order of
priority, with the contents of
.I app_string
being potentially over riden
by commands in
.IR app_file ,
and commands in
.I app_file
potentially
being overriden by commands in
.IR user_file .
.sp
.LP
You can call this function as many times as needed, the results being
cumulative, but note that copies of any file names specified with the
.I app_file
and
.I user_file
arguments are recorded internally for
subsequent use by the read-init-files key-binding function, so if you plan
to call this function multiple times, be sure that the last call specifies
the filenames that you want re-read when the user requests that the
configuration files be re-read.
.sp
.LP
Individual key sequences can also be bound and unbound using the
.B gl_bind_keyseq()
function. The
.I origin
argument specifies the
priority of the binding, according to whom it is being established for, and
must be one of the following two values.
.sp
.ne 2
.mk
.na
.B GL_USER_KEY
.ad
.RS 15n
.rt
The user requested this key-binding.
.RE

.sp
.ne 2
.mk
.na
.B GL_APP_KEY
.ad
.RS 15n
.rt
This is a default binding set by the application.
.RE

.sp
.LP
When both user and application bindings for a given key sequence have been
specified, the user binding takes precedence. The application's binding is
subsequently reinstated if the user's binding is later unbound with either
another call to this function, or a call to
.BR gl_configure_getline() .
.sp
.LP
The
.I keyseq
argument specifies the key sequence to be bound or
.RB "unbound, and is expressed in the same way as in a" " ~/.teclarc"
configuration file. The
.I action
argument must either be a string
containing the name of the action to bind the key sequence to, or it must be
\fINULL\fR or \fB""\fR to unbind the key sequence.
.SS "Customized Word Completion"
.sp
.LP
If in your application you would like to have TAB completion complete other
things in addition to or instead of filenames, you can arrange this by
registering an alternate completion callback function with a call to the
.B gl_customize_completion()
function.
.sp
.LP
The
.I data
argument provides a way for your application to pass
arbitrary, application-specific information to the callback function. This
is passed to the callback every time that it is called. It might for example
point to the symbol table from which possible completions are to be sought.
The
.I match_fn
argument specifies the callback function to be called.
The
.I CplMatchFn
function type is defined in
.RB < libtecla.h >,
as is a
.B CPL_MATCH_FN()
macro that you can use to declare and prototype
callback functions. The declaration and responsibilities of callback
functions are described in depth on the
.BR cpl_complete_word (3TECLA)
manual page.
.sp
.LP
The callback function is responsible for looking backwards in the input
line from the point at which the user pressed TAB, to find the start of the
word being completed. It then must lookup possible completions of this word,
and record them one by one in the
.B WordCompletion
object that is passed
to it as an argument, by calling the
.B cpl_add_completion()
function. If
the callback function wants to provide filename completion in addition to
its own specific completions, it has the option of itself calling the
builtin filename completion callback. This also is documented on the
.BR cpl_complete_word (3TECLA)
manual page.
.sp
.LP
If you would like
.B gl_get_line()
to return the current input line when
a successful completion is been made, you can arrange this when you call
.B cpl_add_completion()
by making the last character of the continuation
suffix a newline character. The input line will be updated to display the
completion, together with any contiuation suffix up to the newline
character, and
.B gl_get_line()
will return this input line.
.sp
.LP
If your callback function needs to write something to the terminal, it must
call
.B gl_normal_io()
before doing so. This will start a new line after
the input line that is currently being edited, reinstate normal terminal
I/O, and notify
.B gl_get_line()
that the input line will need to be
redrawn when the callback returns.
.SS "Adding Completion Actions"
.sp
.LP
In the previous section the ability to customize the behavior of the only
default completion action, complete-word, was described. In this section the
ability to install additional action functions, so that different types of
word completion can be bound to different key sequences, is described. This
is achieved by using the
.B gl_completion_action()
function.
.sp
.LP
The
.I data
and
.I match_fn
arguments are as described on the
.BR cpl_complete_word (3TECLA)
manual page, and specify the callback
function that should be invoked to identify possible completions. The
.I list_only
argument determines whether the action that is being defined
should attempt to complete the word as far as possible in the input line
before displaying any possible ambiguous completions, or whether it should
simply display the list of possible completions without touching the input
line. The former option is selected by specifying a value of 0, and the
latter by specifying a value of 1. The
.I name
argument specifies the
name by which configuration files and future invocations of this function
should refer to the action. This must either be the name of an existing
completion action to be changed, or be a new unused name for a new action.
Finally, the
.I keyseq
argument specifies the default key sequence to
bind the action to. If this is
.IR NULL ,
no new key sequence will be bound
to the action.
.sp
.LP
Beware that in order for the user to be able to change the key sequence
that is bound to actions that are installed in this manner, you shouldcall
.B gl_completion_action()
to install a given action for the first time
between calling
.B new_GetLine()
and the first call to
.BR gl_get_line() .
Otherwise, when the user's configuration file is read
on the first call to
.BR gl_get_line() ,
the name of the your additional
action will not be known, and any reference to it in the configuration file
will generate an error.
.sp
.LP
As discussed for
.BR gl_customize_completion() ,
if your callback function
.RB "needs to write anything to the terminal, it must call" " gl_normal_io()"
before doing so.
.SS "Defining Custom Actions"
.sp
.LP
Although the built-in key-binding actions are sufficient for the needs of
most applications, occasionally a specialized application may need to define
one or more custom actions, bound to application-specific key sequences. For
example, a sales application would benefit from having a key sequence that
displayed the part name that corresponded to a part number preceding the
cursor. Such a feature is clearly beyond the scope of the built-in action
functions. So for such special cases, the
.B gl_register_action()
function is provided.
.sp
.LP
The
.B gl_register_action()
function lets the application register an
external function,
.IR fn ,
that will thereafter be called whenever either
the specified key sequence,
.IR keyseq ,
is entered by the user, or the
user enters any other key sequence that the user subsequently binds to the
specified action name,
.IR name ,
in their configuration file. The
.I data
argument can be a pointer to anything that the application wants
to have passed to the action function,
.IR fn ,
whenever that function is
invoked.
.sp
.LP
The action function,
.IR fn ,
should be declared using the
.B GL_ACTION_FN()
macro, which is defined in
.RB < libtecla.h >.
.sp
.in +2
.nf
#define GL_ACTION_FN(fn) GlAfterAction (fn)(GetLine *gl, \e
                       void *data, int count, size_t curpos, \e
                       const char *line)
.fi
.in -2

.sp
.LP
The
.I gl
and
.I data
arguments are those that were previously passed
to
.B gl_register_action()
when the action function was registered. The
.I count
argument is a numeric argument which the user has the option of
entering using the digit-argument action, before invoking the action. If the
user does not enter a number, then the
.I count
argument is set to 1.
Nominally this argument is interpreted as a repeat count, meaning that the
action should be repeated that many times. In practice however, for some
actions a repeat count makes little sense. In such cases, actions can either
simply ignore the
.I count
argument, or use its value for a different
purpose.
.sp
.LP
A copy of the current input line is passed in the read-only
.I line
argument. The current cursor position within this string is given by the
index contained in the
.I curpos
argument. Note that direct manipulation
of the input line and the cursor position is not permitted because the rules
dictated by various modes (such as
.B vi
mode versus
.B emacs
mode,
no-echo mode, and insert mode versus overstrike mode) make it too complex
for an application writer to write a conforming editing action, as well as
constrain future changes to the internals of
.BR gl_get_line() .
A
potential solution to this dilemma would be to allow the action function to
edit the line using the existing editing actions. This is currently under
consideration.
.sp
.LP
If the action function wishes to write text to the terminal without this
getting mixed up with the displayed text of the input line, or read from the
terminal without having to handle raw terminal I/O, then before doing either
of these operations, it must temporarily suspend line editing by calling the
.B gl_normal_io()
function. This function flushes any pending output to
the terminal, moves the cursor to the start of the line that follows the
last terminal line of the input line, then restores the terminal to a state
that is suitable for use with the C
.B stdio
facilities. The latter
includes such things as restoring the normal mapping of \en to \er\en, and,
when in server mode, restoring the normal blocking form of terminal I/O.
Having called this function, the action function can read from and write to
the terminal without the fear of creating a mess. It is not necessary for
the action function to restore the original editing environment before it
returns. This is done automatically by
.B gl_get_line()
after the action
function returns. The following is a simple example of an action function
which writes the sentence "Hello world" on a new terminal line after the
line being edited. When this function returns, the input line is redrawn on
the line that follows the "Hello world" line, and line editing resumes.
.sp
.in +2
.nf
static GL_ACTION_FN(say_hello_fn)
{
    if(gl_normal_io(gl))   /* Temporarily suspend editing */
        return GLA_ABORT;
    printf("Hello world\en");
    return GLA_CONTINUE;
}
.fi
.in -2

.sp
.LP
Action functions must return one of the following values, to tell
.B gl_get_line()
how to proceed.
.sp
.ne 2
.mk
.na
.B GLA_ABORT
.ad
.RS 16n
.rt
Cause
.B gl_get_line()
to return
.IR NULL .
.RE

.sp
.ne 2
.mk
.na
.B GLA_RETURN
.ad
.RS 16n
.rt
Cause
.B gl_get_line()
to return the completed input line
.RE

.sp
.ne 2
.mk
.na
.B GLA_CONTINUE
.ad
.RS 16n
.rt
Resume command-line editing.
.RE

.sp
.LP
Note that the
.I name
argument of
.B gl_register_action()
specifies
the name by which a user can refer to the action in their configuration
file. This allows them to re-bind the action to an alternate key-seqeunce.
In order for this to work, it is necessary to call
.B gl_register_action()
between calling
.B new_GetLine()
and the first
call to
.BR gl_get_line() .
.SS "History Files"
.sp
.LP
To save the contents of the history buffer before quitting your application
and subsequently restore them when you next start the application, the
.B gl_save_history()
and
.B gl_load_history()
functions are
provided.
.sp
.LP
The
.I filename
argument specifies the name to give the history file
when saving, or the name of an existing history file, when loading. This may
contain home directory and environment variable expressions, such as
.B ~/.myapp_history
or
.BR $HOME/.myapp_history .
.sp
.LP
Along with each history line, additional information about it, such as its
nesting level and when it was entered by the user, is recorded as a comment
preceding the line in the history file. Writing this as a comment allows the
history file to double as a command file, just in case you wish to replay a
whole session using it. Since comment prefixes differ in different
languages, the comment argument is provided for specifying the comment
prefix. For example, if your application were a UNIX  shell, such as the
Bourne shell, you would specify "#" here. Whatever you choose for the
comment character, you must specify the same prefix to
.B gl_load_history()
that you used when you called
.B gl_save_history()
to write the history file.
.sp
.LP
The
.I max_lines
argument must be either -1 to specify that all lines in
the history list be saved, or a positive number specifying a ceiling on how
many of the most recent lines should be saved.
.sp
.LP
Both fuctions return non-zero on error, after writing an error message to
.BR stderr .
Note that
.B gl_load_history()
does not consider the
non-existence of a file to be an error.
.SS "Multiple History Lists"
.sp
.LP
If your application uses a single
.B GetLine
object for entering many
different types of input lines, you might want
.B gl_get_line()
to
distinguish the different types of lines in the history list, and only
recall lines that match the current type of line. To support this
requirement,
.B gl_get_line()
marks lines being recorded in the history
list with an integer identifier chosen by the application. Initially this
identifier is set to 0 by
.BR new_GetLine() ,
but it can be changed
subsequently by calling
.BR gl_group_history() .
.sp
.LP
The integer identifier ID can be any number chosen by the application, but
note that
.B gl_save_history()
and
.B gl_load_history()
preserve the
association between identifiers and historical input lines between program
invocations, so you should choose fixed identifiers for the different types
of input line used by your application.
.sp
.LP
Whenever
.B gl_get_line()
appends a new input line to the history list,
the current history identifier is recorded with it, and when it is asked to
recall a historical input line, it only recalls lines that are marked with
the current identifier.
.SS "Displaying History"
.sp
.LP
The history list can be displayed by calling
.BR gl_show_history() .
This
function displays the current contents of the history list to the
.B stdio
output stream
.IR fp .
If the
.I max_lines
argument is
greater than or equal to zero, then no more than this number of  the most
recent lines will be displayed. If the
.I all_groups
argument is
non-zero, lines from all history groups are displayed. Otherwise only those
of the currently selected history group are displayed. The format string
argument,
.IR fmt ,
determines how the line is displayed. This can contain
arbitrary characters which are written verbatim, interleaved with any of the
following format directives:
.sp
.ne 2
.mk
.na
.B %D
.ad
.RS 6n
.rt
The date on which the line was originally entered, formatted like
2001-11-20.
.RE

.sp
.ne 2
.mk
.na
.B %T
.ad
.RS 6n
.rt
The time of day when the line was entered, formatted like 23:59:59.
.RE

.sp
.ne 2
.mk
.na
.B %N
.ad
.RS 6n
.rt
The sequential entry number of the line in the history buffer.
.RE

.sp
.ne 2
.mk
.na
.B %G
.ad
.RS 6n
.rt
The number of the history group which the line belongs to.
.RE

.sp
.ne 2
.mk
.na
.B %%
.ad
.RS 6n
.rt
A literal % character.
.RE

.sp
.ne 2
.mk
.na
.B %H
.ad
.RS 6n
.rt
The history line itself.
.RE

.sp
.LP
Thus a format string like "%D %T %H0" would output something like:
.sp
.in +2
.nf
2001-11-20 10:23:34  Hello world
.fi
.in -2

.sp
.LP
Note the inclusion of an explicit newline character in the format string.
.SS "Looking Up History"
.sp
.LP
The
.B gl_lookup_history()
function allows the calling application to
look up lines in the history list.
.sp
.LP
The
.I id
argument indicates which line to look up, where the first line
that was entered in the history list after
.B new_GetLine()
was called is
denoted by 0, and subsequently entered lines are denoted with successively
higher numbers. Note that the range of lines currently preserved in the
history list can be queried by calling the
.B gl_range_of_history()
function. If the requested line is in the history list, the details of the
line are recorded in the variable pointed to by the
.I hline
argument,
and 1 is returned. Otherwise 0 is returned, and the variable pointed to by
.I hline
is left unchanged.
.sp
.LP
.RI "Beware that the string returned in " hline -> line " is part of the"
history buffer, so it must not be modified by the caller, and will be
recycled on the next call to any function that takes
.I gl
as its
argument. Therefore you should make a private copy of this string if you
need to keep it.
.SS "Manual History Archival"
.sp
.LP
By default, whenever a line is entered by the user, it is automatically
appended to the history list, just before
.B gl_get_line()
returns the
line to the caller. This is convenient for the majority of applications, but
there are also applications that need finer-grained control over what gets
added to the history list. In such cases, the automatic addition of entered
lines to the history list can be turned off by calling the
.B gl_automatic_history()
function.
.sp
.LP
If this function is called with its
.I enable
argument set to 0,
.B gl_get_line()
will not automatically archive subsequently entered
lines. Automatic archiving can be reenabled at a later time by calling this
function again, with its
.I enable
argument set to 1. While automatic
history archiving is disabled, the calling application can use the
.B gl_append_history()
to append lines to the history list as needed.
.sp
.LP
The
.I line
argument specifies the line to be added to the history list.
This must be a normal '\e0 ' terminated string. If this string contains any
newline characters, the line that gets archived in the history list will be
terminated by the first of these. Otherwise it will be terminated by the
\&'\e0 ' terminator. If the line is longer than the maximum input line
length that was specified when
.B new_GetLine()
was called, it will be
truncated to the actual
.B gl_get_line()
line length when the line is
recalled.
.sp
.LP
If successful,
.B gl_append_history()
returns 0. Otherwise it returns
non-zero and sets
.B errno
to one of the following values.
.sp
.ne 2
.mk
.na
.B EINVAL
.ad
.RS 10n
.rt
One of the arguments passed to
.B gl_append_history()
was
.IR NULL .
.RE

.sp
.ne 2
.mk
.na
.B ENOMEM
.ad
.RS 10n
.rt
The specified line was longer than the allocated size of the history buffer
(as specified when
.B new_GetLine()
was called), so it could not be
archived.
.RE

.sp
.LP
A textual description of the error can optionally be obtained by calling
.BR gl_error_message() .
Note that after such an error, the history list
remains in a valid state to receive new history lines, so there is little
harm in simply ignoring the return status of
.BR gl_append_history() .
.SS "Miscellaneous History Configuration"
.sp
.LP
If you wish to change the size of the history buffer that was originally
specified in the call to
.BR new_GetLine() ,
you can do so with the
.B gl_resize_history()
function.
.sp
.LP
The
.I histlen
argument specifies the new size in bytes, and if you
specify this as 0, the buffer will be deleted.
.sp
.LP
As mentioned in the discussion of
.BR new_GetLine() ,
the number of lines
that can be stored in the history buffer, depends on the lengths of the
individual lines. For example, a 1000 byte buffer could equally store 10
lines of average length 100 bytes, or 20 lines of average length 50 bytes.
Although the buffer is never expanded when new lines are added, a list of
pointers into the buffer does get expanded when needed to accomodate the
number of lines currently stored in the buffer. To place an upper limit on
the number of lines in the buffer, and thus a ceiling on the amount of
.RB "memory used in this list, you can call the" " gl_limit_history()"
function.
.sp
.LP
The
.I max_lines
should either be a positive number >= 0, specifying an
upper limit on the number of lines in the buffer, or be -1 to cancel any
previously specified limit. When a limit is in effect, only the
.I max_lines
most recently appended lines are kept in the buffer. Older
lines are discarded.
.sp
.LP
To discard lines from the history buffer, use the
.B gl_clear_history()
function.
.sp
.LP
The
.I all_groups
argument tells the function whether to delete just the
lines associated with the current history group (see
.BR gl_group_history() )
or all historical lines in the buffer.
.sp
.LP
The
.B gl_toggle_history()
function allows you to toggle history on and
off without losing the current contents of the history list.
.sp
.LP
Setting the
.I enable
argument to 0 turns off the history mechanism, and
setting it to 1 turns it back on. When history is turned off, no new lines
will be added to the history list, and history lookup key-bindings will act
as though there is nothing in the history buffer.
.SS "Querying History Information"
.sp
.LP
The configured state of the history list can be queried with the
.B gl_history_state()
function. On return, the status information is
recorded in the variable pointed to by the
.I state
argument.
.sp
.LP
The
.B gl_range_of_history()
function returns the number and range of
lines in the history list. The return values are recorded in the variable
pointed to by the range argument. If the
.I nlines
member of this
structure is greater than zero, then the oldest and newest members report
the range of lines in the list, and
\fInewest\fR=\fIoldest\fR+\fInlines\fR-1. Otherwise they are both zero.
.sp
.LP
The
.B gl_size_of_history()
function returns the total size of the
history buffer and the amount of the buffer that is currently occupied.
.sp
.LP
On return, the size information is recorded in the variable pointed to by
the
.I size
argument.
.SS "Changing Terminals"
.sp
.LP
The
.B new_GetLine()
constructor function assumes that input is to be
read from
.B stdin
and output written to
.BR stdout .
The following
function allows you to switch to different input and output streams.
.sp
.LP
The
.I gl
argument is the object that was returned by
.BR new_GetLine() .
The
.I input_fp
argument specifies the stream to
read from, and
.I output_fp
specifies the stream to be written to. Only
if both of these refer to a terminal, will interactive terminal input be
enabled. Otherwise
.B gl_get_line()
will simply call
.B fgets()
to
read command input. If both streams refer to a terminal, then they must
refer to the same terminal, and the type of this terminal must be specified
with the
.I term
argument. The value of the
.I term
argument is looked
up in the terminal information database (\fBterminfo\fR or
.BR termcap ),
in order to determine which special control sequences are needed to control
various aspects of the terminal.
.B new_GetLine()
for example, passes the
return value of \fBgetenv\fR("TERM") in this argument. Note that if one or
both of
.IR input_fp " and "
.I output_fp
do not refer to a terminal, then
it is legal to pass
.I NULL
instead of a terminal type.
.sp
.LP
Note that if you want to pass file descriptors to
.BR gl_change_terminal() ,
you can do this by creating
.B stdio
stream
wrappers using the POSIX
.BR fdopen (3C)
function.
.SS "External Event Handling"
.sp
.LP
By default,
.B gl_get_line()
does not return until either a complete
input line has been entered by the user, or an error occurs. In programs
that need to watch for I/O from other sources than the terminal, there are
two options.
.RS +4
.TP
.ie t \(bu
.el o
Use the functions described in the
.BR gl_io_mode "(3TECLA) manual page to"
switch
.B gl_get_line()
into non-blocking server mode. In this mode,
.B gl_get_line()
becomes a non-blocking, incremental line-editing
function that can safely be called from an external event loop. Although
this is a very versatile method, it involves taking on some responsibilities
that are normally performed behind the scenes by
.BR gl_get_line() .
.RE
.RS +4
.TP
.ie t \(bu
.el o
While
.B gl_get_line()
is waiting for keyboard input from the user, you
can ask it to also watch for activity on arbitrary file descriptors, such as
network sockets or pipes, and have it call functions of your choosing when
activity is seen. This works on any system that has the select system call,
which is most, if not all flavors of UNIX.
.RE
.sp
.LP
Registering a file descriptor to be watched by
.B gl_get_line()
involves
calling the
.B gl_watch_fd()
function. If this returns non-zero, then it
means that either your arguments are invalid, or that this facility is not
supported on the host system.
.sp
.LP
The
.I fd
argument is the file descriptor to be watched. The event
argument specifies what type of activity is of interest, chosen from the
following enumerated values:
.sp
.ne 2
.mk
.na
.B GLFD_READ
.ad
.RS 15n
.rt
Watch for the arrival of data to be read.
.RE

.sp
.ne 2
.mk
.na
.B GLFD_WRITE
.ad
.RS 15n
.rt
Watch for the ability to write to the file descriptor without blocking.
.RE

.sp
.ne 2
.mk
.na
.B GLFD_URGENT
.ad
.RS 15n
.rt
Watch for the arrival of urgent out-of-band data on the file descriptor.
.RE

.sp
.LP
The
.I callback
argument is the function to call when the selected
activity is seen. It should be defined with the following macro, which is
defined in libtecla.h.
.sp
.in +2
.nf
#define GL_FD_EVENT_FN(fn) GlFdStatus (fn)(GetLine *gl, \
                                   void *data, int fd, GlFdEvent event)
.fi
.in -2

.sp
.LP
The data argument of the
.B gl_watch_fd()
function is passed to the
callback function for its own use, and can point to anything you like,
including
.IR NULL .
The file descriptor and the event argument are also
passed to the callback function, and this potentially allows the same
callback function to be registered to more than one type of event and/or
more than one file descriptor. The return value of the callback function
should be one of the following values.
.sp
.ne 2
.mk
.na
.B GLFD_ABORT
.ad
.RS 17n
.rt
Tell
.B gl_get_line()
.RB "to abort. When this happens," " gl_get_line()"
returns
.IR NULL ,
and a following call to
.B gl_return_status()
will
return
.BR GLR_FDABORT .
Note that if the application needs
.BR errno
always to have a meaningful value when
.B gl_get_line()
returns
.IR NULL ,
the callback function should set
.B errno
appropriately.
.RE

.sp
.ne 2
.mk
.na
.B GLFD_REFRESH
.ad
.RS 17n
.rt
Redraw the input line  then continue waiting for input. Return this if your
callback wrote to the terminal.
.RE

.sp
.ne 2
.mk
.na
.B GLFD_CONTINUE
.ad
.RS 17n
.rt
Continue to wait for input, without redrawing the line.
.RE

.sp
.LP
Note that before calling the callback,
.B gl_get_line()
blocks most
signals and leaves its own signal handlers installed, so if you need to
catch a particular signal you will need to both temporarily install your own
signal handler, and unblock the signal. Be sure to re-block the signal (if
it was originally blocked) and reinstate the original signal handler, if
any, before returning.
.sp
.LP
Your callback should not try to read from the terminal, which is left in
raw mode as far as input is concerned. You can write to the terminal as
usual, since features like conversion of newline to carriage-return/linefeed
are re-enabled while the callback is running. If your callback function does
write to the terminal, be sure to output a newline first, and when your
callback returns, tell
.B gl_get_line()
that the input line needs to be
redrawn, by returning the
.B GLFD_REFRESH
status code.
.sp
.LP
To remove a callback function that you previously registered for a given
file descriptor and event, simply call
.B gl_watch_fd()
with the same
.I fd
and
.I event
arguments, but with a
.I callback
argument of 0.
The
.I data
argument is ignored in this case.
.SS "Setting An Inactivity Timeout"
.sp
.LP
The
.B gl_inactivity_timeout()
function can be used to set or cancel an
inactivity timeout. Inactivity in this case refers both to keyboard input,
and to I/O on any file descriptors registered by prior and subsequent calls
to
.BR gl_watch_fd() .
.sp
.LP
The timeout is specified in the form of an integral number of seconds and
an integral number of nanoseconds, specified by the
.I sec
and
.IR nsec
arguments, respectively. Subsequently, whenever no activity is seen for this
time period, the function specified by the
.I callback
argument is
called. The
.I data
argument of
.B gl_inactivity_timeout()
is passed
to this callback function whenever it is invoked, and can thus be used to
pass arbitrary application-specific information to the callback. The
following macro is provided in
.RB < libtecla.h >
for applications to use to
declare and prototype timeout callback functions.
.sp
.in +2
.nf
#define GL_TIMEOUT_FN(fn) GlAfterTimeout (fn)(GetLine *gl, void *data)
.fi
.in -2

.sp
.LP
On returning, the application's callback is expected to return one of the
following enumerators to tell
.B gl_get_line()
how to procede after the
timeout has been handled by the callback.
.sp
.ne 2
.mk
.na
.B GLTO_ABORT
.ad
.RS 17n
.rt
Tell
.B gl_get_line()
.RB "to abort. When this happens," " gl_get_line()"
will return
.IR NULL ,
and a following call to
.BR gl_return_status()
will return
.BR GLR_TIMEOUT .
Note that if the application needs
.B errno
always to have a meaningful value when
.BR gl_get_line()
returns
.IR NULL ,
the callback function should set
.BR errno
appropriately.
.RE

.sp
.ne 2
.mk
.na
.B GLTO_REFRESH
.ad
.RS 17n
.rt
Redraw the input line, then continue waiting for input. You should return
this value if your callback wrote to the terminal.
.RE

.sp
.ne 2
.mk
.na
.B GLTO_CONTINUE
.ad
.RS 17n
.rt
In normal blocking-I/O mode, continue to wait for input, without redrawing
the user's input line. In non-blocking server I/O mode (see
.BR gl_io_mode (3TECLA)),
.B gl_get_line()
acts as though I/O blocked.
This means that
.B gl_get_line()
will immediately return
.IR NULL ,
and
a following call to
.B gl_return_status()
will return
.BR GLR_BLOCKED .
.RE

.sp
.LP
Note that before calling the callback,
.B gl_get_line()
blocks most
signals and leaves its own signal handlers installed, so if you need to
catch a particular signal you will need to both temporarily install your own
signal handler and unblock the signal. Be sure to re-block the signal (if it
was originally blocked) and reinstate the original signal handler, if any,
before returning.
.sp
.LP
Your callback should not try to read from the terminal, which is left in
raw mode as far as input is concerned. You can however write to the terminal
as usual, since features like conversion of newline to
carriage-return/linefeed are re-enabled while the callback is running. If
your callback function does write to the terminal, be sure to output a
newline first, and when your callback returns, tell
.B gl_get_line()
that
.RB "the input line needs to be redrawn, by returning the" " GLTO_REFRESH"
status code.
.sp
.LP
Finally, note that although the timeout arguments include a nanosecond
component, few computer clocks presently have resolutions that are finer
than a few milliseconds, so asking for less than a few milliseconds is
equivalent to requesting zero seconds on many systems. If this would be a
problem, you should base your timeout selection on the actual resolution of
the host clock (for example, by calling
.BR sysconf (\fB_SC_CLK_TCK\fR)).
.sp
.LP
To turn off timeouts, simply call
.B gl_inactivity_timeout()
with a
.I callback
argument of 0. The
.I data
argument is ignored in this
case.
.SS "Signal Handling Defaults"
.sp
.LP
By default, the
.B gl_get_line()
function intercepts a number of
signals. This is particularly important for signals that would by default
terminate the process, since the terminal needs to be restored to a usable
state before this happens. This section describes the signals that are
trapped by default and how
.B gl_get_line()
responds to them. Changing
these defaults is the topic of the following section.
.sp
.LP
When the following subset of signals are caught,
.B gl_get_line()
first
restores the terminal settings and signal handling to how they were before
.B gl_get_line()
was called, resends the signal to allow the calling
application's signal handlers to handle it, then, if the process still
exists, returns
.I NULL
and sets
.B errno
as specified below.
.sp
.ne 2
.mk
.na
.B SIGINT
.ad
.RS 11n
.rt
This signal is generated both by the keyboard interrupt key (usually
.BR ^C ),
and the keyboard break key. The
.B errno
value is
.BR EINTR .
.RE

.sp
.ne 2
.mk
.na
.B SIGHUP
.ad
.RS 11n
.rt
This signal is generated when the controlling terminal exits. The
.B errno
value is
.BR ENOTTY .
.RE

.sp
.ne 2
.mk
.na
.B SIGPIPE
.ad
.RS 11n
.rt
This signal is generated when a program attempts to write to a pipe whose
remote end is not being read by any process. This can happen for example if
you have called
.B gl_change_terminal()
to redirect output to a pipe
hidden under a pseudo terminal. The
.B errno
value is
.BR EPIPE .
.RE

.sp
.ne 2
.mk
.na
.B SIGQUIT
.ad
.RS 11n
.rt
This signal is generated by the keyboard quit key (usually \fB^\efR). The
.B errno
value is
.BR EINTR .
.RE

.sp
.ne 2
.mk
.na
.B SIGABRT
.ad
.RS 11n
.rt
This signal is generated by the standard C, abort function. By default it
both terminates the process and generates a core dump. The
.B errno
value
is
.BR EINTR .
.RE

.sp
.ne 2
.mk
.na
.B SIGTERM
.ad
.RS 11n
.rt
This is the default signal that the UNIX kill command sends to processes.
The
.B errno
value is
.BR EINTR .
.RE

.sp
.LP
Note that in the case of all of the above signals, POSIX mandates that by
default the process is terminated, with the addition of a core dump in the
case of the
.B SIGQUIT
signal. In other words, if the calling application
does not override the default handler by supplying its own signal handler,
receipt of the corresponding signal will terminate the application before
.B gl_get_line()
returns.
.sp
.LP
If
.B gl_get_line()
aborts with
.B errno
set to
.BR EINTR ,
you can
find out what signal caused it to abort, by calling the
.B gl_last_signal()
function. This returns the numeric code (for example,
.BR SIGINT )
of the last signal that was received during the most recent
call to
.BR gl_get_line() ,
or -1 if no signals were received.
.sp
.LP
On systems that support it, when a
.B SIGWINCH
(window change) signal is
received,
.B gl_get_line()
queries the terminal to find out its new size,
redraws the current input line to accomodate the new size, then returns to
waiting for keyboard input from the user. Unlike other signals, this signal
is not resent to the application.
.sp
.LP
Finally, the following signals cause
.B gl_get_line()
to first restore
the terminal and signal environment to that which prevailed before
.B gl_get_line()
was called, then resend the signal to the application.
If the process still exists after the signal has been delivered, then
.B gl_get_line()
then re-establishes its own signal handlers, switches
the terminal back to raw mode, redisplays the input line, and goes back to
awaiting terminal input from the user.
.sp
.ne 2
.mk
.na
.B SIGCONT
.ad
.RS 13n
.rt
This signal is generated when a suspended process is resumed.
.RE

.sp
.ne 2
.mk
.na
.B SIGPOLL
.ad
.RS 13n
.rt
On SVR4 systems, this signal notifies the process of an asynchronous I/O
event. Note that under 4.3+BSD,
.B SIGIO
and
.B SIGPOLL
are the same.
On other systems,
.B SIGIO
is ignored by default, so
.B gl_get_line()
does not trap it by default.
.RE

.sp
.ne 2
.mk
.na
.B SIGPWR
.ad
.RS 13n
.rt
This signal is generated when a power failure occurs (presumably when the
system is on a UPS).
.RE

.sp
.ne 2
.mk
.na
.B SIGALRM
.ad
.RS 13n
.rt
This signal is generated when a timer expires.
.RE

.sp
.ne 2
.mk
.na
.B SIGUSR1
.ad
.RS 13n
.rt
An application specific signal.
.RE

.sp
.ne 2
.mk
.na
.B SIGUSR2
.ad
.RS 13n
.rt
Another application specific signal.
.RE

.sp
.ne 2
.mk
.na
.B SIGVTALRM
.ad
.RS 13n
.rt
This signal is generated when a virtual timer expires. See
.BR setitimer (2).
.RE

.sp
.ne 2
.mk
.na
.B SIGXCPU
.ad
.RS 13n
.rt
This signal is generated when a process exceeds its soft CPU time limit.
.RE

.sp
.ne 2
.mk
.na
.B SIGXFSZ
.ad
.RS 13n
.rt
This signal is generated when a process exceeds its soft file-size limit.
.RE

.sp
.ne 2
.mk
.na
.B SIGTSTP
.ad
.RS 13n
.rt
This signal is generated by the terminal suspend key, which is usually
.BR ^Z ,
or the delayed terminal suspend key, which is usually
.BR ^Y .
.RE

.sp
.ne 2
.mk
.na
.B SIGTTIN
.ad
.RS 13n
.rt
This signal is generated if the program attempts to read from the terminal
while the program is running in the background.
.RE

.sp
.ne 2
.mk
.na
.B SIGTTOU
.ad
.RS 13n
.rt
This signal is generated if the program attempts to write to the terminal
while the program is running in the background.
.RE

.sp
.LP
Obviously not all of the above signals are supported on all systems, so
code to support them is conditionally compiled into the tecla library.
.sp
.LP
Note that if
.B SIGKILL
or
.BR SIGPOLL ,
which by definition cannot be
caught, or any of the hardware generated exception signals, such as
.BR SIGSEGV ,
.BR SIGBUS ,
and
.BR SIGFPE ,
are received and unhandled
while
.B gl_get_line()
has the terminal in raw mode, the program will be
terminated without the terminal having been restored to a usable state. In
practice, job-control shells usually reset the terminal settings when a
process relinquishes the controlling terminal, so this is only a problem
with older shells.
.SS "Customized Signal Handling"
.sp
.LP
The previous section listed the signals that
.B gl_get_line()
traps by
default, and described how it responds to them. This section describes how
to both add and remove signals from the list of trapped signals, and how to
specify how
.B gl_get_line()
should respond to a given signal.
.sp
.LP
If you do not need
.B gl_get_line()
to do anything in response to a
signal that it normally traps, you can tell to
.B gl_get_line()
to ignore
that signal by calling
.BR gl_ignore_signal() .
.sp
.LP
The
.I signo
argument is the number of the signal (for example,
.BR SIGINT )
that you want to have ignored. If the specified signal is not
currently one of those being trapped, this function does nothing.
.sp
.LP
The
.B gl_trap_signal()
function allows you to either add a new signal
to the list that
.B gl_get_line()
traps or modify how it responds to a
signal that it already traps.
.sp
.LP
The
.I signo
argument is the number of the signal that you want to have
trapped. The
.I flags
argument is a set of flags that determine the
environment in which the application's signal handler is invoked. The
.I after
argument tells
.B gl_get_line()
what to do after the
application's signal handler returns. The
.I errno_value
tells
.B gl_get_line()
what to set
.B errno
to if told to abort.
.sp
.LP
The
.I flags
argument is a bitwise OR of zero or more of the following
enumerators:
.sp
.ne 2
.mk
.na
.B GLS_RESTORE_SIG
.ad
.RS 20n
.rt
Restore the caller's signal environment while handling the signal.
.RE

.sp
.ne 2
.mk
.na
.B GLS_RESTORE_TTY
.ad
.RS 20n
.rt
Restore the caller's terminal settings while handling the signal.
.RE

.sp
.ne 2
.mk
.na
.B GLS_RESTORE_LINE
.ad
.RS 20n
.rt
Move the cursor to the start of the line following the input line before
invoking the application's signal handler.
.RE

.sp
.ne 2
.mk
.na
.B GLS_REDRAW_LINE
.ad
.RS 20n
.rt
Redraw the input line when the application's signal handler returns.
.RE

.sp
.ne 2
.mk
.na
.B GLS_UNBLOCK_SIG
.ad
.RS 20n
.rt
Normally, if the calling program has a signal blocked (see
.BR sigprocmask (2)),
.B gl_get_line()
does not trap that signal. This
flag tells
.B gl_get_line()
to trap the signal and unblock it for the
duration of the call to
.BR gl_get_line() .
.RE

.sp
.ne 2
.mk
.na
.B GLS_DONT_FORWARD
.ad
.RS 20n
.rt
If this flag is included, the signal will not be forwarded to the signal
handler of the calling program.
.RE

.sp
.LP
Two commonly useful flag combinations are also enumerated as follows:
.sp
.ne 2
.mk
.na
.B GLS_RESTORE_ENV
.ad
.RS 21n
.rt
.B GLS_RESTORE_SIG
|
.B GLS_RESTORE_TTY
|\fBGLS_REDRAW_LINE\fR
.RE

.sp
.ne 2
.mk
.na
.B GLS_SUSPEND_INPUT
.ad
.RS 21n
.rt
.B GLS_RESTORE_ENV
|
.B GLS_RESTORE_LINE
.RE

.sp
.LP
If your signal handler, or the default system signal handler for this
signal, if you have not overridden it, never either writes to the terminal,
nor suspends or terminates the calling program, then you can safely set the
.I flags
argument to 0.
.RS +4
.TP
.ie t \(bu
.el o
The cursor does not get left in the middle of the input line.
.RE
.RS +4
.TP
.ie t \(bu
.el o
So that the user can type in input and have it echoed.
.RE
.RS +4
.TP
.ie t \(bu
.el o
So that you do not need to end each output line with \er\en, instead of
just \en.
.RE
.sp
.LP
The
.B GL_RESTORE_ENV
combination is the same as
.BR GL_SUSPEND_INPUT ,
except that it does not move the cursor. If your signal handler does not
read or write anything to the terminal, the user will not see any visible
indication that a signal was caught. This can be useful if you have a signal
handler that only occasionally writes to the terminal, where using
.B GL_SUSPEND_LINE
would cause the input line to be unnecessarily
duplicated when nothing had been written to the terminal. Such a signal
handler, when it does write to the terminal, should be sure to start a new
line at the start of its first write, by writing a new line before
returning. If the signal arrives while the user is entering a line that only
occupies a signal terminal line, or if the cursor is on the last terminal
line of a longer input line, this will have the same effect as
.BR GL_SUSPEND_INPUT .
Otherwise it will start writing on a line that
already contains part of the displayed input line. This does not do any
.RB "harm, but it looks a bit ugly, which is why the" " GL_SUSPEND_INPUT"
combination is better if you know that you are always going to be writting
to the terminal.
.sp
.LP
The
.I after
argument, which determines what
.B gl_get_line()
does
after the application's signal handler returns (if  it returns), can take
any one of the following values:
.sp
.ne 2
.mk
.na
.B GLS_RETURN
.ad
.RS 16n
.rt
Return the completed input line, just as though the user had pressed the
return key.
.RE

.sp
.ne 2
.mk
.na
.B GLS_ABORT
.ad
.RS 16n
.rt
Cause
.B gl_get_line()
.RB "to abort. When this happens," " gl_get_line()"
returns
.IR NULL ,
and a following call to
.B gl_return_status()
will
return
.BR GLR_SIGNAL .
Note that if the application needs
.BR errno
always to have a meaningful value when
.B gl_get_line()
returns
.IR NULL ,
the callback function should set
.B errno
appropriately.
.RE

.sp
.ne 2
.mk
.na
.B GLS_CONTINUE
.ad
.RS 16n
.rt
Resume command line editing.
.RE

.sp
.LP
The
.I errno_value
argument is intended to be combined with the
.B GLS_ABORT
option, telling
.B gl_get_line()
what to set the standard
.B errno
variable to before returning
.I NULL
to the calling program.
It can also, however, be used with the
.B GL_RETURN
option, in case you
want to have a way to distinguish between an input line that was entered
using the return key, and one that was entered by the receipt of a signal.
.SS "Reliable Signal Handling"
.sp
.LP
Signal handling is suprisingly hard to do reliably without race conditions.
In
.B gl_get_line()
a lot of care has been taken to allow applications to
perform reliable signal handling around
.BR gl_get_line() .
This section
explains how to make use of this.
.sp
.LP
As an example of the problems that can arise if the application is not
written correctly, imagine that one's application has a
.B SIGINT
signal
handler that sets a global flag. Now suppose that the application tests this
flag just before invoking
.BR gl_get_line() .
If a
.B SIGINT
signal
happens to be received in the small window of time between the statement
that tests the value of this flag, and the statement that calls
.BR gl_get_line() ,
then
.B gl_get_line()
will not see the signal, and
will not be interrupted. As a result, the application will not be able to
respond to the signal until the user gets around to finishing entering the
input line and
.B gl_get_line()
returns. Depending on the application,
this might or might not be a disaster, but at the very least it would puzzle
the user.
.sp
.LP
The way to avoid such problems is to do the following.
.RS +4
.TP
1.
If needed, use the
.B gl_trap_signal()
function to configure
.B gl_get_line()
to abort when important signals are caught.
.RE
.RS +4
.TP
2.
Configure
.B gl_get_line()
such that if any of the signals that it
catches are blocked when
.B gl_get_line()
is called, they will be
unblocked automatically during times when
.B gl_get_line()
is waiting for
I/O. This can be done either on a per signal basis, by calling the
.B gl_trap_signal()
function, and specifying the
.B GLS_UNBLOCK
attribute of the signal, or globally by calling the
.B gl_catch_blocked()
function. This function simply adds the
.B GLS_UNBLOCK
attribute to all
of the signals that it is currently configured to trap.
.RE
.RS +4
.TP
3.
Just before calling
.BR gl_get_line() ,
block delivery of all of the
signals that
.B gl_get_line()
is configured to trap. This can be done
using the POSIX sigprocmask function in conjunction with the
.B gl_list_signals()
function. This function returns the set of signals
that it is currently configured to catch in the set argument, which is in
the form required by
.BR sigprocmask (2).
.RE
.RS +4
.TP
4.
In the example, one would now test the global flag that the signal handler
sets, knowing that there is now no danger of this flag being set again until
.B gl_get_line()
unblocks its signals while performing I/O.
.RE
.RS +4
.TP
5.
Eventually
.B gl_get_line()
returns, either because a signal was caught,
an error occurred, or the user finished entering their input line.
.RE
.RS +4
.TP
6.
Now one would check the global signal flag again, and if it is set, respond
to it, and zero the flag.
.RE
.RS +4
.TP
7.
Use
.B sigprocmask()
to unblock the signals that were blocked in step
3.
.RE
.sp
.LP
The same technique can be used around certain POSIX signal-aware functions,
such as
.BR sigsetjmp "(3C) and"
.BR sigsuspend (2),
and in particular, the
former of these two functions can be used in conjunction with
.BR siglongjmp (3C)
to implement race-condition free signal handling around
other long-running system calls. The
.B gl_get_line()
function manages to
reliably trap signals around calls to functions like
.BR read (2)
and
.BR select (3C)
without race conditions.
.sp
.LP
The
.B gl_get_line()
function first uses the POSIX
.BR sigprocmask()
function to block the delivery of all of the signals that it is currently
configured to catch. This is redundant if the application has already
blocked them, but it does no harm. It undoes this step just before
returning.
.sp
.LP
Whenever
.B gl_get_line()
needs to call read or select to wait for input
from the user, it first calls the POSIX
.B sigsetjmp()
function, being
sure to specify a non-zero value for its
.I savemask
argument.
.sp
.LP
If
.B sigsetjmp()
returns zero,
.B gl_get_line()
then does the
following.
.RS +4
.TP
1.
It uses the POSIX
.BR sigaction (2)
function to register a temporary
signal handler to all of the signals that it is configured to catch. This
signal handler does two things.
.RS +4
.TP
a.
It records the number of the signal that was received in a file-scope
variable.
.RE
.RS +4
.TP
b.
It then calls the POSIX
.B siglongjmp()
function using the buffer that
was passed to
.B sigsetjmp()
for its first argument and a non-zero value
for its second argument.
.RE
When this signal handler is registered, the
.I sa_mask
member of the
.B "struct sigaction"
.I act
argument of the call to
.BR sigaction()
is configured to contain all of the signals that
.B gl_get_line()
is
catching. This ensures that only one signal will be caught at once by our
signal handler, which in turn ensures that multiple instances of our signal
handler do not tread on each other's toes.
.RE
.RS +4
.TP
2.
Now that the signal handler has been set up,
.B gl_get_line()
unblocks
all of the signals that it is configured to catch.
.RE
.RS +4
.TP
3.
It then calls the
.B read()
or
.B select()
function to wait for
keyboard input.
.RE
.RS +4
.TP
4.
If this function returns (that is, no signal is received),
.B gl_get_line()
blocks delivery of the signals of interest again.
.RE
.RS +4
.TP
5.
It then reinstates the signal handlers that were displaced by the one that
was just installed.
.RE
.sp
.LP
Alternatively, if
.B sigsetjmp()
returns non-zero, this means that one
of the signals being trapped was caught while the above steps were
executing. When this happens,
.B gl_get_line()
does the following.
.sp
.LP
First, note that when a call to
.B siglongjmp()
causes
.BR sigsetjmp()
to return, provided that the
.I savemask
argument of
.BR sigsetjmp()
was non-zero, the signal process mask is restored to how it was when
.B sigsetjmp()
was called. This is the important difference between
.B sigsetjmp()
and the older problematic
.BR setjmp "(3C), and is the"
essential ingredient that makes it possible to avoid signal handling race
conditions. Because of this we are guaranteed that all of the signals that
we blocked before calling
.B sigsetjmp()
are blocked again as soon as any
signal is caught. The following statements, which are then executed, are
thus guaranteed to be executed without any further signals being caught.
.RS +4
.TP
1.
If so instructed by the
.B gl_get_line()
configuration attributes of the
signal that was caught,
.B gl_get_line()
restores the terminal attributes
to the state that they had when
.B gl_get_line()
was called. This is
particularly important for signals that suspend or terminate the process,
since otherwise the terminal would be left in an unusable state.
.RE
.RS +4
.TP
2.
It then reinstates the application's signal handlers.
.RE
.RS +4
.TP
3.
Then it uses the C standard-library
.BR raise (3C)
function to re-send the
application the signal that was caught.
.RE
.RS +4
.TP
4.
Next it unblocks delivery of the signal that we just sent. This results in
the signal that was just sent by
.B raise()
being caught by the
application's original signal handler, which can now handle it as it sees
fit.
.RE
.RS +4
.TP
5.
If the signal handler returns (that is, it does not terminate the process),
.B gl_get_line()
blocks delivery of the above signal again.
.RE
.RS +4
.TP
6.
It then undoes any actions performed in the first of the above steps and
redisplays the line, if the signal configuration calls for this.
.RE
.RS +4
.TP
7.
.B gl_get_line()
then either resumes trying to read a character, or
aborts, depending on the configuration of the signal that was caught.
.RE
.sp
.LP
What the above steps do in essence is to take asynchronously delivered
signals and handle them synchronously, one at a time, at a point in the code
where
.B gl_get_line()
has complete control over its environment.
.SS "The Terminal Size"
.sp
.LP
On most systems the combination of the
.B TIOCGWINSZ
ioctl and the
.B SIGWINCH
signal is used to maintain an accurate idea of the terminal
.RB "size. The terminal size is newly queried every time that" " gl_get_line()"
is called and whenever a
.B SIGWINCH
signal is received.
.sp
.LP
On the few systems where this mechanism is not available, at startup
.B new_GetLine()
first looks for the
.B LINES
and
.BR COLUMNS
environment variables. If these are not found, or they contain unusable
values, then if a terminal information database like
.B terminfo
or
.B termcap
is available, the default size of the terminal is looked up in
this database. If this too fails to provide the terminal size, a default
size of 80 columns by 24 lines is used.
.sp
.LP
Even on systems that do support ioctl(\fBTIOCGWINSZ\fR), if the terminal is
on the other end of a serial line, the terminal driver generally has no way
of detecting when a resize occurs or of querying what the current size is.
In such cases no
.B SIGWINCH
is sent to the process, and the dimensions
returned by ioctl(\fBTIOCGWINSZ\fR) are not correct. The only way to handle
such instances is to provide a way for the user to enter a command that
tells the remote system what the new size is. This command would then call
the
.B gl_set_term_size()
function to tell
.B gl_get_line()
about the
change in size.
.sp
.LP
The
.I ncolumn
and
.I nline
arguments are used to specify the new
dimensions of the terminal, and must not be less than 1. On systems that do
support ioctl(\fBTIOCGWINSZ\fR), this function first calls
.RB ioctl( TIOCSWINSZ )
to tell the terminal driver about the change in
size. In non-blocking server-I/O mode, if a line is currently being input,
the input line is then redrawn to accomodate the changed size. Finally the
new values are recorded in
.I gl
for future use by
.BR gl_get_line() .
.sp
.LP
The
.B gl_terminal_size()
function allows you to query the current size
of the terminal, and install an alternate fallback size for cases where the
size is not available. Beware that the terminal size will not be available
if reading from a pipe or a file, so the default values can be important
even on systems that do support ways of finding out the terminal size.
.sp
.LP
This function first updates
.BR gl_get_line() 's
fallback terminal
dimensions, then records its findings in the return value.
.sp
.LP
The
.IR def_ncolumn " and "
.I def_nline
arguments specify the default
number of terminal columns and lines to use if the terminal size cannot be
determined by ioctl(\fBTIOCGWINSZ\fR) or environment variables.
.SS "Hiding What You Type"
.sp
.LP
When entering sensitive information, such as passwords, it is best not to
have the text that you are entering echoed on the terminal. Furthermore,
such text should not be recorded in the history list, since somebody finding
your terminal unattended could then recall it, or somebody snooping through
your directories could see it in your history file. With this in mind, the
.B gl_echo_mode()
function allows you to toggle on and off the display
and archival of any text that is subsequently entered in calls to
.BR gl_get_line() .
.sp
.LP
The
.I enable
argument specifies whether entered text should be visible
or not. If it is 0, then subsequently entered lines will not be visible on
the terminal, and will not be recorded in the history list. If it is 1, then
subsequent input lines will be displayed as they are entered, and provided
that history has not been turned off with a call to
.BR gl_toggle_history() ,
then they will also be archived in the history
list. Finally, if the enable argument is -1, then the echoing mode is left
unchanged, which allows you to non-destructively query the current setting
through the return value. In all cases, the return value of the function is
0 if echoing was disabled before the function was called, and 1 if it was
enabled.
.sp
.LP
When echoing is turned off, note that although tab completion will
invisibly complete your prefix as far as possible, ambiguous completions
will not be displayed.
.SS "Single Character Queries"
.sp
.LP
Using
.B gl_get_line()
to query the user for a single character reply,
is inconvenient for the user, since they must hit the enter or return key
before the character that they typed is returned to the program. Thus the
.B gl_query_char()
function has been provided for single character
queries like this.
.sp
.LP
This function displays the specified prompt at the start of a new line, and
waits for the user to type a character. When the user types a character,
.B gl_query_char()
displays it to the right of the prompt, starts a
newline, then returns the character to the calling program. The return value
of the function is the character that was typed. If the read had to be
aborted for some reason, EOF is returned instead. In the latter case, the
application can call the previously documented
.BR gl_return_status() ,
to
find out what went wrong. This could, for example, have been the reception
of a signal, or the optional inactivity timer going off.
.sp
.LP
If the user simply hits enter, the value of the
.I defchar
argument is
substituted. This means that when the user hits either newline or return,
the character specified in
.IR defchar ,
is displayed after the prompt, as
though the user had typed it, as well as being returned to the calling
application. If such a replacement is not important, simply pass '\en' as
the value of
.IR defchar .
.sp
.LP
If the entered character is an unprintable character, it is displayed
symbolically. For example, control-A is displayed as
.BR ^A ,
and
characters beyond 127 are displayed in octal, preceded by a backslash.
.sp
.LP
As with
.BR gl_get_line() ,
echoing of the entered character can be
disabled using the
.B gl_echo_mode()
function.
.sp
.LP
If the calling process is suspended while waiting for the user to type
their response, the cursor is moved to the line following the prompt line,
then when the process resumes, the prompt is redisplayed, and
.B gl_query_char()
resumes waiting for the user to type a character.
.sp
.LP
Note that in non-blocking server mode, if an incomplete input line is in
the process of being read when
.B gl_query_char()
is called, the partial
input line is discarded, and erased from the terminal, before the new prompt
is displayed. The next call to
.B gl_get_line()
will thus start editing a
new line.
.SS "Reading Raw Characters"
.sp
.LP
Whereas the
.B gl_query_char()
function visibly prompts the user for a
character, and displays what they typed, the
.B gl_read_char()
function
reads a signal character from the user, without writing anything to the
terminal, or perturbing any incompletely entered input line. This means that
it can be called not only from between calls to
.BR gl_get_line() ,
but
also from callback functions that the application has registered to be
called by
.BR gl_get_line() .
.sp
.LP
On success, the return value of
.B gl_read_char()
is the character that
was read. On failure, EOF is returned, and the
.B gl_return_status()
function can be called to find out what went wrong. Possibilities include
the optional inactivity timer going off, the receipt of a signal that is
configured to abort
.BR gl_get_line() ,
or terminal I/O blocking, when in
non-blocking server-I/O mode.
.sp
.LP
Beware that certain keyboard keys, such as function keys, and cursor keys,
usually generate at least three characters each, so a single call to
.B gl_read_char()
will not be enough to identify such keystrokes.
.SS "Clearing The Terminal"
.sp
.LP
The calling program can clear the terminal by calling
.BR gl_erase_terminal() .
In non-blocking server-I/O mode, this function
also arranges for the current input line to be redrawn from scratch when
.B gl_get_line()
is next called.
.SS "Displaying Text Dynamically"
.sp
.LP
Between calls to
.BR gl_get_line() ,
the
.B gl_display_text()
function
provides a convenient way to display paragraphs of text, left-justified and
split over one or more terminal lines according to the constraints of the
current width of the terminal. Examples of the use of this function may be
found in the demo programs, where it is used to display introductions. In
those examples the advanced use  of optional prefixes, suffixes and filled
lines to draw a box around the text is also illustrated.
.sp
.LP
If
.I gl
is not currently connected to a terminal, for example if the
output of a program that uses
.B gl_get_line()
is being piped to another
program or redirected to a file, then the value of the
.I def_width
parameter is used as the terminal width.
.sp
.LP
The
.I indentation
argument specifies the number of characters to use to
indent each line of ouput. The
.I fill_char
argument specifies the
character that will be used to perform this indentation.
.sp
.LP
The
.I prefix
argument can be either
.I NULL
or a string to place at
the beginning of each new line (after any indentation). Similarly, the
.I suffix
argument can be either
.I NULL
or a string to place at the
end of each line. The suffix is placed flush against the right edge of the
terminal, and any space between its first character and the last word on
that line is filled with the character specified by the
.I fill_char
argument. Normally the fill-character is a space.
.sp
.LP
The
.I start
argument tells
.B gl_display_text()
how many characters
have already been written to the current terminal line, and thus tells it
the starting column index of the cursor. Since the return value of
.B gl_display_text()
is the ending column index of the cursor, by passing
the return value of one call to the start argument of the next call, a
paragraph that is broken between more than one string can be composed by
calling
.B gl_display_text()
for each successive portion of the
paragraph. Note that literal newline characters are necessary at the end of
each paragraph to force a new line to be started.
.sp
.LP
On error,
.B gl_display_text()
returns -1.
.SS "Callback Function Facilities"
.sp
.LP
Unless otherwise stated, callback functions such as tab completion
callbacks and event callbacks should not call any functions in this module.
The following functions, however, are designed specifically to be used by
callback functions.
.sp
.LP
Calling the
.B gl_replace_prompt()
function from a callback tells
.B gl_get_line()
to display a different prompt when the callback returns.
Except in non-blocking server mode, it has no effect if used between calls
to
.BR gl_get_line() .
In non-blocking server mode, when used between two
calls to
.B gl_get_line()
that are operating on the same input line, the
current input line will be re-drawn with the new prompt on the following
call to
.BR gl_get_line() .
.SS "International Character Sets"
.sp
.LP
Since
.BR libtecla "(3LIB) version 1.4.0,"
.B gl_get_line()
has been
8-bit clean. This means that all 8-bit characters that are printable in the
user's current locale are now displayed verbatim and included in the
returned input line. Assuming that the calling program correctly contains a
call like the following,
.sp
.in +2
.nf
setlocale(LC_CTYPE, "")
.fi
.in -2

.sp
.LP
then the current locale is determined by the first of the environment
variables
.BR LC_CTYPE ,
.BR LC_ALL ,
and
.B LANG
that is found to
contain a valid locale name. If none of these variables are defined, or the
program neglects to call
.BR setlocale (3C),
then the default C locale is
used, which is US 7-bit ASCII. On most UNIX-like platforms, you can get a
list of valid locales by typing the command:
.sp
.in +2
.nf
locale -a
.fi
.in -2
.sp

.sp
.LP
at the shell prompt. Further documentation on how the user can make use of
this to enter international characters can be found in the
.BR tecla (5)
man page.
.SS "Thread Safety"
.sp
.LP
Unfortunately neither
.B terminfo
nor
.B termcap
were designed to be
reentrant, so you cannot safely use the functions of the getline module in
multiple threads (you can use the separate file-expansion and
word-completion modules in multiple threads, see the corresponding man pages
for details). However due to the use of POSIX reentrant functions for
looking up home directories, it is safe to use this module from a single
thread of a multi-threaded program, provided that your other threads do not
use any
.B termcap
or
.B terminfo
functions.
.SH ATTRIBUTES
.sp
.LP
See
.BR attributes (5)
for descriptions of the following attributes:
.sp

.sp
.TS
tab() box;
cw(2.75i) |cw(2.75i)
lw(2.75i) |lw(2.75i)
.
ATTRIBUTE TYPEATTRIBUTE VALUE
_
Interface StabilityCommitted
_
MT-LevelMT-Safe
.TE

.SH SEE ALSO
.sp
.LP
.BR cpl_complete_word (3TECLA),
.BR ef_expand_file (3TECLA),
.BR gl_io_mode (3TECLA),
.BR libtecla (3LIB),
.BR pca_lookup_file (3TECLA),
.BR attributes (5),
.BR tecla (5)
