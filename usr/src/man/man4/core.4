'\" te
.\" Copyright (C) 2008, Sun Microsystems, Inc. All Rights Reserved.
.\" Copyright 1989 AT&T
.\" CDDL HEADER START
.\"
.\" The contents of this file are subject to the terms of the
.\" Common Development and Distribution License (the "License").
.\" You may not use this file except in compliance with the License.
.\"
.\" You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
.\" or http://www.opensolaris.org/os/licensing.
.\" See the License for the specific language governing permissions
.\" and limitations under the License.
.\"
.\" When distributing Covered Code, include this CDDL HEADER in each
.\" file and include the License file at usr/src/OPENSOLARIS.LICENSE.
.\" If applicable, add the following below this CDDL HEADER, with the
.\" fields enclosed by brackets "[]" replaced with your own identifying
.\" information: Portions Copyright [yyyy] [name of copyright owner]
.\"
.\" CDDL HEADER END
.TH core 4 "13 May 2008" "SunOS 5.11" "File Formats"
.SH NAME
core \- process core file
.SH DESCRIPTION
.sp
.LP
The operating system writes out a core file for a process when the process
is terminated due to receiving certain signals. A core file is a disk copy
of the contents of the process address space at the time the process
received the signal, along with additional information about the state of
the process. This information can be consumed by a debugger. Core files can
also be generated by applying the
.BR gcore (1)
utility to a running
process.
.sp
.LP
Typically, core files are produced following abnormal termination of a
process resulting from a bug in the corresponding application. Whatever the
cause, the core file itself provides invaluable information to the
programmer or support engineer to aid in diagnosing the problem. The core
file can be inspected using a debugger such as
.BR dbx (1)
or
.BR mdb (1)
or by applying one of the
.BR proc (1)
tools.
.sp
.LP
The operating system attempts to create up to two core files for each
abnormally terminating process, using a global core file name pattern and a
per-process core file name pattern. These patterns are expanded to determine
the pathname of the resulting core files, and can be configured by
.BR coreadm (1M).
By default, the global core file pattern is disabled and
not used, and the per-process core file pattern is set to \fBcore\fR.
Therefore, by default, the operating system attempts to create a core file
named
.B core
in the process's current working directory.
.sp
.LP
A process terminates and produces a core file whenever it receives one of
the signals whose default disposition is to cause a core dump. The list of
signals that result in generating a core file is shown in
.BR signal.h (3HEAD).
Therefore, a process might not produce a core file if
it has blocked or modified the behavior of the corresponding signal.
Additionally, no core dump can be created under the following conditions:
.RS +4
.TP
.ie t \(bu
.el o
If normal file and directory access permissions prevent the creation or
modification of the per-process core file pathname by the current process
user and group ID. This test does not apply to the global core file pathname
because, regardless of the UID of the process dumping core, the attempt to
write the global core file is made as the superuser.
.RE
.RS +4
.TP
.ie t \(bu
.el o
Core files owned by the user
.B nobody
will not be produced. For
example, core files generated for the superuser on an NFS directory are
owned by
.B nobody
and are, therefore, not written.
.RE
.RS +4
.TP
.ie t \(bu
.el o
If the core file pattern expands to a pathname that contains intermediate
directory components that do not exist. For example, if the global pattern
is set to
.BR /var/core/%n/core.%p ,
and no directory \fB/var/core/`uname
-n`\fR has been created, no global core files are produced.
.RE
.RS +4
.TP
.ie t \(bu
.el o
If the destination directory is part of a filesystem that is mounted
read-only.
.RE
.RS +4
.TP
.ie t \(bu
.el o
If the resource limit
.B RLIMIT_CORE
has been set to
.B 0
for the
process, no per-process core file is produced. Refer to \fBsetrlimit\fR(2)
and
.BR ulimit (1)
for more information on resource limits.
.RE
.RS +4
.TP
.ie t \(bu
.el o
If the core file name already exists in the destination directory and is
not a regular file (that is, is a symlink, block or character special-file,
and so forth).
.RE
.RS +4
.TP
.ie t \(bu
.el o
If the kernel cannot open the destination file
.BR O_EXCL ,
which can
occur if same file is being created by another process simultaneously.
.RE
.RS +4
.TP
.ie t \(bu
.el o
If the process's effective user ID is different from its real user ID or if
its effective group ID is different from its real group ID. Similarly,
set-user-ID and set-group-ID programs do not produce core files as this
could potentially compromise system security. These processes can be
explicitly granted permission to produce core files using
.BR coreadm (1M),
at the risk of exposing secure information.
.RE
.sp
.LP
The core file contains all the process information pertinent to debugging:
contents of hardware registers, process status, and process data. The format
of a core file is object file specific.
.sp
.LP
For ELF executable programs (see
.BR a.out (4)),
the core file generated
is also an ELF file, containing ELF program and file headers. The
\fBe_type\fR field in the file header has type
.BR ET_CORE .
The program
header contains an entry for every segment that was part of the process
address space, including shared library segments. The contents of the
mappings specified by \fBcoreadm\fR(1M) are also part of the core image.
Each program header has its
.B p_memsz
field set to the size of the
mapping. The program headers that represent mappings whose data is included
in the core file have their \fBp_filesz\fR field set the same as
.BR p_memsz ,
otherwise \fBp_filesz\fR is \fBzero\fR.
.sp
.LP
A mapping's data can be excluded due to the core file content settings (see
.BR coreadm (1M)),
or due to some failure. If the data is excluded because
of a failure, the program header entry will have the \fBPF_SUNW_FAILURE\fR
flag set in its \fBp_flags\fR field.
.sp
.LP
The program headers of an
.B ELF
core file also contain entries for two
\fBNOTE\fR segments, each containing several note entries as described
below. The note entry header and core file note type (\fBn_type\fR)
definitions are contained in <\fBsys/elf.h\fR>. The first
.B NOTE
segment
exists for binary compatibility with old programs that deal with core files.
It contains structures defined in <\fBsys/old_procfs.h\fR>. New programs
should recognize and skip this
.B NOTE
segment, advancing instead to the
new
.B NOTE
segment. The old
.B NOTE
segment is deleted from core
files in a future release.
.sp
.LP
The old
.B NOTE
segment contains the following entries. Each has entry
name \fB"CORE"\fR and presents the contents of a system structure:
.sp
.ne 2
.mk
.na
\fBprpsinfo_t\fR
.ad
.RS 16n
.rt
.BR n_type :
.BR NT_PRPSINFO .
This entry contains information of
interest to the
.BR ps (1)
.RB "command, such as process status," " CPU"
usage,
.B nice
value, controlling terminal, user-ID, process-ID, the name
of the executable, and so forth. The \fBprpsinfo_t\fR structure is defined
in <\fBsys/old_procfs.h\fR>.
.RE

.sp
.ne 2
.mk
.na
.BR char " array"
.ad
.RS 16n
.rt
.BR n_type :
.BR NT_PLATFORM .
This entry contains a string describing
the specific model of the hardware platform on which this core file was
created. This information is the same as provided by
.BR sysinfo (2)
when
invoked with the command
.BR SI_PLATFORM .
.RE

.sp
.ne 2
.mk
.na
.BR auxv_t " array"
.ad
.RS 16n
.rt
.BR n_type :
.BR NT_AUXV .
This entry contains the array of
.BR auxv_t
structures that was passed by the operating system as startup information to
the dynamic linker. Auxiliary vector information is defined in
<\fBsys/auxv.h\fR>.
.RE

.sp
.LP
Following these entries, for each active (non-zombie) light-weight process
(LWP) in the process, the old
.B NOTE
segment contains an entry with a
\fBprstatus_t\fR structure, plus other optionally-present entries describing
the LWP, as follows:
.sp
.ne 2
.mk
.na
.B prstatus_t
.ad
.RS 16n
.rt
.BR n_type :
.BR NT_PRSTATUS .
This structure contains things of interest
to a debugger from the operating system, such as the general registers,
signal dispositions, state, reason for stopping, process-ID, and so forth.
The
.B prstatus_t
structure is defined in <\fBsys/old_procfs.h\fR>.
.RE

.sp
.ne 2
.mk
.na
\fBprfpregset_t\fR
.ad
.RS 16n
.rt
.BR n_type :
.BR NT_PRFPREG .
This entry is present only if the
.BR LWP
used the floating-point hardware. It contains the floating-point registers.
The \fBprfpregset_t\fR structure is defined in <\fBsys/procfs_isa.h\fR>.
.RE

.sp
.ne 2
.mk
.na
.B gwindows_t
.ad
.RS 16n
.rt
.BR n_type :
.BR NT_GWINDOWS .
This entry is present only on a SPARC
machine and only if the system was unable to flush all of the register
windows to the stack. It contains all of the unspilled register windows. The
\fBgwindows_t\fR structure is defined in <\fBsys/regset.h\fR>.
.RE

.sp
.ne 2
.mk
.na
.B prxregset_t
.ad
.RS 16n
.rt
.BR n_type :
.BR NT_PRXREG .
This entry is present only if the machine
has extra register state associated with it. It contains the extra register
state. The
.B prxregset_t
structure is defined in
<\fBsys/procfs_isa.h\fR>.
.RE

.sp
.LP
The new
.B NOTE
segment contains the following entries. Each has entry
name "\fBCORE\fR" and presents the contents of a system structure:
.sp
.ne 2
.mk
.na
\fBpsinfo_t\fR
.ad
.RS 20n
.rt
.BR n_type :
.BR NT_PSINFO .
This structure contains information of
interest to the
.BR ps (1)
.RB "command, such as process status," " CPU"
usage,
.B nice
value, controlling terminal, user-ID, process-ID, the name
of the executable, and so forth. The \fBpsinfo_t\fR structure is defined in
<\fBsys/procfs.h\fR>.
.RE

.sp
.ne 2
.mk
.na
.B pstatus_t
.ad
.RS 20n
.rt
.BR n_type :
.BR NT_PSTATUS .
This structure contains things of interest
to a debugger from the operating system, such as pending signals, state,
process-ID, and so forth. The
.B pstatus_t
structure is defined in
<\fBsys/procfs.h\fR>.
.RE

.sp
.ne 2
.mk
.na
.BR char " array"
.ad
.RS 20n
.rt
.BR n_type :
.BR NT_PLATFORM .
This entry contains a string describing
the specific model of the hardware platform on which this core file was
created. This information is the same as provided by
.BR sysinfo (2)
when
invoked with the command
.BR SI_PLATFORM .
.RE

.sp
.ne 2
.mk
.na
.BR auxv_t " array"
.ad
.RS 20n
.rt
.BR n_type :
.BR NT_AUXV .
This entry contains the array of
.BR auxv_t
structures that was passed by the operating system as startup information to
the dynamic linker. Auxiliary vector information is defined in
<\fBsys/auxv.h\fR>.
.RE

.sp
.ne 2
.mk
.na
.B struct utsname
.ad
.RS 20n
.rt
.BR n_type :
.BR NT_UTSNAME .
This structure contains the system
information that would have been returned to the process if it had performed
a
.BR uname (2)
.RB "system call prior to dumping core. The" " utsname"
structure is defined in <\fBsys/utsname.h\fR>.
.RE

.sp
.ne 2
.mk
.na
.B prcred_t
.ad
.RS 20n
.rt
.BR n_type :
.BR NT_PRCRED .
This structure contains the process
credentials, including the real, saved, and effective user and group IDs.
The
.B prcred_t
structure is defined in <\fBaasys/procfs.h\fR>. Following
the structure is an optional array of supplementary group IDs. The total
number of supplementary group IDs is given by the
.B pr_ngroups
member of
the
.B prcred_t
structure, and the structure includes space for one
supplementary group. If
.B pr_ngroups
is greater than 1, there is
.B "pr_ngroups - 1"
.B gid_t
items following the structure; otherwise,
there is no additional data.
.RE

.sp
.ne 2
.mk
.na
.B char array
.ad
.RS 20n
.rt
.BR n_type :
.BR NT_ZONENAME .
This entry contains a string which
describes the name of the zone in which the process was running. See
.BR zones (5).
The information is the same as provided by
.BR getzonenamebyid (3C)
when invoked with the numerical ID returned by
.BR getzoneid (3C).
.RE

.sp
.ne 2
.mk
.na
.BR "struct ssd" " array"
.ad
.RS 20n
.rt
.BR n_type :
.BR NT_LDT .
This entry is present only on an 32-bit x86
machine and only if the process has set up a Local Descriptor Table (LDT).
It contains an array of structures of type
.BR "struct ssd" ,
each of which
was typically used to set up the
.B %gs
segment register to be used to
fetch the address of the current thread information structure in a
multithreaded process. The
.B ssd
structure is defined in
<\fBsys/sysi86.h\fR>.
.RE

.sp
.ne 2
.mk
.na
.B core_content_t
.ad
.RS 20n
.rt
.BR n_type :
.BR NT_CONTENT .
This optional entry indicates which parts
of the process image are specified to be included in the core file. See
.BR coreadm (1M).
.RE

.sp
.LP
Following these entries, for each active and zombie
.B LWP
in the
process, the new
.B NOTE
segment contains an entry with an
\fBlwpsinfo_t\fR structure plus, for a non-zombie LWP, an entry with an
\fBlwpstatus_t\fR structure, plus other optionally-present entries
describing the LWP, as follows. A zombie LWP is a non-detached LWP that has
terminated but has not yet been reaped by another LWP in the same process.
.sp
.ne 2
.mk
.na
\fBlwpsinfo_t\fR
.ad
.RS 15n
.rt
.BR n_type :
.BR NT_LWPSINFO .
This structure contains information of
interest to the
.BR ps (1)
command, such as
.B LWP
.RB status, " CPU"
usage,
.B nice
value,
.BR LWP-ID ,
and so forth. The \fBlwpsinfo_t\fR
structure is defined in <\fBsys/procfs.h\fR>. This is the only entry present
for a zombie LWP.
.RE

.sp
.ne 2
.mk
.na
.B lwpstatus_t
.ad
.RS 15n
.rt
.BR n_type :
.BR NT_LWPSTATUS .
This structure contains things of
interest to a debugger from the operating system, such as the general
registers, the floating point registers, state, reason for stopping,
.BR LWP-ID ,
and so forth. The
.B lwpstatus_t
structure is defined in
<\fBsys/procfs.h>\fR>.
.RE

.sp
.ne 2
.mk
.na
.B gwindows_t
.ad
.RS 15n
.rt
.BR n_type :
.BR NT_GWINDOWS .
This entry is present only on a SPARC
machine and only if the system was unable to flush all of the register
windows to the stack. It contains all of the unspilled register windows. The
\fBgwindows_t\fR structure is defined in \fB<sys/regset.h>\fR\&.
.RE

.sp
.ne 2
.mk
.na
.B prxregset_t
.ad
.RS 15n
.rt
.BR n_type :
.BR NT_PRXREG .
This entry is present only if the machine
has extra register state associated with it. It contains the extra register
state. The
.B prxregset_t
structure is defined in
\fB<sys/procfs_isa.h>\fR\&.
.RE

.sp
.ne 2
.mk
.na
.B asrset_t
.ad
.RS 15n
.rt
.BR n_type :
.BR NT_ASRS .
This entry is present only on a SPARC V9
machine and only if the process is a 64-bit process. It contains the
ancillary state registers for the
.B LWP.
The
.B asrset_t
structure is
defined in \fB<sys/regset.h>\fR\&.
.RE

.sp
.LP
Depending on the \fBcoreadm\fR(1M) settings, the section header of an ELF
core file can contain entries for CTF, symbol table, and string table
sections. The
.B sh_addr
fields are set to the base address of the first
mapping of the load object that they came from to. This can be used to match
those sections with the corresponding load object.
.sp
.LP
The size of the core file created by a process can be controlled by the
user (see \fBgetrlimit\fR(2)).
.SH SEE ALSO
.sp
.LP
\fBelfdump\fR(1),
.BR gcore (1),
.BR mdb (1),
.BR proc (1),
.BR ps (1),
.BR coreadm (1M),
.BR getrlimit (2),
.BR setrlimit (2),
.BR setuid (2),
\fBsysinfo\fR(2),
.BR uname (2),
.BR getzonenamebyid (3C),
.BR getzoneid (3C),
\fBelf\fR(3ELF), \fBsignal.h\fR(3HEAD), \fBa.out\fR(4),
.BR proc (4),
.BR zones (5)
.sp
.LP
.I ANSI C Programmer's Guide
