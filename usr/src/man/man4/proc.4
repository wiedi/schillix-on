'\" te
.\" Copyright 1989 AT&T
.\" Copyright (c) 2006, Sun Microsystems, Inc. All Rights Reserved.
.\" CDDL HEADER START
.\"
.\" The contents of this file are subject to the terms of the
.\" Common Development and Distribution License (the "License").
.\" You may not use this file except in compliance with the License.
.\"
.\" You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
.\" or http://www.opensolaris.org/os/licensing.
.\" See the License for the specific language governing permissions
.\" and limitations under the License.
.\"
.\" When distributing Covered Code, include this CDDL HEADER in each
.\" file and include the License file at usr/src/OPENSOLARIS.LICENSE.
.\" If applicable, add the following below this CDDL HEADER, with the
.\" fields enclosed by brackets "[]" replaced with your own identifying
.\" information: Portions Copyright [yyyy] [name of copyright owner]
.\"
.\" CDDL HEADER END
.TH proc 4 "29 Nov 2006" "SunOS 5.11" "File Formats"
.SH NAME
proc \- /proc, the process file system
.SH DESCRIPTION
.sp
.LP
.B /proc
is a file system that provides access to the state of each
process and light-weight process (lwp) in the system. The name of each entry
in the
.B /proc
directory is a decimal number corresponding to a
process-ID. These entries are themselves subdirectories. Access to process
state is provided by additional files contained within each subdirectory;
the hierarchy is described more completely below. In this document,
``\fB/proc\fR file'' refers to a non-directory file within the hierarchy
rooted at
.BR /proc .
The owner of each
.B /proc
file and subdirectory
is determined by the user-ID of the process.
.sp
.LP
.B /proc
can be mounted on any mount point, in addition to the standard
.B /proc
mount point, and can be mounted several places at once. Such
additional mounts are allowed in order to facilitate the confinement of
processes to subtrees of the file system via
.BR chroot "(1M) and yet allow"
such processes access to commands like
.BR ps (1).
.sp
.LP
Standard system calls are used to access
.B /proc
files:
.BR open (2),
.BR close (2),
.BR read (2),
and
.BR write (2)
(including
.BR readv (2),
.BR writev (2),
.BR pread (2),
and
.BR pwrite (2)).
Most files describe
process state and can only be opened for reading.
.B ctl
and
.BR lwpctl
(control) files permit manipulation of process state and can only be opened
for writing.
.B as
(address space) files contain the image of the running
process and can be opened for both reading and writing. An open for writing
allows process control; a read-only open allows inspection but not control.
In this document, we refer to the process as open for reading or writing if
any of its associated
.B /proc
files is open for reading or writing.
.sp
.LP
In general, more than one process can open the same
.B /proc
file at the
same time.
.I "Exclusive open"
is an advisory mechanism provided to
allow controlling processes to avoid collisions with each other. A process
can obtain exclusive control of a target process, with respect to other
cooperating processes, if it successfully opens any
.B /proc
file in the
target process for writing (the
.B as
or
.B ctl
files, or the
.B lwpctl
file of any lwp) while specifying
.B O_EXCL
in the
.BR open (2).
Such an open will fail if the target process is already open
for writing (that is, if an
.BR as ,
.BR ctl ,
or
.B lwpctl
file is
already open for writing). There can be any number of concurrent read-only
opens;
.B O_EXCL
is ignored on opens for reading. It is recommended that
the first open for writing by a controlling process use the
.BR O_EXCL
flag; multiple controlling processes usually result in chaos.
.sp
.LP
If a process opens one of its own
.B /proc
files for writing, the open
succeeds regardless of
.B O_EXCL
and regardless of whether some other
process has the process open for writing. Self-opens do not count when
another process attempts an exclusive open. (A process cannot exclude a
debugger by opening itself for writing and the application of a debugger
cannot prevent a process from opening itself.) All self-opens for writing
are forced to be close-on-exec (see the
.B F_SETFD
operation of
.BR fcntl (2)).
.sp
.LP
Data may be transferred from or to any locations in the address space of
the traced process by applying
.BR lseek (2)
to position the
.B as
file
at the virtual address of interest followed by
.BR read (2)
or
.BR write (2)
(or by using
.BR pread (2)
or
.BR pwrite (2)
for the
combined operation). The address-map files \fB/proc/\fIpid\fB/map\fR
and \fB/proc/\fIpid\fB/xmap\fR can be read to determine the accessible
areas (mappings) of the address space.
.B I/O
transfers may span
contiguous mappings. An
.B I/O
request extending into an unmapped area is
truncated at the boundary. A write request beginning at an unmapped virtual
address fails with
.BR EIO ;
a read request beginning at an unmapped
virtual address returns zero (an end-of-file indication).
.sp
.LP
Information and control operations are provided through additional files.
.B <procfs.h>
contains definitions of data structures and message formats
used with these files. Some of these definitions involve the use of sets of
flags. The set types
.BR sigset_t ,
.BR fltset_t ,
and
.BR sysset_t
correspond, respectively, to signal, fault, and system call enumerations
defined in
.BR <sys/signal.h> ,
.BR <sys/fault.h> ,
and
\fB<sys/syscall.h>\fR\&. Each set type is large enough to hold flags for its
own enumeration. Although they are of different sizes, they have a common
structure and can be manipulated by these macros:
.sp
.in +2
.nf
prfillset(&set);             /* turn on all flags in set */
premptyset(&set);            /* turn off all flags in set */
praddset(&set, flag);        /* turn on the specified flag */
prdelset(&set, flag);        /* turn off the specified flag */
r = prismember(&set, flag);  /* != 0 iff flag is turned on */
.fi
.in -2

.sp
.LP
One of
.B prfillset()
or
.B premptyset()
must be used to initialize
.B set
before it is used in any other operation.
.B flag
must be a
member of the enumeration corresponding to
.BR set .
.sp
.LP
Every process contains at least one
.IR "light-weight process" ,
or
.IR lwp .
Each lwp represents a flow of execution that is independently
scheduled by the operating system. All lwps in a process share its address
space as well as many other attributes. Through the use of
.B lwpctl
and
.B ctl
files as described below, it is possible to affect individual lwps
in a process or to affect all of them at once, depending on the operation.
.sp
.LP
When the process has more than one lwp, a representative lwp is chosen by
the system for certain process status files and control operations. The
representative lwp is a stopped lwp only if all of the process's lwps are
stopped; is stopped on an event of interest only if all of the lwps are so
stopped (excluding
.B PR_SUSPENDED
lwps); is in a
.B PR_REQUESTED
stop
only if there are no other events of interest to be found; or, failing
everything else, is in a
.B PR_SUSPENDED
stop (implying that the process
is deadlocked). See the description of the
.B status
file for definitions
of stopped states. See the
.B PCSTOP
control operation for the definition
of ``event of interest''.
.sp
.LP
The representative lwp remains fixed (it will be chosen again on the next
operation) as long as all of the lwps are stopped on events of interest or
are in a
.B PR_SUSPENDED
stop and the
.B PCRUN
control operation is
not applied to any of them.
.sp
.LP
When applied to the process control file, every
.B /proc
control
operation that must act on an lwp uses the same algorithm to choose which
lwp to act upon. Together with synchronous stopping (see
.BR PCSET ),
this
enables a debugger to control a multiple-lwp process using only the
process-level status and control files if it so chooses. More fine-grained
control can be achieved using the lwp-specific files.
.sp
.LP
The system supports two process data models, the traditional 32-bit data
model in which ints, longs and pointers are all 32 bits wide (the ILP32 data
model), and on some platforms the 64-bit data model in which longs and
pointers, but not ints, are 64 bits in width (the LP64 data model). In the
LP64 data model some system data types, notably
.BR size_t ,
.BR off_t ,
.B time_t
and
.BR dev_t ,
grow from 32 bits to 64 bits as well.
.sp
.LP
The
.B /proc
interfaces described here are available to both 32-bit and
64-bit controlling processes. However, many operations attempted by a 32-bit
controlling process on a 64-bit target process will fail with
.B EOVERFLOW
because the address space range of a 32-bit process cannot
encompass a 64-bit process or because the data in some 64-bit system data
type cannot be compressed to fit into the corresponding 32-bit type without
loss of information. Operations that fail in this circumstance include
reading and writing the address space, reading the address-map files, and
setting the target process's registers. There is no restriction on
operations applied by a 64-bit process to either a 32-bit or a 64-bit target
processes.
.sp
.LP
The format of the contents of any
.B /proc
file depends on the data
model of the observer (the controlling process), not on the data model of
the target process. A 64-bit debugger does not have to translate the
information it reads from a
.B /proc
file for a 32-bit process from
32-bit format to 64-bit format. However, it usually has to be aware of the
data model of the target process. The
.B pr_dmodel
field of the
.B status
files indicates the target process's data model.
.sp
.LP
To help deal with system data structures that are read from 32-bit
processes, a 64-bit controlling program can be compiled with the C
preprocessor symbol
.B _SYSCALL32
defined before system header files are
included. This makes explicit 32-bit fixed-width data structures (like
.BR "cstruct stat32" )
visible to the 64-bit program. See
.BR types32.h (3HEAD).
.SH DIRECTORY STRUCTURE
.sp
.LP
At the top level, the directory
.B /proc
contains entries each of which
names an existing process in the system. These entries are themselves
directories. Except where otherwise noted, the files described below can be
opened for reading only. In addition, if a process becomes a \fIzombie\fR
(one that has exited but whose parent has not yet performed a
.BR wait (3C)
upon it), most of its associated
.B /proc
files disappear from the
hierarchy; subsequent attempts to open them, or to read or write files
opened before the process exited, will elicit the error
.BR ENOENT .
.sp
.LP
Although process state and consequently the contents of
.B /proc
files
can change from instant to instant, a single
.BR read (2)
of a
.BR /proc
file is guaranteed to return a sane representation of state; that is, the
read will be atomic with respect to the state of the process. No such
guarantee applies to successive reads applied to a
.B /proc
file for a
running process. In addition, atomicity is not guaranteed for \fBI/O\fR
applied to the
.B as
(address-space) file for a running process or for a
process whose address space contains memory shared by another running
process.
.sp
.LP
A number of structure definitions are used to describe the files. These
structures may grow by the addition of elements at the end in future
releases of the system and it is not legitimate for a program to assume that
they will not.
.SH STRUCTURE OF \fB/proc/\fIpid\fR
.sp
.LP
A given directory \fB/proc/\fIpid\fR contains the following entries. A
process can use the invisible alias
.B /proc/self
if it wishes to open
one of its own
.B /proc
files (invisible in the sense that the name
``self'' does not appear in a directory listing of
.B /proc
obtained from
.BR ls (1),
.BR getdents (2),
or
.BR readdir (3C)).
.SS "contracts"
.sp
.LP
A directory containing references to the contracts held by the process.
Each entry is a symlink to the contract's directory under
.BR /system/contract .
See
.BR contract (4).
.SS "as"
.sp
.LP
Contains the address-space image of the process; it can be opened for both
reading and writing.
.BR lseek (2)
is used to position the file at the
virtual address of interest and then the address space can be examined or
changed through
.BR read (2)
or
.BR write (2)
(or by using
.BR pread (2)
or
.BR pwrite (2)
for the combined operation).
.SS "ctl"
.sp
.LP
A write-only file to which structured messages are written directing the
system to change some aspect of the process's state or control its behavior
in some way. The seek offset is not relevant when writing to this file.
Individual lwps also have associated
.B lwpctl
files in the lwp
subdirectories. A control message may be written either to the process's
.B ctl
file or to a specific
.B lwpctl
file with operation-specific
effects. The effect of a control message is immediately reflected in the
state of the process visible through appropriate status and information
files. The types of control messages are described in detail later. See
.BR "CONTROL MESSAGES" .
.SS "status"
.sp
.LP
Contains state information about the process and the representative lwp.
The file contains a
.B pstatus
structure which contains an embedded
.B lwpstatus
structure for the representative lwp, as follows:
.sp
.in +2
.nf
typedef struct pstatus {
     int pr_flags;            /* flags (see below) */
     int pr_nlwp;             /* number of active lwps in the process */
     int pr_nzomb;            /* number of zombie lwps in the process */
     pid_tpr_pid;             /* process id */
     pid_tpr_ppid;            /* parent process id */
     pid_tpr_pgid;            /* process group id */
     pid_tpr_sid;             /* session id */
     id_t pr_aslwpid;         /* obsolete */
     id_t pr_agentid;         /* lwp-id of the agent lwp, if any */
     sigset_t pr_sigpend;     /* set of process pending signals */
     uintptr_t pr_brkbase;    /* virtual address of the process heap */
     size_t pr_brksize;       /* size of the process heap, in bytes */
     uintptr_t pr_stkbase;    /* virtual address of the process stack */
     size_tpr_stksize;        /* size of the process stack, in bytes */
     timestruc_t pr_utime;    /* process user cpu time */
     timestruc_t pr_stime;    /* process system cpu time */
     timestruc_t pr_cutime;   /* sum of children's user times */
     timestruc_t pr_cstime;   /* sum of children's system times */
     sigset_t pr_sigtrace;    /* set of traced signals */
     fltset_t pr_flttrace;    /* set of traced faults */
     sysset_t pr_sysentry;    /* set of system calls traced on entry */
     sysset_t pr_sysexit;     /* set of system calls traced on exit */
     char pr_dmodel;          /* data model of the process */
     taskid_t pr_taskid;      /* task id */
     projid_t pr_projid;      /* project id */
     zoneid_t pr_zoneid;      /* zone id */
     lwpstatus_t pr_lwp;      /* status of the representative lwp */
} pstatus_t;
.fi
.in -2

.sp
.LP
.B pr_flags
is a bit-mask holding the following process flags. For
convenience, it also contains the lwp flags for the representative lwp,
described later.
.sp
.ne 2
.mk
.na
.B PR_ISSYS
.ad
.RS 13n
.rt
process is a system process  (see
.BR PCSTOP ).
.RE

.sp
.ne 2
.mk
.na
.B PR_VFORKP
.ad
.RS 13n
.rt
process is the parent of a vforked child (see
.BR PCWATCH ).
.RE

.sp
.ne 2
.mk
.na
.B PR_FORK
.ad
.RS 13n
.rt
process has its inherit-on-fork mode set (see
.BR PCSET ).
.RE

.sp
.ne 2
.mk
.na
.B PR_RLC
.ad
.RS 13n
.rt
process has its run-on-last-close mode set  (see
.BR PCSET ).
.RE

.sp
.ne 2
.mk
.na
.B PR_KLC
.ad
.RS 13n
.rt
process has its kill-on-last-close mode set  (see
.BR PCSET ).
.RE

.sp
.ne 2
.mk
.na
.B PR_ASYNC
.ad
.RS 13n
.rt
process has its asynchronous-stop mode set  (see
.BR PCSET ).
.RE

.sp
.ne 2
.mk
.na
.B PR_MSACCT
.ad
.RS 13n
.rt
Set by default in all processes to indicate that microstate accounting is
enabled. However, this flag has been deprecated and no longer has any
effect. Microstate accounting may not be disabled; however, it is still
possible to toggle the flag.
.RE

.sp
.ne 2
.mk
.na
.B PR_MSFORK
.ad
.RS 13n
.rt
Set by default in all processes to indicate that microstate accounting will
be enabled for processes that this parent forks(). However, this flag has
been deprecated and no longer has any effect. It is possible to toggle this
flag; however, it is not possible to disable microstate accounting.
.RE

.sp
.ne 2
.mk
.na
.B PR_BPTADJ
.ad
.RS 13n
.rt
process has its breakpoint adjustment mode set  (see
.BR PCSET ).
.RE

.sp
.ne 2
.mk
.na
.B PR_PTRACE
.ad
.RS 13n
.rt
process has its ptrace-compatibility mode set  (see
.BR PCSET ).
.RE

.sp
.LP
.B pr_nlwp
is the total number of active lwps in the process. pr_nzomb
is the total number of zombie lwps in the process. A zombie lwp is a
non-detached lwp that has terminated but has not been reaped with
.BR thr_join (3C)
or
.BR pthread_join (3C).
.sp
.LP
.BR pr_pid ,
.BR pr_ppid ,
.BR pr_pgid ,
and
.B pr_sid
are,
respectively, the process ID, the ID of the process's parent, the process's
process group ID, and the process's session ID.
.sp
.LP
.B pr_aslwpid
is obsolete and is always zero.
.sp
.LP
.B pr_agentid
is the lwp-ID for the
.B /proc
agent lwp (see the
.B PCAGENT
control operation). It is zero if there is no agent lwp in the
process.
.sp
.LP
.B pr_sigpend
identifies asynchronous signals pending for the process.
.sp
.LP
.B pr_brkbase
is the virtual address of the process heap and
.B pr_brksize
is its size in bytes. The address formed by the sum of
these values is the process
.B break
(see
.BR brk (2)).
.B pr_stkbase
and
.B pr_stksize
are, respectively, the virtual address of the process
stack and its size in bytes. (Each lwp runs on a separate stack; the
distinguishing characteristic of the process stack is that the operating
system will grow it when necessary.)
.sp
.LP
.BR pr_utime ,
.BR pr_stime ,
.BR pr_cutime ,
and
.B pr_cstime
are,
respectively, the user
.B CPU
and system
.B CPU
time consumed by the
process, and the cumulative user
.B CPU
and system
.B CPU
time
consumed by the process's children, in seconds and nanoseconds.
.sp
.LP
.B pr_sigtrace
and
.B pr_flttrace
contain, respectively, the set of
signals and the set of hardware faults that are being traced (see
.B PCSTRACE
and
.BR PCSFAULT ).
.sp
.LP
.B pr_sysentry
and
.B pr_sysexit
contain, respectively, the sets of
system calls being traced on entry and exit (see
.B PCSENTRY
and
.BR PCSEXIT ).
.sp
.LP
.B pr_dmodel
indicates the data model of the process. Possible values
are:
.sp
.ne 2
.mk
.na
.B PR_MODEL_ILP32
.ad
.RS 19n
.rt
process data model is ILP32.
.RE

.sp
.ne 2
.mk
.na
.B PR_MODEL_LP64
.ad
.RS 19n
.rt
process data model is LP64.
.RE

.sp
.ne 2
.mk
.na
.B PR_MODEL_NATIVE
.ad
.RS 19n
.rt
process data model is native.
.RE

.sp
.LP
The
.BR pr_taskid ,
.BR pr_projid ,
and
.B pr_zoneid
fields contain
respectively, the numeric \fBID\fRs of the task, project, and zone in which
the process was running.
.sp
.LP
The constant
.B PR_MODEL_NATIVE
reflects the data model of the
controlling process,
.IR "that is" ,
its value is
.B PR_MODEL_ILP32
or
.B PR_MODEL_LP64
according to whether the controlling process has been
compiled as a 32-bit program or a 64-bit program, respectively.
.sp
.LP
.B pr_lwp
contains the status information for the representative lwp:
.sp
.in +2
.nf
typedef struct lwpstatus {
  int pr_flags;              /* flags (see below) */
  id_t pr_lwpid;             /* specific lwp identifier */
  short pr_why;              /* reason for lwp stop, if stopped */
  short pr_what;             /* more detailed reason */
  short pr_cursig;           /* current signal, if any */
  siginfo_t pr_info;         /* info associated with signal or fault */
  sigset_t pr_lwppend;       /* set of signals pending to the lwp */
  sigset_t pr_lwphold;       /* set of signals blocked by the lwp */
  struct sigaction pr_action;/* signal action for current signal */
  stack_t pr_altstack;       /* alternate signal stack info */
  uintptr_t pr_oldcontext;   /* address of previous ucontext */
  short pr_syscall;          /* system call number (if in syscall) */
  short pr_nsysarg;          /* number of arguments to this syscall */
  int pr_errno;              /* errno for failed syscall */
  long pr_sysarg[PRSYSARGS]; /* arguments to this syscall */
  long pr_rval1;             /* primary syscall return value */
  long pr_rval2;             /* second syscall return value, if any */
  char pr_clname[PRCLSZ];    /* scheduling class name */
  timestruc_t pr_tstamp;     /* real-time time stamp of stop */
  timestruc_t pr_utime;      /* lwp user cpu time */
  timestruc_t pr_stime;      /* lwp system cpu time */
  uintptr_t pr_ustack;       /* stack boundary data (stack_t) address */
  ulong_t pr_instr;          /* current instruction */
  prgregset_t pr_reg;        /* general registers */
  prfpregset_t pr_fpreg;     /* floating-point registers */
} lwpstatus_t;
.fi
.in -2

.sp
.LP
.B pr_flags
is a bit-mask holding the following lwp flags. For
convenience, it also contains the process flags, described previously.
.sp
.ne 2
.mk
.na
.B PR_STOPPED
.ad
.RS 14n
.rt
The lwp is stopped.
.RE

.sp
.ne 2
.mk
.na
.B PR_ISTOP
.ad
.RS 14n
.rt
The lwp is stopped on an event of interest (see
.BR PCSTOP ).
.RE

.sp
.ne 2
.mk
.na
.B PR_DSTOP
.ad
.RS 14n
.rt
The lwp has a stop directive in effect (see
.BR PCSTOP ).
.RE

.sp
.ne 2
.mk
.na
.B PR_STEP
.ad
.RS 14n
.rt
The lwp has a single-step directive in effect (see
.BR PCRUN ).
.RE

.sp
.ne 2
.mk
.na
.B PR_ASLEEP
.ad
.RS 14n
.rt
The lwp is in an interruptible sleep within a system call.
.RE

.sp
.ne 2
.mk
.na
.B PR_PCINVAL
.ad
.RS 14n
.rt
The lwp's current instruction (\fBpr_instr\fR) is undefined.
.RE

.sp
.ne 2
.mk
.na
.B PR_DETACH
.ad
.RS 14n
.rt
This is a detached lwp (see
.BR pthread_create (3C)
and
.BR pthread_join (3C)).
.RE

.sp
.ne 2
.mk
.na
.B PR_DAEMON
.ad
.RS 14n
.rt
This is a daemon lwp (see
.BR pthread_create (3C)).
.RE

.sp
.ne 2
.mk
.na
.B PR_ASLWP
.ad
.RS 14n
.rt
This flag is obsolete and is never set.
.RE

.sp
.ne 2
.mk
.na
.B PR_AGENT
.ad
.RS 14n
.rt
This is the
.B /proc
agent lwp for the process.
.RE

.sp
.LP
.B pr_lwpid
names the specific lwp.
.sp
.LP
.B pr_why
and
.B pr_what
together describe, for a stopped lwp, the
reason for the stop. Possible values of
.B pr_why
and the associated
.B pr_what
are:
.sp
.ne 2
.mk
.na
.B PR_REQUESTED
.ad
.RS 17n
.rt
indicates that the stop occurred in response to a stop directive, normally
because
.B PCSTOP
was applied or because another lwp stopped on an event
of interest and the asynchronous-stop flag (see
.BR PCSET )
was not set for
the process.
.B pr_what
is unused in this case.
.RE

.sp
.ne 2
.mk
.na
.B PR_SIGNALLED
.ad
.RS 17n
.rt
indicates that the lwp stopped on receipt of a signal (see
.BR PCSTRACE );
.B pr_what
holds the signal number that caused the stop (for a
newly-stopped lwp, the same value is in
.BR pr_cursig ).
.RE

.sp
.ne 2
.mk
.na
.B PR_FAULTED
.ad
.RS 17n
.rt
indicates that the lwp stopped on incurring a hardware fault (see
.BR PCSFAULT );
.B pr_what
holds the fault number that caused the
stop.
.RE

.sp
.ne 2
.mk
.na
.B PR_SYSENTRY
.ad
.br
.na
.B PR_SYSEXIT
.ad
.RS 17n
.rt
indicate a stop on entry to or exit from a system call (see \fBPCSENTRY\fR
and
.BR PCSEXIT );
.B pr_what
holds the system call number.
.RE

.sp
.ne 2
.mk
.na
.B PR_JOBCONTROL
.ad
.RS 17n
.rt
indicates that the lwp stopped due to the default action of a job control
stop signal (see
.BR sigaction (2));
.B pr_what
holds the stopping
signal number.
.RE

.sp
.ne 2
.mk
.na
.B PR_SUSPENDED
.ad
.RS 17n
.rt
indicates that the lwp stopped due to internal synchronization of lwps
within the process.
.B pr_what
is unused in this case.
.RE

.sp
.LP
.B pr_cursig
names the current signal, that is, the next signal to be
delivered to the lwp, if any.
.BR pr_info ,
when the lwp is in a
.B PR_SIGNALLED
or
.B PR_FAULTED
stop, contains additional information
pertinent to the particular signal or fault (see
.BR <sys/siginfo.h> ).
.sp
.LP
.B pr_lwppend
identifies any synchronous or directed signals pending for
the lwp.
.B pr_lwphold
identifies those signals whose delivery is being
blocked by the lwp (the signal mask).
.sp
.LP
.B pr_action
contains the signal action information pertaining to the
current signal (see
.BR sigaction (2));
it is undefined if
.BR pr_cursig
is zero.
.B pr_altstack
contains the alternate signal stack information
for the lwp (see
.BR sigaltstack (2)).
.sp
.LP
.BR pr_oldcontext ,
if not zero, contains the address on the lwp stack of
a
.B ucontext
structure describing the previous user-level context (see
.BR ucontext.h (3HEAD)).
It is non-zero only if the lwp is executing in the
context of a signal handler.
.sp
.LP
.B pr_syscall
is the number of the system call, if any, being executed
by the lwp; it is non-zero if and only if the lwp is stopped on
.B PR_SYSENTRY
or
.BR PR_SYSEXIT ,
or is asleep within a system call (
.B PR_ASLEEP
is set). If
.B pr_syscall
is non-zero,
.B pr_nsysarg
is the number of arguments to the system call and
.B pr_sysarg
contains
the actual arguments.
.sp
.LP
.BR pr_rval1 ,
.BR pr_rval2 ,
and
.B pr_errno
are defined only if the
lwp is stopped on
.B PR_SYSEXIT
or if the
.B PR_VFORKP
flag is set. If
.B pr_errno
is zero,
.B pr_rval1
and
.B pr_rval2
contain the return
values from the system call. Otherwise,
.B pr_errno
contains the error
number for the failing system call (see
.BR <sys/errno.h> ).
.sp
.LP
.B pr_clname
contains the name of the lwp's scheduling class.
.sp
.LP
.BR pr_tstamp ,
if the lwp is stopped, contains a time stamp marking when
the lwp stopped, in real time seconds and nanoseconds since an arbitrary
time in the past.
.sp
.LP
.B pr_utime
is the amount of user level CPU time used by this LWP.
.sp
.LP
.B pr_stime
is the amount of system level CPU time used by this LWP.
.sp
.LP
.B pr_ustack
is the virtual address of the
.B stack_t
that contains
the stack boundaries for this LWP. See
.BR getustack (2)
and
.BR _stack_grow (3C).
.sp
.LP
.B pr_instr
contains the machine instruction to which the lwp's program
counter refers. The amount of data retrieved from the process is
machine-dependent. On SPARC based machines, it is a 32-bit word. On
x86-based machines, it is a single byte. In general, the size is that of the
machine's smallest instruction. If
.B PR_PCINVAL
.RB "is set," " pr_instr"
is undefined; this occurs whenever the lwp is not stopped or when the
program counter refers to an invalid virtual address.
.sp
.LP
.B pr_reg
is an array holding the contents of a stopped lwp's general
registers.
.sp
.ne 2
.mk
.na
.B SPARC
.ad
.RS 21n
.rt
On SPARC-based machines, the predefined constants
.B R_G0
\&.\|.\|.
.BR R_G7 ,
.B R_O0
\&.\|.\|.
.BR R_O7 ,
.B R_L0
\&.\|.\|.
.BR R_L7 ,
.B R_I0
\&.\|.\|.
.BR R_I7 ,
.BR R_PC ,
.BR R_nPC ,
and
.B R_Y
can be used as
indices to refer to the corresponding registers; previous register windows
can be read from their overflow locations on the stack (however, see the
\fBgwindows\fR file in the \fB/proc/\fIpid\fB/lwp/\fIlwpid\fR
subdirectory).
.RE

.sp
.ne 2
.mk
.na
.B SPARC V8 (32-bit)
.ad
.RS 21n
.rt
For SPARC V8 (32-bit) controlling processes, the predefined constants
.BR R_PSR ,
.BR R_WIM ,
and
.B R_TBR
can be used as indices to refer to
the corresponding special registers. For SPARC V9 (64-bit) controlling
processes, the predefined constants
.BR R_CCR ,
.BR R_ASI ,
and
.B R_FPRS
can be used as indices to refer to the corresponding special
registers.
.RE

.sp
.ne 2
.mk
.na
.B x86 (32-bit)
.ad
.RS 21n
.rt
For 32-bit x86 processes, the predefined constants listed belowcan be used
as indices to refer to the corresponding registers.
.sp
.in +2
.nf
SS
UESP
EFL
CS
EIP
ERR
TRAPNO
EAX
ECX
EDX
EBX
ESP
EBP
ESI
EDI
DS
ES
GS
.fi
.in -2

The preceding constants are listed in \fB<sys/regset.h>\fR\&.
.sp
Note that a 32-bit process can run on an x86 64-bit system, using the
constants listed above.
.RE

.sp
.ne 2
.mk
.na
.B x86 (64-bit)
.ad
.RS 21n
.rt
To read the registers of a 32-
.B or
a 64-bit process, a 64-bit x86
process should use the predefined constants listed below.
.sp
.in +2
.nf
REG_GSBASE
REG_FSBASE
REG_DS
REG_ES
REG_GS
REG_FS
REG_SS
REG_RSP
REG_RFL
REG_CS
REG_RIP
REG_ERR
REG_TRAPNO
REG_RAX
REG_RCX
REG_RDX
REG_RBX
REG_RBP
REG_RSI
REG_RDI
REG_R8
REG_R9
REG_R10
REG_R11
REG_R12
REG_R13
REG_R14
REG_R15
.fi
.in -2

The preceding constants are listed in \fB<sys/regset.h>\fR\&.
.RE

.sp
.LP
.B pr_fpreg
is a structure holding the contents of the floating-point
registers.
.sp
.LP
SPARC registers, both general and floating-point, as seen by a 64-bit
controlling process are the V9 versions of the registers, even if the target
process is a 32-bit (V8) process. V8 registers are a subset of the V9
registers.
.sp
.LP
If the lwp is not stopped, all register values are undefined.
.SS "psinfo"
.sp
.LP
Contains miscellaneous information about the process and the representative
lwp needed by the
.BR ps (1)
command.
.B psinfo
remains accessible after
a process becomes a
.IR zombie .
The file contains a
.B psinfo
structure
which contains an embedded
.B lwpsinfo
structure for the representative
lwp, as follows:
.sp
.in +2
.nf
typedef struct psinfo {
    int pr_flag;             /* process flags (DEPRECATED: see below) */
    int pr_nlwp;             /* number of active lwps in the process */
    int pr_nzomb;            /* number of zombie lwps in the process */
    pid_t pr_pid;            /* process id */
    pid_t pr_ppid;           /* process id of parent */
    pid_t pr_pgid;           /* process id of process group leader */
    pid_t pr_sid;            /* session id */
    uid_t pr_uid;            /* real user id */
    uid_t pr_euid;           /* effective user id */
    gid_t pr_gid;            /* real group id */
    gid_t pr_egid;           /* effective group id */
    uintptr_t pr_addr;       /* address of process */
    size_t pr_size;          /* size of process image in Kbytes */
    size_t pr_rssize;        /* resident set size in Kbytes */
    dev_t pr_ttydev;         /* controlling tty device (or PRNODEV) */
    ushort_t pr_pctcpu;      /* % of recent cpu time used by all lwps */
    ushort_t pr_pctmem;      /* % of system memory used by process */
    timestruc_t pr_start;    /* process start time, from the epoch */
    timestruc_t pr_time;     /* cpu time for this process */
    timestruc_t pr_ctime;    /* cpu time for reaped children */
    char pr_fname[PRFNSZ];   /* name of exec'ed file */
    char pr_psargs[PRARGSZ]; /* initial characters of arg list */
    int pr_wstat;            /* if zombie, the wait() status */
    int pr_argc;             /* initial argument count */
    uintptr_t pr_argv;       /* address of initial argument vector */
    uintptr_t pr_envp;       /* address of initial environment vector */
    char pr_dmodel;          /* data model of the process */
    lwpsinfo_t pr_lwp;       /* information for representative lwp */
    taskid_t pr_taskid;      /* task id */
    projid_t pr_projid;      /* project id */
    poolid_t pr_poolid;      /* pool id */
    zoneid_t pr_zoneid;      /* zone id */
    ctid_t pr_contract;      /* process contract id */
} psinfo_t;
.fi
.in -2

.sp
.LP
Some of the entries in
.BR psinfo ,
such as
.BR pr_addr ,
refer to
internal kernel data structures and should not be expected to retain their
meanings across different versions of the operating system.
.sp
.LP
.B psinfo_t.pr_flag
is a deprecated interface that should no longer be
used. Applications currently relying on the
.B SSYS
bit in \fBpr_flag\fR
should migrate to checking
.B PR_ISSYS
in the
.B pstatus
structure's
.B pr_flags
field.
.sp
.LP
.B pr_pctcpu
and
.B pr_pctmem
are 16-bit binary fractions in the
range 0.0 to 1.0 with the binary point to the right of the high-order bit
(1.0 == 0x8000).
.B pr_pctcpu
is the summation over all lwps in the
process.
.sp
.LP
.B pr_lwp
contains the
.BR ps (1)
information for the representative
lwp. If the process is a
.IR zombie ,
.BR pr_nlwp ,
.BR pr_nzomb ,
and
.B pr_lwp.pr_lwpid
are zero and the other fields of
.B pr_lwp
are
undefined:
.sp
.in +2
.nf
typedef struct lwpsinfo {
    int pr_flag;             /* lwp flags (DEPRECATED: see below) */
    id_t pr_lwpid;           /* lwp id */
    uintptr_t pr_addr;       /* internal address of lwp */
    uintptr_t pr_wchan;      /* wait addr for sleeping lwp */
    char pr_stype;           /* synchronization event type */
    char pr_state;           /* numeric lwp state */
    char pr_sname;           /* printable character for pr_state */
    char pr_nice;            /* nice for cpu usage */
    short pr_syscall;        /* system call number (if in syscall) */
    char pr_oldpri;          /* pre-SVR4, low value is high priority */
    char pr_cpu;             /* pre-SVR4, cpu usage for scheduling */
    int pr_pri;              /* priority, high value = high priority */
    ushort_t pr_pctcpu;      /* % of recent cpu time used by this lwp */
    timestruc_t pr_start;    /* lwp start time, from the epoch */
    timestruc_t pr_time;     /* cpu time for this lwp */
    char pr_clname[PRCLSZ];  /* scheduling class name */
    char pr_name[PRFNSZ];    /* name of system lwp */
    processorid_t pr_onpro;  /* processor which last ran this lwp */
    processorid_t pr_bindpro;/* processor to which lwp is bound */
    psetid_t pr_bindpset;    /* processor set to which lwp is bound */
    lgrp_id_t pr_lgrp	      /* home lgroup */
} lwpsinfo_t;
.fi
.in -2

.sp
.LP
Some of the entries in
.BR lwpsinfo ,
such as
.BR pr_addr ,
.BR pr_wchan ,
.BR pr_stype ,
.BR pr_state ,
and
.BR pr_name ,
refer to
internal kernel data structures and should not be expected to retain their
meanings across different versions of the operating system.
.sp
.LP
.B lwpsinfo_t.pr_flag
is a deprecated interface that should no longer be
used.
.sp
.LP
.B pr_pctcpu
is a 16-bit binary fraction, as described above. It
represents the
.B CPU
time used by the specific lwp. On a multi-processor
machine, the maximum value is 1/N, where N is the number of \fBCPU\fRs.
.sp
.LP
.B pr_contract
is the id of the process contract of which the process is
a member. See
.BR contract (4)
and
.BR process (4).
.SS "cred"
.sp
.LP
Contains a description of the credentials associated with the process:
.sp
.in +2
.nf
typedef struct prcred {
	uid_t pr_euid;      /* effective user id */
	uid_t pr_ruid;      /* real user id */
	uid_t pr_suid;      /* saved user id (from exec) */
	gid_t pr_egid;      /* effective group id */
	gid_t pr_rgid;      /* real group id */
	gid_t pr_sgid;      /* saved group id (from exec) */
	int pr_ngroups;     /* number of supplementary groups */
	gid_t pr_groups[1]; /* array of supplementary groups */
} prcred_t;
.fi
.in -2
.sp

.sp
.LP
The array of associated supplementary groups in
.B pr_groups
is of
variable length; the
.B cred
file contains all of the supplementary
groups.
.B pr_ngroups
indicates the number of supplementary groups. (See
also the
.B PCSCRED
and
.B PCSCREDX
control operations.)
.SS "priv"
.sp
.LP
Contains a description of the privileges associated with the process:
.sp
.in +2
.nf
typedef struct prpriv {
     uint32_t        pr_nsets;      /* number of privilege set */
     uint32_t        pr_setsize;    /* size of privilege set */
     uint32_t        pr_infosize;   /* size of supplementary data */
     priv_chunk_t    pr_sets[1];    /* array of sets */
} prpriv_t;
.fi
.in -2

.sp
.LP
The actual dimension of the
.BR pr_sets []
field is
.sp
.in +2
.nf
pr_sets[pr_nsets][pr_setsize]
.fi
.in -2

.sp
.LP
which is followed by additional information about the process state
.B pr_infosize
bytes in size.
.sp
.LP
The full size of the structure can be computed using
\fBPRIV_PRPRIV_SIZE\fR(\fBprpriv_t *\fR).
.SS "sigact"
.sp
.LP
Contains an array of
.B "sigaction structures"
describing the current
dispositions of all signals associated with the traced process (see
.BR sigaction (2)).
Signal numbers are displaced by 1 from array indices,
so that the action for signal number
.I n
appears in position
.IR n -1
of the array.
.SS "auxv"
.sp
.LP
Contains the initial values of the process's aux vector in an array of
.B auxv_t
structures (see
.BR <sys/auxv.h> ).
The values are those that
were passed by the operating system as startup information to the dynamic
linker.
.SS "ldt"
.sp
.LP
This file exists only on x86-based machines. It is non-empty only if the
process has established a local descriptor table
.RB ( LDT ).
If non-empty,
the file contains the array of currently active
.B LDT
entries in an
array of elements of type
.BR "struct ssd" ,
defined in
.BR <sys/sysi86.h> ,
one element for each active
.B LDT
entry.
.SS "map, xmap"
.sp
.LP
Contain information about the virtual address map of the process. The map
file contains an array of
.B prmap
structures while the xmap file
contains an array of
.B prxmap
structures. Each structure describes a
contiguous virtual address region in the address space of the traced
process:
.sp
.in +2
.nf
typedef struct prmap {
	uintptr_tpr_vaddr;         /* virtual address of mapping */
	size_t pr_size;            /* size of mapping in bytes */
	char pr_mapname[PRMAPSZ];  /* name in /proc/pid/object */
	offset_t pr_offset;        /* offset into mapped object, if any */
	int pr_mflags;             /* protection and attribute flags */
	int pr_pagesize;           /* pagesize for this mapping in bytes */
	int pr_shmid;              /* SysV shared memory identifier */
} prmap_t;
.fi
.in -2
.sp

.sp
.in +2
.nf
typedef struct prxmap {
	uintptr_t pr_vaddr;        /* virtual address of mapping */
	size_t pr_size;            /* size of mapping in bytes */
	char pr_mapname[PRMAPSZ];  /* name in /proc/pid/object */
	offset_t pr_offset;        /* offset into mapped object, if any */
	int pr_mflags;             /* protection and attribute flags */
	int pr_pagesize;           /* pagesize for this mapping in bytes */
	int pr_shmid;              /* SysV shared memory identifier */
	dev_t pr_dev;              /* device of mapped object, if any */
	uint64_t pr_ino;           /* inode of mapped object, if any */
	size_t pr_rss;             /* pages of resident memory */
	size_t pr_anon;            /* pages of resident anonymous memory */
	size_t pr_locked;          /* pages of locked memory */
	uint64_t pr_hatpagesize;   /* pagesize of mapping */
} prxmap_t;
.fi
.in -2
.sp

.sp
.LP
.B pr_vaddr
is the virtual address of the mapping within the traced
process and
.B pr_size
is its size in bytes.
.BR pr_mapname ,
if it does
not contain a null string, contains the name of a file in the \fBobject\fR
directory (see below) that can be opened read-only to obtain a file
descriptor for the mapped file associated with the mapping. This enables a
debugger to find object file symbol tables without having to know the real
path names of the executable file and shared libraries of the process.
.B pr_offset
is the 64-bit offset within the mapped file (if any) to
which the virtual address is mapped.
.sp
.LP
.B pr_mflags
is a bit-mask of protection and attribute flags:
.sp
.ne 2
.mk
.na
.B MA_READ
.ad
.RS 17n
.rt
mapping is readable by the traced process.
.RE

.sp
.ne 2
.mk
.na
.B MA_WRITE
.ad
.RS 17n
.rt
mapping is writable by the traced process.
.RE

.sp
.ne 2
.mk
.na
.B MA_EXEC
.ad
.RS 17n
.rt
mapping is executable by the traced process.
.RE

.sp
.ne 2
.mk
.na
.B MA_SHARED
.ad
.RS 17n
.rt
mapping changes are shared by the mapped object.
.RE

.sp
.ne 2
.mk
.na
.B MA_ISM
.ad
.RS 17n
.rt
mapping is intimate shared memory (shared MMU resources)
.RE

.sp
.ne 2
.mk
.na
.B MAP_NORESERVE
.ad
.RS 17n
.rt
mapping does not have swap space reserved (mapped with MAP_NORESERVE)
.RE

.sp
.ne 2
.mk
.na
.B MA_SHM
.ad
.RS 17n
.rt
mapping System V shared memory
.RE

.sp
.LP
A contiguous area of the address space having the same underlying mapped
object may appear as multiple mappings due to varying read, write, and
execute attributes. The underlying mapped object does not change over the
range of a single mapping. An
.B I/O
operation to a mapping marked
.B MA_SHARED
fails if applied at a virtual address not corresponding to a
.RB "valid page in the underlying mapped object. A write to a" " MA_SHARED"
mapping that is not marked
.B MA_WRITE
fails. Reads and writes to private
mappings always succeed. Reads and writes to unmapped addresses fail.
.sp
.LP
.B pr_pagesize
is the page size for the mapping, currently always the
system pagesize.
.sp
.LP
.B pr_shmid
is the shared memory identifier, if any, for the mapping.
Its value is \fB\(mi1\fR if the mapping is not System V shared memory. See
.BR shmget (2).
.sp
.LP
.B pr_dev
is the device of the mapped object, if any, for the mapping.
Its value is
.B PRNODEV
(-1) if the mapping does not have a device.
.sp
.LP
.B pr_ino
is the inode of the mapped object, if any, for the mapping.
Its contents are only valid if
.B pr_dev
is not
.BR PRNODEV.
.sp
.LP
.B pr_rss
is the number of resident pages of memory for the mapping. The
number of resident bytes for the mapping may be determined by multiplying
.B pr_rss
by the page size given by
.BR pr_pagesize.
.sp
.LP
.B pr_anon
is the number of resident anonymous memory pages (pages which
are private to this process) for the mapping.
.sp
.LP
.B pr_locked
is the number of locked pages for the mapping. Pages which
are locked are always resident in memory.
.sp
.LP
.B pr_hatpagesize
is the size, in bytes, of the
.B HAT
(\fBMMU\fR)
translation for the mapping.
.B pr_hatpagesize
may be different than
.B pr_pagesize.
The possible values are hardware architecture specific,
and may change over a mapping's lifetime.
.SS "rmap"
.sp
.LP
Contains information about the reserved address ranges of the process. The
file contains an array of
.B prmap
structures, as defined above for the
.B map
file. Each structure describes a contiguous virtual address region
in the address space of the traced process that is reserved by the system in
the sense that an
.BR mmap (2)
system call that does not specify
.B MAP_FIXED
will not use any part of it for the new mapping. Examples of
such reservations include the address ranges reserved for the process stack
and the individual thread stacks of a multi-threaded process.
.SS "cwd"
.sp
.LP
A symbolic link to the process's current working directory. See
\fBchdir\fR(2). A \fBreadlink\fR(2) of \fB/proc/\fIpid\fR/cwd\fR yields a
null string. However, it can be opened, listed, and searched as a directory,
and can be the target of
.BR chdir (2).
.SS "root"
.sp
.LP
A symbolic link to the process's root directory.
\fB/proc/\fIpid\fB/root\fR can differ from the system root directory
if the process or one of its ancestors executed
.BR chroot (2)
as super
user. It has the same semantics as \fB/proc/\fIpid\fB/cwd\fR.
.SS "fd"
.sp
.LP
A directory containing references to the open files of the process. Each
entry is a decimal number corresponding to an open file descriptor in the
process.
.sp
.LP
If an entry refers to a regular file, it can be opened with normal file
system semantics but, to ensure that the controlling process cannot gain
greater access than the controlled process, with no file access modes other
than its read/write open modes in the controlled process. If an entry refers
to a directory, it can be accessed with the same semantics as
\fB/proc/\fIpid\fR/cwd\fR. An attempt to open any other type of entry fails
with
.BR EACCES .
.SS "object"
.sp
.LP
A directory containing read-only files with names corresponding to the
.B pr_mapname
entries in the
.B map
and
.B pagedata
files. Opening
such a file yields a file descriptor for the underlying mapped file
associated with an address-space mapping in the process. The file name
.B a.out
appears in the directory as an alias for the process's
executable file.
.sp
.LP
The
.B object
directory makes it possible for a controlling process to
gain access to the object file and any shared libraries (and consequently
the symbol tables) without having to know the actual path names of the
executable files.
.SS "path"
.sp
.LP
A directory containing symbolic links to files opened by the process. The
directory includes one entry for
.B cwd
and
.BR root .
The directory
also contains a numerical entry for each file descriptor in the \fBfd\fR
directory, and entries matching those in the
.B object
directory. If this
information is not available, any attempt to read the contents of the
symbolic link will fail. This is most common for files that do not exist in
the filesystem namespace (such as \fBFIFO\fRs and sockets), but can also
happen for regular files. For the file descriptor entries, the path may be
different from the one used by the process to open the file.
.SS "pagedata"
.sp
.LP
Opening the page data file enables tracking of address space references and
modifications on a per-page basis.
.sp
.LP
A
.BR read (2)
of the page data file descriptor returns structured page
data and atomically clears the page data maintained for the file by the
system. That is to say, each read returns data collected since the last
read; the first read returns data collected since the file was opened. When
the call completes, the read buffer contains the following structure as its
header and thereafter contains a number of section header structures and
associated byte arrays that must be accessed by walking linearly through the
buffer.
.sp
.in +2
.nf
typedef struct prpageheader {
    timestruc_t pr_tstamp; /* real time stamp, time of read() */
    ulong_t pr_nmap;       /* number of address space mappings */
    ulong_t pr_npage;      /* total number of pages */
} prpageheader_t;
.fi
.in -2

.sp
.LP
The header is followed by
.B "pr_nmap prasmap"
structures and associated
data arrays. The
.B prasmap
structure contains the following elements:
.sp
.in +2
.nf
typedef struct prasmap {
    uintptr_t pr_vaddr;        /* virtual address of mapping */
    ulong_t pr_npage;          /* number of pages in mapping */
    char pr_mapname[PRMAPSZ];  /* name in /proc/pid/object */
    offset_t pr_offset;        /* offset into mapped object, if any */
    int pr_mflags;             /* protection and attribute flags */
    int pr_pagesize;           /* pagesize for this mapping in bytes */
    int pr_shmid;              /* SysV shared memory identifier */
} prasmap_t;
.fi
.in -2

.sp
.LP
Each section header is followed by
.B pr_npage
bytes, one byte for each
page in the mapping, plus 0-7 null bytes at the end so that the next
.B prasmap
structure begins on an eight-byte aligned boundary. Each data
byte may contain these flags:
.sp
.ne 2
.mk
.na
.B PG_REFERENCED
.ad
.RS 17n
.rt
page has been referenced.
.RE

.sp
.ne 2
.mk
.na
.B PG_MODIFIED
.ad
.RS 17n
.rt
page has been modified.
.RE

.sp
.LP
If the read buffer is not large enough to contain all of the page data, the
read fails with
.B E2BIG
and the page data is not cleared. The required
size of the read buffer can be determined through
.BR fstat (2).
Application of
.BR lseek (2)
to the page data file descriptor is
ineffective; every read starts from the beginning of the file. Closing the
page data file descriptor terminates the system overhead associated with
collecting the data.
.sp
.LP
More than one page data file descriptor for the same process can be opened,
up to a system-imposed limit per traced process. A read of one does not
affect the data being collected by the system for the others. An open of the
page data file will fail with
.B ENOMEM
if the system-imposed limit would
be exceeded.
.SS "watch"
.sp
.LP
Contains an array of
.B prwatch
structures, one for each watched area
established by the
.B PCWATCH
control operation. See
.B PCWATCH
for
details.
.SS "usage"
.sp
.LP
Contains process usage information described by a
.B prusage
structure
which contains at least the following fields:
.sp
.in +2
.nf
typedef struct prusage {
    id_t pr_lwpid;           /* lwp id.  0: process or defunct */
    int pr_count;            /* number of contributing lwps */
    timestruc_t pr_tstamp;   /* real time stamp, time of read() */
    timestruc_t pr_create;   /* process/lwp creation time stamp */
    timestruc_t pr_term;     /* process/lwp termination time stamp */
    timestruc_t pr_rtime;    /* total lwp real (elapsed) time */
    timestruc_t pr_utime;    /* user level CPU time */
    timestruc_t pr_stime;    /* system call CPU time */
    timestruc_t pr_ttime;    /* other system trap CPU time */
    timestruc_t pr_tftime;   /* text page fault sleep time */
    timestruc_t pr_dftime;   /* data page fault sleep time */
    timestruc_t pr_kftime;   /* kernel page fault sleep time */
    timestruc_t pr_ltime;    /* user lock wait sleep time */
    timestruc_t pr_slptime;  /* all other sleep time */
    timestruc_t pr_wtime;    /* wait-cpu (latency) time */
    timestruc_t pr_stoptime; /* stopped time */
    ulong_t pr_minf;         /* minor page faults */
    ulong_t pr_majf;         /* major page faults */
    ulong_t pr_nswap;        /* swaps */
    ulong_t pr_inblk;        /* input blocks */
    ulong_t pr_oublk;        /* output blocks */
    ulong_t pr_msnd;         /* messages sent */
    ulong_t pr_mrcv;         /* messages received */
    ulong_t pr_sigs;         /* signals received */
    ulong_t pr_vctx;         /* voluntary context switches */
    ulong_t pr_ictx;         /* involuntary context switches */
    ulong_t pr_sysc;         /* system calls */
    ulong_t pr_ioch;         /* chars read and written */
} prusage_t;
.fi
.in -2

.sp
.LP
Microstate accounting is now continuously enabled. While this information
was previously an estimate, if microstate accounting were not enabled, the
current information is now never an estimate represents time the process has
spent in various states.
.SS "lstatus"
.sp
.LP
Contains a
.B prheader
structure followed by an array of
.BR lwpstatus
structures, one for each active lwp in the process (see also
\fB/proc/\fIpid\fB/lwp/\fIlwpid\fR/\fBlwpstatus\fR,
below). The
.B prheader
structure describes the number and size of the
array entries that follow.
.sp
.in +2
.nf
typedef struct prheader {
    long pr_nent;        /* number of entries */
    size_t pr_entsize;   /* size of each entry, in bytes */
} prheader_t;
.fi
.in -2

.sp
.LP
The
.B lwpstatus
structure may grow by the addition of elements at the
end in future releases of the system. Programs must use
.B pr_entsize
in
the file header to index through the array. These comments apply to all
.B /proc
files that include a
.B prheader
structure (\fBlpsinfo\fR and
.BR lusage ,
below).
.SS "lpsinfo"
.sp
.LP
Contains a
.B prheader
structure followed by an array of \fBlwpsinfo\fR
structures, one for eachactive and zombie lwp in the process. See also
\fB/proc/\fIpid\fB/lwp/\fIlwpid\fR/\fBlwpsinfo\fR, below.
.SS "lusage"
.sp
.LP
Contains a
.B prheader
structure followed by an array of
.BR prusage
structures, one for each active lwp in the process, plus an additional
element at the beginning that contains the summation over all defunct lwps
(lwps that once existed but no longer exist in the process). Excluding the
.BR pr_lwpid ,
.BR pr_tstamp ,
.BR pr_create ,
and
.B pr_term
entries,
the entry-by-entry summation over all these structures is the definition of
the process usage information obtained from the
.B usage
file. (See also
\fB/proc/\fIpid\fB/lwp/\fIlwpid\fR/\fBlwpusage\fR, below.)
.SS "lwp"
.sp
.LP
A directory containing entries each of which names an active or zombie lwp
within the process. These entries are themselves directories containing
additional files as described below. Only the
.B lwpsinfo
file exists in
the directory of a zombie lwp.
.SH STRUCTURE OF \fB/proc/\fIpid\fB/lwp/\fR \fIlwpid\fR
.sp
.LP
A given directory \fB/proc/\fIpid\fB/lwp/\fIlwpid\fR contains the
following entries:
.SS "lwpctl"
.sp
.LP
Write-only control file. The messages written to this file affect the
specific lwp rather than the representative lwp, as is the case for the
process's
.B ctl
file.
.SS "lwpstatus"
.sp
.LP
lwp-specific state information. This file contains the \fBlwpstatus\fR
structure for the specific lwp as described above for the representative lwp
in the process's
.B status
file.
.SS "lwpsinfo"
.sp
.LP
lwp-specific
.BR ps (1)
information. This file contains the \fBlwpsinfo\fR
structure for the specific lwp as described above for the representative lwp
in the process's \fBpsinfo\fR file. The \fBlwpsinfo\fR file remains
accessible after an lwp becomes a zombie.
.SS "lwpusage"
.sp
.LP
This file contains the
.B prusage
structure for the specific lwp as
described above for the process's
.B usage
file.
.SS "gwindows"
.sp
.LP
This file exists only on SPARC based machines. If it is non-empty, it
contains a
.B gwindows_t
structure, defined in
.BR <sys/regset.h> ,
with
the values of those SPARC register windows that could not be stored on the
stack when the lwp stopped. Conditions under which register windows are not
stored on the stack are: the stack pointer refers to nonexistent process
memory or the stack pointer is improperly aligned. If the lwp is not stopped
or if there are no register windows that could not be stored on the stack,
the file is empty (the usual case).
.SS "xregs"
.sp
.LP
Extra state registers. The extra state register set is architecture
dependent; this file is empty if the system does not support extra state
registers. If the file is non-empty, it contains an architecture dependent
structure of type
.BR prxregset_t ,
defined in
.BR <procfs.h> ,
with the
values of the lwp's extra state registers. If the lwp is not stopped, all
register values are undefined. See also the
.B PCSXREG
control operation,
below.
.SS "asrs"
.sp
.LP
This file exists only for 64-bit SPARC V9 processes. It contains an
.B asrset_t
structure, defined in <\fBsys/regset.h\fR>, containing the
values of the lwp's platform-dependent ancillary state registers. If the lwp
is not stopped, all register values are undefined. See also the
.B PCSASRS
control operation, below.
.SS "templates"
.sp
.LP
A directory which contains references to the active templates for the lwp,
named by the contract type. Changes made to an active template descriptor do
not affect the original template which was activated, though they do affect
the active template. It is not possible to activate an active template
descriptor. See
.BR contract (4).
.SH CONTROL MESSAGES
.sp
.LP
Process state changes are effected through messages written to a process's
.B ctl
file or to an individual lwp's
.B lwpctl
file. All control
messages consist of a
.B long
that names the specific operation followed
by additional data containing the operand, if any.
.sp
.LP
Multiple control messages may be combined in a single
.BR write (2)
(or
.BR writev (2))
to a control file, but no partial writes are permitted.
That is, each control message, operation code plus operand, if any, must be
presented in its entirety to the
.BR write (2)
and not in pieces over
several system calls. If a control operation fails, no subsequent operations
contained in the same
.BR write (2)
are attempted.
.sp
.LP
Descriptions of the allowable control messages follow. In all cases,
writing a message to a control file for a process or lwp that has terminated
elicits the error
.BR ENOENT .
.SS "PCSTOP PCDSTOP PCWSTOP PCTWSTOP"
.sp
.LP
When applied to the process control file,
.B PCSTOP
directs all lwps to
stop and waits for them to stop,
.B PCDSTOP
directs all lwps to stop
without waiting for them to stop, and
.B PCWSTOP
simply waits for all
lwps to stop. When applied to an lwp control file,
.B PCSTOP
directs the
specific lwp to stop and waits until it has stopped,
.B PCDSTOP
directs
the specific lwp to stop without waiting for it to stop, and \fBPCWSTOP\fR
simply waits for the specific lwp to stop. When applied to an lwp control
file,
.B PCSTOP
and
.B PCWSTOP
complete when the lwp stops on an event
of interest, immediately if already so stopped; when applied to the process
control file, they complete when every lwp has stopped either on an event of
interest or on a
.B PR_SUSPENDED
stop.
.sp
.LP
.B PCTWSTOP
is identical to
.B PCWSTOP
except that it enables the
operation to time out, to avoid waiting forever for a process or lwp that
may never stop on an event of interest.
.B PCTWSTOP
takes a
.BR long
operand specifying a number of milliseconds; the wait will terminate
successfully after the specified number of milliseconds even if the process
or lwp has not stopped; a timeout value of zero makes the operation
identical to
.BR PCWSTOP .
.sp
.LP
An ``event of interest'' is either a
.B PR_REQUESTED
stop or a stop that
has been specified in the process's tracing flags (set by
.BR PCSTRACE ,
.BR PCSFAULT ,
.BR PCSENTRY ,
and
.BR PCSEXIT ).
.B PR_JOBCONTROL
and
.B PR_SUSPENDED
stops are specifically not events of interest. (An lwp
may stop twice due to a stop signal, first showing
.B PR_SIGNALLED
if the
signal is traced and again showing
.B PR_JOBCONTROL
if the lwp is set
running without clearing the signal.) If
.B PCSTOP
or
.B PCDSTOP
is
applied to an lwp that is stopped, but not on an event of interest, the stop
directive takes effect when the lwp is restarted by the competing mechanism.
At that time, the lwp enters a
.B PR_REQUESTED
stop before executing any
user-level code.
.sp
.LP
A write of a control message that blocks is interruptible by a signal so
that, for example, an
.BR alarm (2)
can be set to avoid waiting forever for
a process or lwp that may never stop on an event of interest. If
.B PCSTOP
is interrupted, the lwp stop directives remain in effect even
though the
.BR write (2)
returns an error. (Use of
.B PCTWSTOP
with a
non-zero timeout is recommended over
.B PCWSTOP
with an
.BR alarm (2).)
.sp
.LP
A system process (indicated by the
.B PR_ISSYS
flag) never executes at
user level, has no user-level address space visible through
.BR /proc ,
and
cannot be stopped. Applying one of these operations to a system process or
any of its lwps elicits the error
.BR EBUSY .
.SS "PCRUN"
.sp
.LP
Make an lwp runnable again after a stop. This operation takes a \fBlong\fR
operand containing zero or more of the following flags:
.sp
.ne 2
.mk
.na
.B PRCSIG
.ad
.RS 12n
.rt
clears the current signal, if any (see
.BR PCCSIG ).
.RE

.sp
.ne 2
.mk
.na
.B PRCFAULT
.ad
.RS 12n
.rt
clears the current fault, if any (see
.BR PCCFAULT ).
.RE

.sp
.ne 2
.mk
.na
.B PRSTEP
.ad
.RS 12n
.rt
directs the lwp to execute a single machine instruction. On completion of
the instruction, a trace trap occurs. If
.B FLTTRACE
is being traced, the
lwp stops; otherwise, it is sent
.BR SIGTRAP .
If
.B SIGTRAP
is being
traced and is not blocked, the lwp stops. When the lwp stops on an event of
interest, the single-step directive is cancelled, even if the stop occurs
before the instruction is executed. This operation requires hardware and
operating system support and may not be implemented on all processors. It is
implemented on SPARC and x86-based machines.
.RE

.sp
.ne 2
.mk
.na
.B PRSABORT
.ad
.RS 12n
.rt
is meaningful only if the lwp is in a
.B PR_SYSENTRY
stop or is marked
.BR PR_ASLEEP ;
it instructs the lwp to abort execution of the system call
(see
.B PCSENTRY
and
.BR PCSEXIT ).
.RE

.sp
.ne 2
.mk
.na
.B PRSTOP
.ad
.RS 12n
.rt
directs the lwp to stop again as soon as possible after resuming execution
(see
.BR PCDSTOP ).
In particular, if the lwp is stopped on
.B PR_SIGNALLED
or
.BR PR_FAULTED ,
the next stop will show
.BR PR_REQUESTED ,
no other stop will have intervened, and the lwp will not
have executed any user-level code.
.RE

.sp
.LP
When applied to an lwp control file,
.B PCRUN
clears any outstanding
directed-stop request and makes the specific lwp runnable. The operation
fails with
.B EBUSY
if the specific lwp is not stopped on an event of
interest or has not been directed to stop or if the agent lwp exists and
this is not the agent lwp  (see
.BR PCAGENT ).
.sp
.LP
When applied to the process control file, a representative lwp is chosen
for the operation as described for \fB/proc/\fIpid\fB/status\fR. The
operation fails with
.B EBUSY
if the representative lwp is not stopped on
an event of interest or has not been directed to stop or if the agent lwp
exists. If
.B PRSTEP
or
.B PRSTOP
was requested, the representative
lwp is made runnable and its outstanding directed-stop request is cleared;
otherwise all outstanding directed-stop requests are cleared and, if it was
stopped on an event of interest, the representative lwp is marked
.BR PR_REQUESTED .
If, as a consequence, all lwps are in the
.B PR_REQUESTED
or
.B PR_SUSPENDED
stop state, all lwps showing
.B PR_REQUESTED
are made runnable.
.SS "PCSTRACE"
.sp
.LP
Define a set of signals to be traced in the process. The receipt of one of
these signals by an lwp causes the lwp to stop. The set of signals is
defined using an operand
.B sigset_t
contained in the control message.
Receipt of
.B SIGKILL
cannot be traced; if specified, it is silently
ignored.
.sp
.LP
If a signal that is included in an lwp's held signal set (the signal mask)
is sent to the lwp, the signal is not received and does not cause a stop
until it is removed from the held signal set, either by the lwp itself or by
setting the held signal set with
.BR PCSHOLD .
.SS "PCCSIG"
.sp
.LP
The current signal, if any, is cleared from the specific or representative
lwp.
.SS "PCSSIG"
.sp
.LP
The current signal and its associated signal information for the specific
or representative lwp are set according to the contents of the operand
.B siginfo
structure (see
.BR <sys/siginfo.h> ).
If the specified signal
number is zero, the current signal is cleared. The semantics of this
operation are different from those of
.BR kill (2)
in that the signal is
delivered to the lwp immediately after execution is resumed (even if it is
being blocked) and an additional
.B PR_SIGNALLED
stop does not intervene
even if the signal is traced. Setting the current signal to \fBSIGKILL\fR
terminates the process immediately.
.SS "PCKILL"
.sp
.LP
If applied to the process control file, a signal is sent to the process
with semantics identical to those of
.BR kill (2).
If applied to an lwp
control file, a directed signal is sent to the specific lwp. The signal is
named in a
.B long
operand contained in the message. Sending
.B SIGKILL
terminates the process immediately.
.SS "PCUNKILL"
.sp
.LP
A signal is deleted, that is, it is removed from the set of pending
signals. If applied to the process control file, the signal is deleted from
the process's pending signals. If applied to an lwp control file, the signal
is deleted from the lwp's pending signals. The current signal (if any) is
unaffected. The signal is named in a
.B long
operand in the control
message. It is an error (\fBEINVAL\fR) to attempt to delete
.BR SIGKILL .
.SS "PCSHOLD"
.sp
.LP
Set the set of held signals for the specific or representative lwp (signals
whose delivery will be blocked if sent to the lwp). The set of signals is
specified with a
.B sigset_t
operand.
.B SIGKILL
and
.BR SIGSTOP
cannot be held; if specified, they are silently ignored.
.SS "PCSFAULT"
.sp
.LP
Define a set of hardware faults to be traced in the process. On incurring
one of these faults, an lwp stops. The set is defined via the operand
.B fltset_t
structure. Fault names are defined in
.B <sys/fault.h>
and
include the following. Some of these may not occur on all processors; there
may be processor-specific faults in addition to these.
.sp
.ne 2
.mk
.na
.B FLTILL
.ad
.RS 13n
.rt
illegal instruction
.RE

.sp
.ne 2
.mk
.na
.B FLTPRIV
.ad
.RS 13n
.rt
privileged instruction
.RE

.sp
.ne 2
.mk
.na
.B FLTBPT
.ad
.RS 13n
.rt
breakpoint trap
.RE

.sp
.ne 2
.mk
.na
.B FLTTRACE
.ad
.RS 13n
.rt
trace trap (single-step)
.RE

.sp
.ne 2
.mk
.na
.B FLTWATCH
.ad
.RS 13n
.rt
watchpoint trap
.RE

.sp
.ne 2
.mk
.na
.B FLTACCESS
.ad
.RS 13n
.rt
memory access fault (bus error)
.RE

.sp
.ne 2
.mk
.na
.B FLTBOUNDS
.ad
.RS 13n
.rt
memory bounds violation
.RE

.sp
.ne 2
.mk
.na
.B FLTIOVF
.ad
.RS 13n
.rt
integer overflow
.RE

.sp
.ne 2
.mk
.na
.B FLTIZDIV
.ad
.RS 13n
.rt
integer zero divide
.RE

.sp
.ne 2
.mk
.na
.B FLTFPE
.ad
.RS 13n
.rt
floating-point exception
.RE

.sp
.ne 2
.mk
.na
.B FLTSTACK
.ad
.RS 13n
.rt
unrecoverable stack fault
.RE

.sp
.ne 2
.mk
.na
.B FLTPAGE
.ad
.RS 13n
.rt
recoverable page fault
.RE

.sp
.LP
When not traced, a fault normally results in the posting of a signal to the
lwp that incurred the fault. If an lwp stops on a fault, the signal is
posted to the lwp when execution is resumed unless the fault is cleared by
.B PCCFAULT
or by the
.B PRCFAULT
option of
.BR PCRUN .
.B FLTPAGE
is an exception; no signal is posted. The
.B pr_info
field in the
.B lwpstatus
structure identifies the signal to be sent and contains
machine-specific information about the fault.
.SS "PCCFAULT"
.sp
.LP
The current fault, if any, is cleared; the associated signal will not be
sent to the specific or representative lwp.
.SS "PCSENTRY PCSEXIT"
.sp
.LP
These control operations instruct the process's lwps to stop on entry to or
exit from specified system calls. The set of system calls to be traced is
defined via an operand
.B sysset_t
structure.
.sp
.LP
When entry to a system call is being traced, an lwp stops after having
begun the call to the system but before the system call arguments have been
fetched from the lwp. When exit from a system call is being traced, an lwp
stops on completion of the system call just prior to checking for signals
and returning to user level. At this point, all return values have been
stored into the lwp's registers.
.sp
.LP
If an lwp is stopped on entry to a system call (\fBPR_SYSENTRY\fR) or when
sleeping in an interruptible system call (\fBPR_ASLEEP\fR is set), it may be
instructed to go directly to system call exit by specifying the
.B PRSABORT
flag in a
.B PCRUN
control message. Unless exit from the
system call is being traced, the lwp returns to user level showing
.BR EINTR .
.SS "PCWATCH"
.sp
.LP
Set or clear a watched area in the controlled process from a
.BR prwatch
structure operand:
.sp
.in +2
.nf
typedef struct prwatch {
    uintptr_t pr_vaddr;  /* virtual address of watched area */
    size_t pr_size;      /* size of watched area in bytes */
    int pr_wflags;       /* watch type flags */
} prwatch_t;
.fi
.in -2

.sp
.LP
.B pr_vaddr
specifies the virtual address of an area of memory to be
watched in the controlled process.
.B pr_size
specifies the size of the
area, in bytes.
.B pr_wflags
specifies the type of memory access to be
monitored as a bit-mask of the following flags:
.sp
.ne 2
.mk
.na
.B WA_READ
.ad
.RS 16n
.rt
read access
.RE

.sp
.ne 2
.mk
.na
.B WA_WRITE
.ad
.RS 16n
.rt
write access
.RE

.sp
.ne 2
.mk
.na
.B WA_EXEC
.ad
.RS 16n
.rt
execution access
.RE

.sp
.ne 2
.mk
.na
.B WA_TRAPAFTER
.ad
.RS 16n
.rt
trap after the instruction completes
.RE

.sp
.LP
If
.B pr_wflags
is non-empty, a watched area is established for the
virtual address range specified by
.B pr_vaddr
and
.BR pr_size .
If
.B pr_wflags
is empty, any previously-established watched area starting
at the specified virtual address is cleared;
.B pr_size
is ignored.
.sp
.LP
A watchpoint is triggered when an lwp in the traced process makes a memory
reference that covers at least one byte of a watched area and the memory
reference is as specified in
.BR pr_wflags .
When an lwp triggers a
watchpoint, it incurs a watchpoint trap. If
.B FLTWATCH
is being traced,
the lwp stops; otherwise, it is sent a
.B SIGTRAP
signal; if
.B SIGTRAP
is being traced and is not blocked, the lwp stops.
.sp
.LP
The watchpoint trap occurs before the instruction completes unless
.B WA_TRAPAFTER
was specified, in which case it occurs after the
instruction completes. If it occurs before completion, the memory is not
modified. If it occurs after completion, the memory is modified (if the
access is a write access).
.sp
.LP
Physical i/o is an exception for watchpoint traps. In this instance, there
is no guarantee that memory before the watched area has already been
modified (or in the case of
.BR WA_TRAPAFTER ,
that the memory following
the watched area has not been modified) when the watchpoint trap occurs and
the lwp stops.
.sp
.LP
.B pr_info
in the
.B lwpstatus
structure contains information
pertinent to the watchpoint trap. In particular, the
.B si_addr
field
contains the virtual address of the memory reference that triggered the
watchpoint, and the
.B si_code
field contains one of
.BR TRAP_RWATCH ,
.BR TRAP_WWATCH ,
or
.BR TRAP_XWATCH ,
indicating read, write, or execute
access, respectively. The
.B si_trapafter
field is zero unless
.B WA_TRAPAFTER
is in effect for this watched area; non-zero indicates
that the current instruction is not the instruction that incurred the
watchpoint trap. The
.B si_pc
field contains the virtual address of the
instruction that incurred the trap.
.sp
.LP
A watchpoint trap may be triggered while executing a system call that makes
reference to the traced process's memory. The lwp that is executing the
system call incurs the watchpoint trap while still in the system call. If it
stops as a result, the
.B lwpstatus
structure contains the system call
number and its arguments. If the lwp does not stop, or if it is set running
again without clearing the signal or fault, the system call fails with
.BR EFAULT .
If
.B WA_TRAPAFTER
was specified, the memory reference will
have completed and the memory will have been modified (if the access was a
write access) when the watchpoint trap occurs.
.sp
.LP
If more than one of
.BR WA_READ ,
.BR WA_WRITE ,
and
.B WA_EXEC
is
specified for a watched area, and a single instruction incurs more than one
of the specified types, only one is reported when the watchpoint trap
occurs. The precedence is
.BR WA_EXEC ,
.BR WA_READ ,
.B WA_WRITE
(\fBWA_EXEC\fR and \fBWA_READ\fR take precedence over
.BR WA_WRITE ),
unless
.B WA_TRAPAFTER
was specified, in which case it is
.BR WA_WRITE ,
.BR WA_READ ,
.B WA_EXEC
(\fBWA_WRITE\fR takes precedence).
.sp
.LP
.B PCWATCH
fails with
.B EINVAL
if an attempt is made to specify
overlapping watched areas or if
.B pr_wflags
contains flags other than
those specified above. It fails with
.B ENOMEM
if an attempt is made to
establish more watched areas than the system can support (the system can
support thousands).
.sp
.LP
The child of a
.BR vfork (2)
borrows the parent's address space. When a
.BR vfork (2)
is executed by a traced process, all watched areas
established for the parent are suspended until the child terminates or
performs an
.BR exec (2).
Any watched areas established independently in
the child are cancelled when the parent resumes after the child's
termination or
.BR exec (2).
.B PCWATCH
fails with
.B EBUSY
if
applied to the parent of a
.BR vfork (2)
before the child has terminated or
performed an
.BR exec (2).
The
.B PR_VFORKP
flag is set in the
.B pstatus
structure for such a parent process.
.sp
.LP
Certain accesses of the traced process's address space by the operating
system are immune to watchpoints. The initial construction of a signal stack
frame when a signal is delivered to an lwp will not trigger a watchpoint
trap even if the new frame covers watched areas of the stack. Once the
signal handler is entered, watchpoint traps occur normally. On SPARC based
machines, register window overflow and underflow will not trigger watchpoint
traps, even if the register window save areas cover watched areas of the
stack.
.sp
.LP
Watched areas are not inherited by child processes, even if the traced
process's inherit-on-fork mode,
.BR PR_FORK ,
is set (see
.BR PCSET ,
below). All watched areas are cancelled when the traced process performs a
successful
.BR exec (2).
.SS "PCSET PCUNSET"
.sp
.LP
.B PCSET
sets one or more modes of operation for the traced process.
.B PCUNSET
unsets these modes. The modes to be set or unset are specified
by flags in an operand
.B long
in the control message:
.sp
.ne 2
.mk
.na
.B PR_FORK
.ad
.RS 13n
.rt
(inherit-on-fork): When set, the process's tracing flags and its
inherit-on-fork mode are inherited by the child of a
.BR fork (2),
.BR fork1 (2),
or
.BR vfork (2).
When unset, child processes start with
all tracing flags cleared.
.RE

.sp
.ne 2
.mk
.na
.B PR_RLC
.ad
.RS 13n
.rt
(run-on-last-close): When set and the last writable
.B /proc
file
descriptor referring to the traced process or any of its lwps is closed, all
of the process's tracing flags and watched areas are cleared, any
outstanding stop directives are canceled, and if any lwps are stopped on
events of interest, they are set running as though
.B PCRUN
had been
applied to them. When unset, the process's tracing flags and watched areas
are retained and lwps are not set running on last close.
.RE

.sp
.ne 2
.mk
.na
.B PR_KLC
.ad
.RS 13n
.rt
(kill-on-last-close): When set and the last writable
.B /proc
file
descriptor referring to the traced process or any of its lwps is closed, the
process is terminated with
.BR SIGKILL .
.RE

.sp
.ne 2
.mk
.na
.B PR_ASYNC
.ad
.RS 13n
.rt
(asynchronous-stop): When set, a stop on an event of interest by one lwp
does not directly affect any other lwp in the process. When unset and an lwp
stops on an event of interest other than
.BR PR_REQUESTED ,
all other lwps
in the process are directed to stop.
.RE

.sp
.ne 2
.mk
.na
.B PR_MSACCT
.ad
.RS 13n
.rt
(microstate accounting): Microstate accounting is now continuously enabled.
This flag is deprecated and no longer has any effect upon microstate
accounting. Applications may toggle this flag; however, microstate
accounting will remain enabled regardless.
.RE

.sp
.ne 2
.mk
.na
.B PR_MSFORK
.ad
.RS 13n
.rt
(inherit microstate accounting): All processes now inherit microstate
accounting, as it is continuously enabled. This flag has been deprecated and
its use no longer has any effect upon the behavior of microstate
accounting.
.RE

.sp
.ne 2
.mk
.na
.B PR_BPTADJ
.ad
.RS 13n
.rt
(breakpoint trap pc adjustment): On x86-based machines, a breakpoint trap
leaves the program counter
.RB "(the " EIP )
referring to the breakpointed
instruction plus one byte. When
.B PR_BPTADJ
is set, the system will
adjust the program counter back to the location of the breakpointed
instruction when the lwp stops on a breakpoint. This flag has no effect on
SPARC based machines, where breakpoint traps leave the program counter
referring to the breakpointed instruction.
.RE

.sp
.ne 2
.mk
.na
.B PR_PTRACE
.ad
.RS 13n
.rt
(ptrace-compatibility): When set, a stop on an event of interest by the
traced process is reported to the parent of the traced process by
.BR wait (3C),
.B SIGTRAP
is sent to the traced process when it executes
a successful
.BR exec (2),
setuid/setgid flags are not honored for execs
performed by the traced process, any exec of an object file that the traced
process cannot read fails, and the process dies when its parent dies. This
mode is deprecated; it is provided only to allow
.BR ptrace (3C)
to be
implemented as a library function using
.BR /proc .
.RE

.sp
.LP
It is an error (\fBEINVAL\fR) to specify flags other than those described
above or to apply these operations to a system process. The current modes
are reported in the
.B pr_flags
field of
\fB/proc/\fIpid\fB/status\fR and
\fB/proc/\fIpid\fB/lwp/\fIlwp\fB/lwpstatus\fR.
.SS "PCSREG"
.sp
.LP
Set the general registers for the specific or representative lwp according
to the operand
.B prgregset_t
structure.
.sp
.LP
On SPARC based systems, only the condition-code bits of the
processor-status register (R_PSR) of SPARC V8 (32-bit) processes can be
modified by
.BR PCSREG .
Other privileged registers cannot be modified at
all.
.sp
.LP
On x86-based systems, only certain bits of the flags register (EFL) can be
modified by
.BR PCSREG :
these include the condition codes, direction-bit,
and overflow-bit.
.sp
.LP
.B PCSREG
fails with
.B EBUSY
if the lwp is not stopped on an event
of interest.
.SS "PCSVADDR"
.sp
.LP
Set the address at which execution will resume for the specific or
representative lwp from the operand
.BR long .
On SPARC based systems, both
%pc and %npc are set, with %npc set to the instruction following the virtual
address. On x86-based systems, only %eip is set.
.B PCSVADDR
fails with
.B EBUSY
if the lwp is not stopped on an event of interest.
.SS "PCSFPREG"
.sp
.LP
Set the floating-point registers for the specific or representative lwp
according to the operand
.B prfpregset_t
structure. An error
(\fBEINVAL\fR) is returned if the system does not support floating-point
operations (no floating-point hardware and the system does not emulate
floating-point machine instructions).
.B PCSFPREG
fails with
.BR EBUSY
if the lwp is not stopped on an event of interest.
.SS "PCSXREG"
.sp
.LP
Set the extra state registers for the specific or representative lwp
according to the architecture-dependent operand
.B prxregset_t
structure.
An error (\fBEINVAL\fR) is returned if the system does not support extra
state registers.
.B PCSXREG
fails with
.B EBUSY
if the lwp is not
stopped on an event of interest.
.SS "PCSASRS"
.sp
.LP
Set the ancillary state registers for the specific or representative lwp
according to the SPARC V9 platform-dependent operand \fBasrset_t\fR
structure. An error (\fBEINVAL\fR) is returned if either the target process
or the controlling process is not a 64-bit SPARC V9 process. Most of the
ancillary state registers are privileged registers that cannot be modified.
Only those that can be modified are set; all others are silently ignored.
.B PCSASRS
fails with
.B EBUSY
if the lwp is not stopped on an event
of interest.
.SS "PCAGENT"
.sp
.LP
Create an agent lwp in the controlled process with register values from the
operand
.B prgregset_t
structure (see
.BR PCSREG ,
above). The agent lwp
is created in the stopped state showing
.B PR_REQUESTED
and with its held
signal set (the signal mask) having all signals except
.B SIGKILL
and
.B SIGSTOP
blocked.
.sp
.LP
The
.B PCAGENT
operation fails with
.B EBUSY
unless the process is
fully stopped via
.BR /proc ,
that is, unless all of the lwps in the
process are stopped either on events of interest or on
.BR PR_SUSPENDED ,
or are stopped on
.B PR_JOBCONTROL
and have been directed to stop via
.BR PCDSTOP .
It fails with
.B EBUSY
if an agent lwp already exists. It
fails with
.B ENOMEM
if system resources for creating new lwps have been
exhausted.
.sp
.LP
Any
.B PCRUN
operation applied to the process control file or to the
control file of an lwp other than the agent lwp fails with
.B EBUSY
as
long as the agent lwp exists. The agent lwp must be caused to terminate by
executing the
.B SYS_lwp_exit
system call trap before the process can be
restarted.
.sp
.LP
Once the agent lwp is created, its lwp-ID can be found by reading the
process status file. To facilitate opening the agent lwp's control and
status files, the directory name \fB/propc/\fIpid\fB/lwp/agent\fR is
accepted for lookup operations as an invisible alias for
\fB/proc/\fIpid\fB/lwp/\fIlwpid, lwpid\fR being the lwp-ID of
the agent lwp (invisible in the sense that the name ``agent'' does not
appear in a directory listing of \fB/proc/\fIpid\fB/lwp\fR obtained
from
.BR ls (1),
.BR getdents (2),
or
.BR readdir (3C)).
.sp
.LP
The purpose of the agent lwp is to perform operations in the controlled
process on behalf of the controlling process: to gather information not
directly available via
.B /proc
files, or in general to make the process
change state in ways not directly available via
.B /proc
control
operations. To make use of an agent lwp, the controlling process must be
capable of making it execute system calls (specifically, the
.B SYS_lwp_exit
system call trap). The register values given to the agent
lwp on creation are typically the registers of the representative lwp, so
that the agent lwp can use its stack.
.sp
.LP
The agent lwp is not allowed to execute any variation of the \fBSYS_fork\fR
or
.B SYS_exec
.RB "system call traps. Attempts to do so yield" " ENOTSUP"
to the agent lwp.
.sp
.LP
Symbolic constants for system call trap numbers like
.B SYS_lwp_exit
and
.B SYS_lwp_create
can be found in the header file
<\fBsys/syscall.h\fR>.
.SS "PCREAD PCWRITE"
.sp
.LP
.RB "Read or write the target process's address space via a" " priovec"
structure operand:
.sp
.in +2
.nf
typedef struct priovec {
    void *pio_base;      /* buffer in controlling process */
    size_t pio_len;      /* size of read/write request in bytes */
    off_t pio_offset;    /* virtual address in target process */
} priovec_t;
.fi
.in -2

.sp
.LP
These operations have the same effect as
.BR pread (2)
and
.BR pwrite (2),
respectively, of the target process's address space file.
The difference is that more than one
.B PCREAD
or
.B PCWRITE
control
operation can be written to the control file at once, and they can be
interspersed with other control operations in a single write to the control
file. This is useful, for example, when planting many breakpoint
instructions in the process's address space, or when stepping over a
breakpointed instruction. Unlike
.BR pread (2)
and
.BR pwrite (2),
no
provision is made for partial reads or writes; if the operation cannot be
performed completely, it fails with
.BR EIO .
.SS "PCNICE"
.sp
.LP
The traced process's
.BR nice (2)
value is incremented by the amount in
the operand
.BR long .
Only a process with the {\fBPRIV_PROC_PRIOCNTL\fR}
privilege asserted in its effective set can better a process's priority in
this way, but any user may lower the priority. This operation is not
meaningful for all scheduling classes.
.SS "PCSCRED"
.sp
.LP
Set the target process credentials to the values contained in the
\fBprcred_t\fR structure operand (see \fB/proc/\fIpid\fB/cred\fR). The
effective, real, and saved user-IDs and group-IDs of the target process are
set. The target process's supplementary groups are not changed; the
.B pr_ngroups
and
.B pr_groups
members of the structure operand are
ignored. Only the privileged processes can perform this operation; for all
others it fails with
.BR EPERM .
.SS "PCSCREDX"
.sp
.LP
Operates like
.B PCSCRED
but also sets the supplementary groups; the
length of the data written with this control operation should be "sizeof
(\fBprcred_t\fR) + sizeof (\fBgid_t)\fR * (#groups - 1)".
.SS "PCSPRIV"
.sp
.LP
Set the target process privilege to the values contained in the
.B prpriv_t
operand (see
.BR /proc/pid/priv ).
The effective, permitted,
inheritable, and limit sets are all changed. Privilege flags can also be
set. The process is made privilege aware unless it can relinquish privilege
awareness. See
.BR privileges (5).
.sp
.LP
The limit set of the target process cannot be grown. The other privilege
sets must be subsets of the intersection of the effective set of the calling
process with the new limit set of the target process or subsets of the
original values of the sets in the target process.
.sp
.LP
If any of the above restrictions are not met,
.B EPERM
is returned. If
the structure written is improperly formatted,
.B EINVAL
is returned.
.SH PROGRAMMING NOTES
.sp
.LP
For security reasons, except for the
.BR psinfo ,
.BR usage ,
.BR lpsinfo ,
.BR lusage ,
.BR lwpsinfo ,
and
.B lwpusage
files, which
are world-readable, and except for privileged processes, an open of a
.B /proc
file fails unless both the user-ID and group-ID of the caller
match those of the traced process and the process's object file is readable
by the caller. The effective set of the caller is a superset of both the
inheritable and the permitted set of the target process. The limit set of
the caller is a superset of the limit set of the target process. Except for
the world-readable files just mentioned, files corresponding to setuid and
setgid processes can be opened only by the appropriately privileged
process.
.sp
.LP
A process that is missing the basic privilege {\fBPRIV_PROC_INFO\fR} cannot
see any processes under
.B /proc
that it cannot send a signal to.
.sp
.LP
A process that has {\fBPRIV_PROC_OWNER\fR} asserted in its effective set
can open any file for reading. To manipulate or control a process, the
controlling process must have at least as many privileges in its effective
set as the target process has in its effective, inheritable, and permitted
sets. The limit set of the controlling process must be a superset of the
limit set of the target process. Additional restrictions apply if any of the
uids of the target process are 0. See
.BR privileges (5).
.sp
.LP
Even if held by a privileged process, an open process or lwp file
descriptor (other than file descriptors for the world-readable files)
becomes invalid if the traced process performs an
.BR exec (2)
of a
setuid/setgid object file or an object file that the traced process cannot
read. Any operation performed on an invalid file descriptor, except
.BR close (2),
fails with
.BR EAGAIN .
In this situation, if any tracing
flags are set and the process or any lwp file descriptor is open for
writing, the process will have been directed to stop and its
run-on-last-close flag will have been set (see
.BR PCSET ).
This enables a
controlling process (if it has permission) to reopen the
.B /proc
files
to get new valid file descriptors, close the invalid file descriptors, unset
the run-on-last-close flag (if desired), and proceed. Just closing the
invalid file descriptors causes the traced process to resume execution with
all tracing flags cleared. Any process not currently open for writing via
.BR /proc ,
but that has left-over tracing flags from a previous open, and
that executes a setuid/setgid or unreadable object file, will not be stopped
but will have all its tracing flags cleared.
.sp
.LP
To wait for one or more of a set of processes or lwps to stop or terminate,
.B /proc
file descriptors (other than those obtained by opening the
.B cwd
or
.B root
directories or by opening files in the
.B fd
or
.B object
directories) can be used in a
.BR poll (2)
system call. When
requested and returned, either of the polling events
.B POLLPRI
or
.B POLLWRNORM
indicates that the process or lwp stopped on an event of
interest. Although they cannot be requested, the polling events
.BR POLLHUP ,
.BR POLLERR ,
and
.B POLLNVAL
may be returned.
.B POLLHUP
indicates that the process or lwp has terminated.
.B POLLERR
indicates that the file descriptor has become invalid.
.B POLLNVAL
is returned immediately if
.B POLLPRI
or
.BR POLLWRNORM
is requested on a file descriptor referring to a system process (see
.BR PCSTOP ).
The requested events may be empty to wait simply for
termination.
.SH FILES
.sp
.ne 2
.mk
.na
.B /proc
.ad
.sp .6
.RS 4n
directory (list of processes)
.RE

.sp
.ne 2
.mk
.na
\fB/proc/\fIpid\fR
.ad
.sp .6
.RS 4n
specific process directory
.RE

.sp
.ne 2
.mk
.na
.B /proc/self
.ad
.sp .6
.RS 4n
alias for a process's own directory
.RE

.sp
.ne 2
.mk
.na
\fB/proc/\fIpid\fR/as\fR
.ad
.sp .6
.RS 4n
address space file
.RE

.sp
.ne 2
.mk
.na
\fB/proc/\fIpid\fR/ctl\fR
.ad
.sp .6
.RS 4n
process control file
.RE

.sp
.ne 2
.mk
.na
\fB/proc/\fIpid\fR/status\fR
.ad
.sp .6
.RS 4n
process status
.RE

.sp
.ne 2
.mk
.na
\fB/proc/\fIpid\fR/lstatus\fR
.ad
.sp .6
.RS 4n
array of lwp status structs
.RE

.sp
.ne 2
.mk
.na
\fB/proc/\fIpid\fR/psinfo\fR
.ad
.sp .6
.RS 4n
process
.BR ps (1)
info
.RE

.sp
.ne 2
.mk
.na
\fB/proc/\fIpid\fR/lpsinfo\fR
.ad
.sp .6
.RS 4n
array of lwp
.BR ps (1)
info structs
.RE

.sp
.ne 2
.mk
.na
\fB/proc/\fIpid\fR/map\fR
.ad
.sp .6
.RS 4n
address space map
.RE

.sp
.ne 2
.mk
.na
\fB/proc/\fIpid\fR/xmap\fR
.ad
.sp .6
.RS 4n
extended address space map
.RE

.sp
.ne 2
.mk
.na
\fB/proc/\fIpid\fR/rmap\fR
.ad
.sp .6
.RS 4n
reserved address map
.RE

.sp
.ne 2
.mk
.na
\fB/proc/\fIpid\fR/cred\fR
.ad
.sp .6
.RS 4n
process credentials
.RE

.sp
.ne 2
.mk
.na
\fB/proc/\fIpid\fR/priv\fR
.ad
.sp .6
.RS 4n
process privileges
.RE

.sp
.ne 2
.mk
.na
\fB/proc/\fIpid\fR/sigact\fR
.ad
.sp .6
.RS 4n
process signal actions
.RE

.sp
.ne 2
.mk
.na
\fB/proc/\fIpid\fR/auxv\fR
.ad
.sp .6
.RS 4n
process aux vector
.RE

.sp
.ne 2
.mk
.na
\fB/proc/\fIpid\fR/ldt\fR
.ad
.sp .6
.RS 4n
process
.B LDT
(x86 only)
.RE

.sp
.ne 2
.mk
.na
\fB/proc/\fIpid\fR/usage\fR
.ad
.sp .6
.RS 4n
process usage
.RE

.sp
.ne 2
.mk
.na
\fB/proc/\fIpid\fR/lusage\fR
.ad
.sp .6
.RS 4n
array of lwp usage structs
.RE

.sp
.ne 2
.mk
.na
\fB/proc/\fIpid\fR/path\fR
.ad
.sp .6
.RS 4n
symbolic links to process open files
.RE

.sp
.ne 2
.mk
.na
\fB/proc/\fIpid\fR/pagedata\fR
.ad
.sp .6
.RS 4n
process page data
.RE

.sp
.ne 2
.mk
.na
\fB/proc/\fIpid\fR/watch\fR
.ad
.sp .6
.RS 4n
active watchpoints
.RE

.sp
.ne 2
.mk
.na
\fB/proc/\fIpid\fR/cwd\fR
.ad
.sp .6
.RS 4n
alias for the current working directory
.RE

.sp
.ne 2
.mk
.na
\fB/proc/\fIpid\fR/root\fR
.ad
.sp .6
.RS 4n
alias for the root directory
.RE

.sp
.ne 2
.mk
.na
\fB/proc/\fIpid\fR/fd\fR
.ad
.sp .6
.RS 4n
directory (list of open files)
.RE

.sp
.ne 2
.mk
.na
\fB/proc/\fIpid\fR/fd/*\fR
.ad
.sp .6
.RS 4n
aliases for process's open files
.RE

.sp
.ne 2
.mk
.na
\fB/proc/\fIpid\fR/object\fR
.ad
.sp .6
.RS 4n
directory (list of mapped files)
.RE

.sp
.ne 2
.mk
.na
\fB/proc/\fIpid\fR/object/a.out\fR
.ad
.sp .6
.RS 4n
alias for process's executable file
.RE

.sp
.ne 2
.mk
.na
\fB/proc/\fIpid\fR/object/*\fR
.ad
.sp .6
.RS 4n
aliases for other mapped files
.RE

.sp
.ne 2
.mk
.na
\fB/proc/\fIpid\fR/lwp\fR
.ad
.sp .6
.RS 4n
directory (list of lwps)
.RE

.sp
.ne 2
.mk
.na
\fB/proc/\fIpid\fR/lwp/\fIlwpid\fR
.ad
.sp .6
.RS 4n
specific lwp directory
.RE

.sp
.ne 2
.mk
.na
\fB/proc/\fIpid\fR/lwp/agent\fR
.ad
.sp .6
.RS 4n
alias for the agent lwp directory
.RE

.sp
.ne 2
.mk
.na
\fB/proc/\fIpid\fR/lwp/\fIlwpid\fR/lwpctl\fR
.ad
.sp .6
.RS 4n
lwp control file
.RE

.sp
.ne 2
.mk
.na
\fB/proc/\fIpid\fR/lwp/\fIlwpid\fR/lwpstatus\fR
.ad
.sp .6
.RS 4n
lwp status
.RE

.sp
.ne 2
.mk
.na
\fB/proc/\fIpid\fR/lwp/\fIlwpid\fR/lwpsinfo\fR
.ad
.sp .6
.RS 4n
lwp
.BR ps (1)
info
.RE

.sp
.ne 2
.mk
.na
\fB/proc/\fIpid\fR/lwp/\fIlwpid\fR/lwpusage\fR
.ad
.sp .6
.RS 4n
lwp usage
.RE

.sp
.ne 2
.mk
.na
\fB/proc/\fIpid\fR/lwp/\fIlwpid\fR/gwindows\fR
.ad
.sp .6
.RS 4n
register windows (SPARC only)
.RE

.sp
.ne 2
.mk
.na
\fB/proc/\fIpid\fR/lwp/\fIlwpid\fR/xregs\fR
.ad
.sp .6
.RS 4n
extra state registers
.RE

.sp
.ne 2
.mk
.na
\fB/proc/\fIpid\fR/lwp/\fIlwpid\fR/asrs\fR
.ad
.sp .6
.RS 4n
ancillary state registers (SPARC V9 only)
.RE

.SH SEE ALSO
.sp
.LP
.BR ls (1),
.BR ps (1),
.BR chroot (1M),
.BR alarm (2),
.BR brk (2),
.BR chdir (2),
.BR chroot (2),
.BR close (2),
.BR creat (2),
.BR dup (2),
.BR exec (2),
.BR fcntl (2),
.BR fork (2),
.BR fork1 (2),
.BR fstat (2),
.BR getdents (2),
.BR getustack (2),
.BR kill (2),
.BR lseek (2),
.BR mmap (2),
.BR nice (2),
.BR open (2),
.BR poll (2),
.BR pread (2),
.BR ptrace (3C),
.BR pwrite (2),
.BR read (2),
.BR readlink (2),
.BR readv (2),
.BR shmget (2),
.BR sigaction (2),
.BR sigaltstack (2),
.BR vfork (2),
.BR write (2),
.BR writev (2),
.BR _stack_grow (3C),
.BR readdir (3C),
.BR pthread_create (3C),
.BR pthread_join (3C),
.BR siginfo.h (3HEAD),
.BR signal.h (3HEAD),
.BR thr_create (3C),
.BR thr_join (3C),
.BR types32.h (3HEAD),
.BR ucontext.h (3HEAD),
.BR wait (3C),
.BR contract (4),
.BR process (4),
.BR lfcompile (5),
.BR privileges (5)
.SH DIAGNOSTICS
.sp
.LP
Errors that can occur in addition to the errors normally associated with
file system access:
.sp
.ne 2
.mk
.na
.B E2BIG
.ad
.RS 13n
.rt
Data to be returned in a
.BR read (2)
of the page data file exceeds the
size of the read buffer provided by the caller.
.RE

.sp
.ne 2
.mk
.na
.B EACCES
.ad
.RS 13n
.rt
An attempt was made to examine a process that ran under a different uid
than the controlling process and {\fBPRIV_PROC_OWNER\fR} was not asserted in
the effective set.
.RE

.sp
.ne 2
.mk
.na
.B EAGAIN
.ad
.RS 13n
.rt
The traced process has performed an
.BR exec (2)
of a setuid/setgid object
file or of an object file that it cannot read; all further operations on the
process or lwp file descriptor (except
.BR close (2))
elicit this error.
.RE

.sp
.ne 2
.mk
.na
.B EBUSY
.ad
.RS 13n
.rt
.BR PCSTOP ,
.BR PCDSTOP ,
.BR PCWSTOP ,
or
.B PCTWSTOP
was applied
to a system process; an exclusive
.BR open (2)
was attempted on a
.B /proc
file for a process already open for writing;
.BR PCRUN ,
.BR PCSREG ,
.BR PCSVADDR ,
.BR PCSFPREG ,
or
.B PCSXREG
was applied
to a process or lwp not stopped on an event of interest; an attempt was made
to mount
.B /proc
when it was already mounted;
.B PCAGENT
was applied
to a process that was not fully stopped or that already had an agent lwp.
.RE

.sp
.ne 2
.mk
.na
.B EINVAL
.ad
.RS 13n
.rt
In general, this means that some invalid argument was supplied to a system
call. A non-exhaustive list of conditions eliciting this error includes: a
control message operation code is undefined; an out-of-range signal number
was specified with
.BR PCSSIG ,
.BR PCKILL ,
or
.BR PCUNKILL ;
.B SIGKILL
was specified with
.BR PCUNKILL ;
.B PCSFPREG
was applied
on a system that does not support floating-point operations; \fBPCSXREG\fR
was applied on a system that does not support extra state registers.
.RE

.sp
.ne 2
.mk
.na
.B EINTR
.ad
.RS 13n
.rt
A signal was received by the controlling process while waiting for the
traced process or lwp to stop via
.BR PCSTOP ,
.BR PCWSTOP ,
or
.BR PCTWSTOP .
.RE

.sp
.ne 2
.mk
.na
.B EIO
.ad
.RS 13n
.rt
A
.BR write (2)
was attempted at an illegal address in the traced
process.
.RE

.sp
.ne 2
.mk
.na
.B ENOENT
.ad
.RS 13n
.rt
The traced process or lwp has terminated after being opened. The basic
privilege {\fBPRIV_PROC_INFO\fR} is not asserted in the effective set of the
calling process and the calling process cannot send a signal to the target
process.
.RE

.sp
.ne 2
.mk
.na
.B ENOMEM
.ad
.RS 13n
.rt
The system-imposed limit on the number of page data file descriptors was
reached on an open of \fB/proc/\fIpid\fB/pagedata\fR; an attempt was
made with
.B PCWATCH
to establish more watched areas than the system can
support; the
.B PCAGENT
operation was issued when the system was out of
resources for creating lwps.
.RE

.sp
.ne 2
.mk
.na
.B ENOSYS
.ad
.RS 13n
.rt
An attempt was made to perform an unsupported operation (such as
.BR creat (2),
.BR link (2),
or
.BR unlink (2))
on an entry in
.BR /proc .
.RE

.sp
.ne 2
.mk
.na
.B EOVERFLOW
.ad
.RS 13n
.rt
A 32-bit controlling process attempted to read or write the
.B as
file
or attempted to read the
.BR map ,
.BR rmap ,
or
.B pagedata
file of a
64-bit target process. A 32-bit controlling process attempted to apply one
of the control operations
.BR PCSREG ,
.BR PCSXREG ,
.BR PCSVADDR ,
.BR PCWATCH ,
.BR PCAGENT ,
.BR PCREAD ,
.B PCWRITE
to a 64-bit target
process.
.RE

.sp
.ne 2
.mk
.na
.B EPERM
.ad
.RS 13n
.rt
The process that issued the
.B PCSCRED
or
.B PCSCREDX
operation did
not have the {\fBPRIV_PROC_SETID\fR} privilege asserted in its effective
set, or the process that issued the
.B PCNICE
operation did not have the
{\fBPRIV_PROC_PRIOCNTL\fR} in its effective set.
.sp
An attempt was made to control a process of which the E, P, and I privilege
sets were not a subset of the effective set of the controlling process or
the limit set of the controlling process is not a superset of limit set of
the controlled process.
.sp
Any of the uids of the target process are 0 or an attempt was made to
change any of the uids to 0 using PCSCRED and the security policy imposed
additional restrictions. See
.BR privileges (5).
.RE

.SH NOTES
.sp
.LP
Descriptions of structures in this document include only interesting
structure elements, not filler and padding fields, and may show elements out
of order for descriptive clarity. The actual structure definitions are
contained in \fB<procfs.h>\fR\&.
.SH BUGS
.sp
.LP
Because the old \fBioctl\fR(2)-based version of
.B /proc
is currently
supported for binary compatibility with old applications, the top-level
directory for a process, \fB/proc/\fIpid\fR, is not world-readable, but
it is world-searchable. Thus, anyone can open
\fB/proc/\fIpid\fB/psinfo\fR even though \fBls\fR(1) applied to
\fB/proc/\fIpid\fR will fail for anyone but the owner or an appropriately
privileged process. Support for the old \fBioctl\fR(2)-based version of
.B /proc
will be dropped in a future release, at which time the top-level
directory for a process will be made world-readable.
.sp
.LP
On SPARC based machines, the types
.B gregset_t
and \fBfpregset_t\fR
defined in <\fBsys/regset.h\fR> are similar to but not the same as the types
.B prgregset_t
and \fBprfpregset_t\fR defined in <\fBprocfs.h\fR>.
