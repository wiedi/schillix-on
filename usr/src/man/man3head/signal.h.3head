'\" te
.\" Copyright (c) 1995 IEEE.  All Rights Reserved.
.\" Portions Copyright (c) 2008, Sun Microsystems, Inc.  All Rights Reserved.
.\" Copyright (c) 2012-2013, J. Schilling
.\" Copyright (c) 2013, Andreas Roehler
.\"
.\" Sun Microsystems, Inc. gratefully acknowledges The Open Group for
.\" permission to reproduce portions of its copyrighted documentation.
.\" Original documentation from The Open Group can be obtained online
.\" at http://www.opengroup.org/bookstore/.
.\"
.\" The Institute of Electrical and Electronics Engineers and The Open Group,
.\" have given us permission to reprint portions of their documentation.
.\"
.\" In the following statement, the phrase "this text" refers to portions
.\" of the system documentation.
.\"
.\" Portions of this text are reprinted and reproduced in electronic form in
.\" the Sun OS Reference Manual, from IEEE Std 1003.1, 2004 Edition, Standard
.\" for Information Technology -- Portable Operating System Interface (POSIX),
.\" The Open Group Base Specifications Issue 6, Copyright (C) 2001-2004 by the
.\" Institute of Electrical and Electronics Engineers, Inc and The Open Group.
.\" In the event of any discrepancy between these versions and the original
.\" IEEE and The Open Group Standard, the original IEEE and The Open Group
.\" Standard is the referee document.
.\"
.\" The original Standard can be obtained online at
.\" http://www.opengroup.org/unix/online.html.
.\"
.\" This notice shall appear on any product containing this material.
.\"
.\" CDDL HEADER START
.\"
.\" The contents of this file are subject to the terms of the
.\" Common Development and Distribution License ("CDDL"), version 1.0.
.\" You may only use this file in accordance with the terms of version
.\" 1.0 of the CDDL.
.\"
.\" A full copy of the text of the CDDL should have accompanied this
.\" source.  A copy of the CDDL is also available via the Internet at
.\" http://www.opensource.org/licenses/cddl1.txt
.\"
.\" When distributing Covered Code, include this CDDL HEADER in each
.\" file and include the License file at usr/src/OPENSOLARIS.LICENSE.
.\" If applicable, add the following below this CDDL HEADER, with the
.\" fields enclosed by brackets "[]" replaced with your own identifying
.\" information: Portions Copyright [yyyy] [name of copyright owner]
.\"
.\" CDDL HEADER END
.TH signal.h 3HEAD "5 Feb 2008" "SunOS 5.11" "Headers"
.SH NAME
signal.h, signal \- base signals
.SH SYNOPSIS
.LP
.nf
\fB#include <signal.h>\fR
.fi

.SH DESCRIPTION
.sp
.LP
A signal is an asynchronous notification of an event. A signal is said to be
generated for (or sent to) a process when the event associated with that signal
first occurs. Examples of such events include hardware faults, timer expiration
and terminal activity, as well as the invocation of the
.BR kill (2)
or
.BR sigsend (2)
functions. In some circumstances, the same event generates
signals for multiple processes. A process may request a detailed notification
of
the source of the signal and the reason why it was generated. See
.BR siginfo.h (3HEAD).
.sp
.LP
Signals can be generated synchronously or asynchronously. Events directly
caused by the execution of code by a thread, such as a reference to an
unmapped,
protected, or bad memory can generate
.B SIGSEGV
or
.BR SIGBUS ;
a floating
point exception can generate
.BR SIGFPE ;
and the execution of an illegal
instruction can generate
.BR SIGILL .
Such events are referred to as traps;
signals generated by traps are said to be synchronously generated.
Synchronously
generated signals are initiated by a specific thread and are delivered to and
handled by that thread.
.sp
.LP
Signals may also be generated by calling
.BR kill() ,
.BR sigqueue() ,
or
.BR sigsend() .
Events such as keyboard interrupts generate signals, such as
.BR SIGINT ,
which are sent to the target process. Such events are referred to
as interrupts; signals generated by interrupts are said to be asynchronously
generated. Asynchronously generated signals are not directed to a particular
thread but are handled by an arbitrary thread that meets either of the
following
conditions:
.RS +4
.TP
.ie t \(bu
.el o
The thread is blocked in a call to
.BR sigwait (2)
whose argument includes the
type of signal generated.
.RE
.RS +4
.TP
.ie t \(bu
.el o
The thread has a signal mask that does not include the type of signal
generated. See
.BR pthread_sigmask (3C).
Each process can specify a system
action to be taken in response to each signal sent to it, called the signal's
disposition. All threads in the process share the disposition. The set of
system
signal actions for a process is initialized from that of its parent. Once an
action is installed for a specific signal, it usually remains installed until
another disposition is explicitly requested by a call to either
.BR sigaction() ,
.B signal()
or
.BR sigset() ,
or until the process
.BR execs() .
See
.BR sigaction (2)
and
.BR signal "(3C). When a process"
execs, all signals whose disposition has been set to catch the signal will be
set to
.B SIG_DFL.
Alternatively, a process may request that the system
automatically reset the disposition of a signal to
.B SIG_DFL
after it has
been caught. See
.BR sigaction (2)
and
.BR signal (3C).
.RE
.SS "SIGNAL DELIVERY"
.sp
.LP
A signal is said to be delivered to a process when a thread within the process
takes the appropriate action for  the disposition of the signal. Delivery of a
signal can be blocked. There are two methods for handling delivery of a signal
in a multithreaded application. The first method specifies a signal handler
function to execute when the signal is received by the process. See
.BR sigaction (2).
The second method uses
.BR sigwait (2)
to create a thread
to handle the receipt of the signal. The
.B sigaction()
function can be used
for both synchronously and asynchronously generated signals. The
.B sigwait()
function will work only for asynchronously generated signals, as synchronously
generated signals are sent to the thread that caused the event. The
.B sigwait()
function is the recommended for use with a multithreaded
application.
.SS "SIGNAL MASK"
.sp
.LP
Each thread has a signal mask  that defines the set of signals currently
blocked from delivery to it. The signal mask of the main thread is inherited
from the signal mask of the thread that created it in the parent process. The
selection of the thread within the process that is to take the appropriate
action for the signal is based on the method of signal generation and the
signal
masks of the threads in the receiving process. Signals that are generated by
action of a particular thread such as hardware faults are delivered to the
thread that caused the signal. See
.BR pthread_sigmask (3C)
or
.BR sigprocmask (2).
See
.BR alarm (2)
for current semantics of delivery of
.BR SIGALRM .
Signals that are directed to a particular thread  are delivered
to the targeted thread. See
.BR pthread_kill (3C).
If the selected thread has
blocked the signal, it remains pending on the thread until it is unblocked. 
For
all other types of signal generation  (for example,
.BR kill (2),
.BR sigsend (2),
terminal activity, and other external events not ascribable to
a particular thread) one of the threads that does not have the signal blocked
is
selected to process the signal. If all the threads within the process block the
signal, it remains pending on the process until a thread in the process
unblocks
it. If the action associated with a signal is set to ignore the signal then
both
currently pending and subsequently generated signals of this type are discarded
immediately for this process.
.sp
.LP
The determination of which action is taken in response to a signal  is made at
the time the signal is delivered to a thread within the process, allowing for
any changes since the time of generation.   This determination is independent
of
the means by which the signal was originally generated.
.sp
.LP
The signals currently defined by
.RB < signal.h >
are as follows:
.sp

.sp
.TS
tab();
cw(1.38i) cw(.49i) cw(.86i) cw(2.78i)
lw(1.38i) lw(.49i) lw(.86i) lw(2.78i)
.
NameValueDefaultEvent
\fBSIGHUP\fR1ExitHangup (see \fBtermio\fR(7I))
\fBSIGINT\fR2ExitInterrupt (see \fBtermio\fR(7I))
\fBSIGQUIT\fR3CoreQuit (see \fBtermio\fR(7I))
\fBSIGILL\fR4CoreIllegal Instruction
\fBSIGTRAP\fR5CoreTrace or Breakpoint Trap
\fBSIGABRT\fR6CoreAbort
\fBSIGEMT\fR7CoreEmulation Trap
\fBSIGFPE\fR8CoreArithmetic Exception
\fBSIGKILL\fR9ExitKilled
\fBSIGBUS\fR10CoreBus Error
\fBSIGSEGV\fR11CoreSegmentation Fault
\fBSIGSYS\fR12CoreBad System Call
\fBSIGPIPE\fR13ExitBroken Pipe
\fBSIGALRM\fR14ExitAlarm Clock
\fBSIGTERM\fR15ExitTerminated
\fBSIGUSR1\fR16ExitUser Signal 1
\fBSIGUSR2\fR17ExitUser Signal 2
\fBSIGCHLD\fR18IgnoreChild Status Changed
\fBSIGPWR\fR19IgnorePower Fail or Restart
\fBSIGWINCH\fR20IgnoreWindow Size Change
\fBSIGURG\fR21IgnoreUrgent Socket Condition
\fBSIGPOLL\fR22ExitPollable Event (see \fBstreamio\fR(7I))
\fBSIGSTOP\fR23StopStopped (signal)
\fBSIGTSTP\fR24StopStopped (user) (see \fBtermio\fR(7I))
\fBSIGCONT\fR25IgnoreContinued
\fBSIGTTIN\fR26StopStopped (tty input) (see \fBtermio\fR(7I))
\fBSIGTTOU\fR27StopStopped (tty output) (see \fBtermio\fR(7I))
\fBSIGVTALRM\fR28ExitVirtual Timer Expired
\fBSIGPROF\fR29ExitProfiling Timer Expired
\fBSIGXCPU\fR30CoreT{
CPU time limit exceeded (see \fBgetrlimit\fR(2))
T}
\fBSIGXFSZ\fR31CoreT{
File size limit exceeded (see \fBgetrlimit\fR(2))
T}
\fBSIGWAITING\fR32IgnoreReserved
\fBSIGLWP\fR33IgnoreReserved
\fBSIGFREEZE\fR34IgnoreCheck point Freeze
\fBSIGTHAW\fR35IgnoreCheck point Thaw
\fBSIGCANCEL\fR36IgnoreReserved for threading support
\fBSIGLOST\fR37ExitT{
Resource lost (for example, record-lock lost)
T}
\fBSIGXRES\fR38IgnoreT{
Resource control exceeded (see \fBsetrctl\fR(2))
T}
\fBSIGJVM1\fR39IgnoreReserved for Java Virtual Machine 1
\fBSIGJVM2\fR40IgnoreReserved for Java Virtual Machine 2
\fBSIGRTMIN\fR\fB*\fRExitFirst real time signal
(\fBSIGRTMIN\fR+1)*ExitSecond real time signal
\fB\|.\|.\|.\fR
(\fBSIGRTMAX\fR-1)*ExitSecond-to-last real time signal
\fBSIGRTMAX\fR\fB*\fRExitLast real time signal
.TE

.sp
.LP
The symbols
.B SIGRTMIN
through
.B SIGRTMAX
are evaluated dynamically to
permit future configurability.
.sp
.LP
Applications should not use any of the signals marked "reserved" in the above
table for any purpose, to avoid interfering with their use by the system.
.SS "SIGNAL DISPOSITION"
.sp
.LP
A process using a
.BR signal (3C),
.BR sigset (3C)
or
.BR sigaction (2)
system call can specify one of three dispositions for a signal: take the
default
action for the signal, ignore the signal, or catch the signal.
.SS "Default Action: SIG_DFL"
.sp
.LP
A disposition of
.B SIG_DFL
specifies the default action. The default
action for each signal is listed in the table above and is selected from the
following:
.sp
.ne 2
.mk
.na
.B Exit
.ad
.RS 10n
.rt
When it gets the signal, the receiving process is to be terminated with all the
consequences outlined in
.BR exit (2).
.RE

.sp
.ne 2
.mk
.na
.B Core
.ad
.RS 10n
.rt
When it gets the signal, the receiving process is to be terminated with all the
consequences outlined in
.BR exit (2).
In addition, a ``core image'' of the
process is constructed in the  current working directory.
.RE

.sp
.ne 2
.mk
.na
.B Stop
.ad
.RS 10n
.rt
When it gets the signal, the receiving process is to stop. When a process is
stopped, all the threads within the process also stop executing.
.RE

.sp
.ne 2
.mk
.na
.B Ignore
.ad
.RS 10n
.rt
When it gets the signal, the receiving process is to ignore it. This is
identical to setting the disposition to
.BR SIG_IGN .
.RE

.SS "Ignore Signal: SIG_IGN"
.sp
.LP
A disposition of
.B SIG_IGN
specifies that the signal is to be ignored.
Setting a signal action to
.B SIG_IGN
for a signal that is pending causes the
pending signal to be discarded, whether or not it is blocked. Any queued values
pending are also discarded, and the resources used to queue them are released
and made available to queue other signals.
.SS "Catch Signal: function address"
.sp
.LP
A disposition that is a function address specifies that, when it gets the
signal, the thread within the process that is selected to process the signal
will execute the signal handler at the specified address. Normally, the signal
handler is passed the signal number as its only argument. If the disposition
was
set with the
.BR sigaction (2)
function, however, additional arguments can be
requested. When the signal handler returns, the receiving process resumes
execution at the point it was interrupted, unless the signal handler makes
other
arrangements. If an invalid function address is specified, results are
undefined.
.sp
.LP
If the disposition has been set with the
.B sigset()
or
.BR sigaction() ,
the signal is automatically blocked in the thread while it is executing the
signal catcher. If a
.B longjmp()
is used to leave the signal catcher, then
the signal must be explicitly unblocked by the user. See
.BR setjmp (3C),
.BR signal (3C)
and
.BR sigprocmask (2).
.sp
.LP
If execution of the signal handler interrupts a blocked function call, the
handler is executed and the interrupted function call returns  \fB\(mi1\fR to
the calling process with
.B errno
set to
.BR EINTR .
If the
.BR SA_RESTART
flag is set, however, certain function calls will be transparently restarted.
.sp
.LP
Some signal-generating functions, such as high resolution timer expiration,
asynchronous I/O completion, inter-process message arrival, and the
.BR sigqueue (3C)
function, support the specification of an application defined
value, either explicitly as a parameter to the function, or in a
.B sigevent
structure parameter. The
.B sigevent
structure is defined by
.BR <signal.h>
and contains at least the following members:
.sp

.sp
.TS
tab();
cw(1.83i) cw(1.83i) cw(1.83i)
lw(1.83i) lw(1.83i) lw(1.83i)
.
TypeNameDescription
_
\fBint\fR\fBsigev_notify\fRNotification type
\fBint\fR\fBsigev_signo\fRSignal number
_
\fBunion sigval\fR\fBsigev_value\fRSignal value
_
\fBvoid(*)(union sigval)\fR\fBsigev_notify_function\fRNotification function
_
\fB(pthread_attr_t *)\fR\fBsigev_notify_attributes\fRNotification attributes
.TE

.sp
.LP
The
.B sigval
union is defined by
.BR <signal.h> "and contains at least the"
following members:
.sp

.sp
.TS
tab();
cw(1.83i) cw(1.83i) cw(1.83i)
lw(1.83i) lw(1.83i) lw(1.83i)
.
TypeNameDescription
_
\fBint\fR\fBsival_int\fRInteger signal value
\fBvoid *\fR\fBsival_ptr\fRPointer signal value
.TE

.sp
.LP
The
.B sigev_notify
member specifies the notification mechanism to use when
an asynchronous event occurs. The
.B sigev_notify
member may be defined with
the following values:
.sp
.ne 2
.mk
.na
.B SIGEV_NONE
.ad
.RS 16n
.rt
No asynchronous notification is delivered when the event of interest occurs.
.RE

.sp
.ne 2
.mk
.na
.B SIGEV_SIGNAL
.ad
.RS 16n
.rt
A queued signal, with its value equal to
.BR sigev_signo ,
is generated when
the event of interest occurs.
.RE

.sp
.ne 2
.mk
.na
.B SIGEV_THREAD
.ad
.RS 16n
.rt
The
.B sigev_notify_function
is called, with
.B sigev_value
as its
argument, to perform notification when the asynchronous event occurs. The
function is executed in an environment as if it were the start routine for a
newly created thread with thread attributes
.BR sigev_notify_attributes .
If
.B sigev_notify_attributes
is
.IR NULL ,
the thread runs as a detached
thread with default attributes. Otherwise, the thread runs with the specified
attributes, but as a detached thread regardless. The thread runs with all
blockable signals blocked.
.RE

.sp
.ne 2
.mk
.na
.B SIGEV_PORT
.ad
.RS 16n
.rt
An asynchronous notification is delivered to an event port when the event of
interest occurs. The
.B sigev_value.sival_ptr
member points to a
.B port_notify_t
structure defined in
.RB < port.h >
(see
.BR port_associate (3C)).
The event port identifier as well as an
application-defined cookie are part of the
.B port_notify_t
structure.
.RE

.sp
.LP
The
.B sigev_signo
member contains the application-defined value to be
passed to the signal-catching function (for notification type
.BR SIGEV_SIGNAL )
at the time of the signal delivery as the
.BR si_value
member of the
.B siginfo_t
structure, or as the argument to the notification
function (for notification type
.BR SIGEV_THREAD )
that is called when the
asynchronous event occurs.  For notification type
.BR SIGEV_PORT ,
.B sigev_value.sival_ptr
points to a
.B port_notify_t
structure that
specifies the port and an application-defined cookie.
.sp
.LP
The
.B sigev_value
member references the application defined value to be
passed to the signal-catching function at the time of the signal delivery as
the
.B si_value
member of the
.B siginfo_t
structure.
.sp
.LP
The
.B sival_int
member is used when the application defined value is of
type
.BR int ,
and the
.B sival_ptr
member is used when the application
defined value is a pointer.
.sp
.LP
When a signal is generated by
.BR sigqueue (3C)
or any signal\(migenerating
function which supports the specification of an application defined value, the
signal is marked pending and, if the
.B SA_SIGINFO
flag is set for that
signal, the signal is queued to the process along with the application
specified
signal value. Multiple occurrences of signals so generated are queued in FIFO
order. If the
.B SA_SIGINFO
flag is not set for that signal, later
occurrences of that signal's generation, when a signal is already queued, are
silently discarded.
.SH ATTRIBUTES
.sp
.LP
See
.BR attributes (5)
for descriptions of the following attributes:
.sp

.sp
.TS
tab() box;
cw(2.75i) |cw(2.75i)
lw(2.75i) |lw(2.75i)
.
ATTRIBUTE TYPEATTRIBUTE VALUE
_
Interface StabilityCommitted
_
StandardSee \fBstandards\fR(5).
.TE

.SH SEE ALSO
.sp
.LP
.BR lockd (1M),
.BR Intro (2),
.BR alarm (2),
.BR exit (2),
.BR fcntl (2),
.BR getrlimit (2),
.BR ioctl (2),
.BR kill (2),
.BR pause (2),
.BR setrctl (2),
.BR sigaction (2),
.BR sigaltstack (2),
.BR sigprocmask (2),
.BR sigsend (2),
.BR sigsuspend (2),
.BR sigwait (2),
.BR port_associate (3C),
.BR pthread_create (3C),
.BR pthread_kill (3C),
.BR pthread_sigmask (3C),
.BR setjmp (3C),
.BR siginfo.h (3HEAD),
.BR signal (3C),
.BR sigqueue (3C),
.BR sigsetops (3C),
.BR ucontext.h (3HEAD),
.BR wait (3C),
.BR attributes (5),
.BR standards (5)
.SH NOTES
.sp
.LP
The dispositions of the
.B SIGKILL
and
.B SIGSTOP
signals cannot be
altered from their default values. The system generates an error if this is
attempted.
.sp
.LP
The
.BR SIGKILL ,
.BR SIGSTOP ,
and
.B SIGCANCEL
signals cannot be
blocked. The system silently enforces this restriction.
.sp
.LP
The
.B SIGCANCEL
signal cannot be directed to an individual thread using
.BR pthread_kill (3C),
but it can be sent to a process using
.BR kill (2),
.BR sigsend (2),
or
.BR sigqueue (3C).
.sp
.LP
Whenever a process receives a
.BR SIGSTOP ,
.BR SIGTSTP ,
.BR SIGTTIN ,
or
.B SIGTTOU
signal, regardless of its disposition, any pending
.B SIGCONT
signal are discarded.
.sp
.LP
Whenever a process receives a
.B SIGCONT
signal, regardless of its
disposition, any pending
.BR SIGSTOP ,
.BR SIGTSTP ,
.BR SIGTTIN ,
and
.B SIGTTOU
signals is discarded. In addition, if the process was stopped, it
is continued.
.sp
.LP
.B SIGPOLL
is issued when a file descriptor corresponding to a STREAMS file
has a "selectable" event pending. See \fBIntro\fR(2). A process must
specifically request that this signal be sent using the
.BR I_SETSIG
.B ioctl
call. Otherwise, the process will never receive
.BR SIGPOLL .
.sp
.LP
If the disposition of the
.B SIGCHLD
signal has been set with
.BR signal()
or
.BR sigset() ,
or with
.B sigaction()
and the
.B SA_NOCLDSTOP
flag has
been specified, it will only be sent to the calling process when its children
exit; otherwise, it will also be sent when the calling process's children are
stopped or continued due to job control.
.sp
.LP
The name
.B SIGCLD
is also defined in this header and identifies the same
signal as
.BR SIGCHLD .
.B SIGCLD
is provided for backward compatibility,
new applications should use
.BR SIGCHLD .
.sp
.LP
The disposition of signals that are inherited as
.B SIG_IGN
should not be
changed.
.sp
.LP
Signals which are generated synchronously should not be masked. If such a
signal is blocked and delivered, the receiving process is killed.
