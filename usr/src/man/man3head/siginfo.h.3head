'\" te
.\" Copyright (c) 2008, Sun Microsystems, Inc.  All Rights Reserved.
.\" Copyright (c) 2012-2013, J. Schilling
.\" Copyright (c) 2013, Andreas Roehler
.\" Copyright 1989 AT&T
.\" CDDL HEADER START
.\"
.\" The contents of this file are subject to the terms of the
.\" Common Development and Distribution License ("CDDL"), version 1.0.
.\" You may only use this file in accordance with the terms of version
.\" 1.0 of the CDDL.
.\"
.\" A full copy of the text of the CDDL should have accompanied this
.\" source.  A copy of the CDDL is also available via the Internet at
.\" http://www.opensource.org/licenses/cddl1.txt
.\"
.\" When distributing Covered Code, include this CDDL HEADER in each
.\" file and include the License file at usr/src/OPENSOLARIS.LICENSE.
.\" If applicable, add the following below this CDDL HEADER, with the
.\" fields enclosed by brackets "[]" replaced with your own identifying
.\" information: Portions Copyright [yyyy] [name of copyright owner]
.\"
.\" CDDL HEADER END
.TH siginfo.h 3HEAD "5 Feb 2008" "SunOS 5.11" "Headers"
.SH NAME
siginfo.h, siginfo \- signal generation information
.SH SYNOPSIS
.LP
.nf
#include <siginfo.h>
.fi

.SH DESCRIPTION
.sp
.LP
If a process is catching a signal,  it might request information that tells
why the system generated that signal. See
.BR sigaction (2).
If a process
is monitoring its children, it might receive information that tells why a
child changed state. See
.BR waitid (2).
In either case, the system
returns the information in a structure of type
.BR siginfo_t ,
which
includes the following information:
.sp
.in +2
.nf
int            si_signo        /* signal number */
int            si_errno        /* error number */
int            si_code         /* signal code */
union sigval   si_value        /* signal value */
.fi
.in -2

.sp
.LP
.B si_signo
contains the system-generated signal number. For the
.BR waitid (2)
function,
.B si_signo
is always
.BR SIGCHLD .
.sp
.LP
If
.B si_errno
is non-zero, it contains an error number associated with
this signal, as defined in
.BR <errno.h> \&.
.sp
.LP
.B si_code
contains a code identifying the cause of the signal.
.sp
.LP
If the value of the
.B si_code
member is
.B SI_NOINFO,
only the
.B si_signo
member of
.B siginfo_t
is meaningful, and the value of
all other members is unspecified.
.SS "User Signals"
.sp
.LP
If the value of
.B si_code
is less than or equal to 0, then the signal
was generated by a user process (see
.BR kill (2),
.BR _lwp_kill (2),
.BR sigqueue (3C),
.BR sigsend (2),
.BR abort (3C),
and
.BR raise (3C))
and the
.B siginfo
structure contains the following additional
information:
.sp
.in +2
.nf
pid_t        si_pid      /* sending process ID */
uid_t        si_uid      /* sending user ID */
ctid_t       si_ctid     /* sending contract ID */
zoneid_t     si_zoneid   /* sending zone ID */S
.fi
.in -2

.sp
.LP
If the signal was generated by a user process, the following values are
defined for
.BR si_code :
.sp
.ne 2
.mk
.na
.B SI_USER
.ad
.RS 15n
.rt
The implementation sets
.B si_code
to
.B SI_USER
if the signal was
sent by
.BR kill (2),
.BR sigsend (2),
.BR raise (3C)
or
.BR abort (3C).

.RE

.sp
.ne 2
.mk
.na
.B SI_LWP
.ad
.RS 15n
.rt
The signal was sent by
.BR _lwp_kill (2).
.RE

.sp
.ne 2
.mk
.na
.B SI_QUEUE
.ad
.RS 15n
.rt
The signal was sent by
.BR sigqueue (3C).
.RE

.sp
.ne 2
.mk
.na
.B SI_TIMER
.ad
.RS 15n
.rt
The signal was generated by the expiration of a timer created by
.BR timer_settime (3C).
.RE

.sp
.ne 2
.mk
.na
.B SI_ASYNCIO
.ad
.RS 15n
.rt
The signal was generated by the completion of an asynchronous
.BR I/O
request.
.RE

.sp
.ne 2
.mk
.na
.B SI_MESGQ
.ad
.RS 15n
.rt
The signal was generated by the arrival of a message on an empty message
queue. See
.BR mq_notify (3C).
.RE

.sp
.LP
.B si_value
contains the application specified value, which is passed to
the application's signal-catching function at the time of the signal
delivery if
.B si_code
is any of
.BR SI_QUEUE ,
.BR SI_TIMER ,
.BR SI_ASYNCHIO ,
or
.BR SI_MESGQ .
.SS "System Signals"
.sp
.LP
Non-user generated signals can arise for a number of reasons. For all of
these cases,
.B si_code
contains a positive value reflecting the reason
why the system generated the signal:
.sp

.sp
.TS
tab();
lw(1.24i) lw(1.74i) lw(2.53i)
lw(1.24i) lw(1.74i) lw(2.53i)
.
SignalCodeReason
_
SIGILLILL_ILLOPCillegal opcode
ILL_ILLOPNillegal operand
ILL_ILLADRillegal addressing mode
ILL_ILLTRPillegal trap
ILL_PRVOPCprivileged opcode
ILL_PRVREGprivileged register
ILL_COPROCco-processor error
ILL_BADSTKinternal stack error
_
SIGFPEFPE_INTDIVinteger divide by zero
FPE_INTOVFinteger overflow
FPE_FLTDIVfloating point divide by zero
FPE_FLTOVFfloating point overflow
FPE_FLTUNDfloating point underflow
FPE_FLTRESfloating point inexact result
FPE_FLTINVinvalid floating point operation
FPE_FLTSUBsubscript out of range
_
SIGSEGVSEGV_MAPERRaddress not mapped to object
SEGV_ACCERRinvalid permissions for mapped object
_
SIGBUSBUS_ADRALNinvalid address alignment
BUS_ADRERRnon-existent physical address
BUS_OBJERRobject specific hardware error
_
SIGTRAPTRAP_BRKPTprocess breakpoint
TRAP_TRACEprocess trace trap
_
SIGCHLDCLD_EXITEDchild has exited
CLD_KILLEDchild was killed
CLD_DUMPEDchild terminated abnormally
CLD_TRAPPEDtraced child has trapped
CLD_STOPPEDchild has stopped
CLD_CONTINUEDstopped child had continued
_
SIGPOLLPOLL_INdata input available
POLL_OUToutput buffers available
POLL_MSGinput message available
POLL_ERRI/O error
POLL_PRIhigh priority input available
POLL_HUPdevice disconnected
.TE

.sp
.LP
Signals can also be generated from the resource control subsystem. Where
these signals do not already possess kernel-level
.B siginfo
codes, the
.B siginfo si_code
will be filled with
.B SI_RCTL
to indicate a
kernel-generated signal from an established resource control value.
.sp

.sp
.TS
tab();
cw(1.19i) cw(1.65i) cw(2.65i)
lw(1.19i) lw(1.65i) lw(2.65i)
.
SignalCodeReason
_
SIGXRESSI_RCTLresource-control generated signal
_
SIGHUP
SIGTERM
.TE

.sp
.LP
The uncatchable signals
.B SIGSTOP
and
.B SIGKILL
have undefined
.B siginfo
codes.
.sp
.LP
Signals sent with a
.B siginfo
code of
.B SI_RCTL
contain
code-dependent information for kernel-generated signals:
.sp

.sp
.TS
tab();
cw(1.19i) cw(1.65i) cw(2.65i)
lw(1.19i) lw(1.65i) lw(2.65i)
.
Code FieldValue
_
SI_RCTLhr_time si_entityprocess-model entity of control
.TE

.sp
.LP
In addition, the following signal-dependent information is available for
kernel-generated signals:
.sp

.sp
.TS
tab();
cw(1.19i) cw(1.67i) cw(2.64i)
lw(1.19i) lw(1.67i) lw(2.64i)
.
SignalFieldValue
_
SIGILLcaddr_t si_addraddress of faulting instruction
_
SIGFPE
_
SIGSEGVcaddr_t si_addraddress of faulting memory reference
SIGBUS
_
SIGCHLDpid_t si_pidchild process ID
int si_statusexit value or signal
_
SIGPOLLlong si_bandT{
band event for \fBPOLL_IN\fR, \fBPOLL_OUT\fR, or \fBPOLL_MSG\fR
T}
.TE

.SH SEE ALSO
.sp
.LP
.BR _lwp_kill (2),
.BR kill (2),
.BR setrctl (2),
.BR sigaction (2),
.BR sigsend (2),
.BR waitid (2),
.BR abort (3C),
.BR aio_read (3C),
.BR mq_notify (3C),
.BR raise (3C),
.BR signal.h (3HEAD),
.BR sigqueue (3C),
.BR timer_create (3C),
.BR timer_settime (3C)
.SH NOTES
.sp
.LP
For
.B SIGCHLD
signals, if
.B si_code
is equal to
.B CLD_EXITED,
then
.B si_status
is equal to the exit value of the
process; otherwise, it is equal to the signal that caused the process to
change state. For some implementations, the exact value of
.B si_addr
might not be available; in that case,
.B si_addr
is guaranteed to be on
the same page as the faulting instruction or memory reference.
