'\" te
.\" Copyright (c) 1982-2007 AT&T Knowledge Ventures
.\" To view license terms, see http://www.opensource.org/licenses/cpl1.0.txt
.\" Portions Copyright (c) 2009, Sun Microsystems, Inc.
.\" Copyright (c) 2012-2013, J. Schilling
.\" Copyright (c) 2013, Andreas Roehler
.TH ksh93 1 "11 Aug sam2009" "SunOS 5.11" "User Commands"
.SH NAME
ksh93, rksh93 \- Korn Shell, a standard and restricted command and
programming language
.SH SYNOPSIS
.LP
.nf
\fBksh93\fR [\fB\(+-abcefhikmnoprstuvxBCD\fR] [\fB-R\fR \fIfile\fR] [ \fB\(+-o\fR \fIoption\fR] .\|.\|.
       [-] [\fIarg\fR .\|.\|.]
.fi

.LP
.nf
\fBrksh93\fR [\fB\(+-abcefhikmnoprstuvxBCD\fR] [\fB-R\fR \fIfile\fR] [\fB\(+-o\fR \fIoption\fR] .\|.\|.
       [-] [\fIarg\fR .\|.\|.]
.fi

.SH DESCRIPTION
.sp
.LP
.B ksh93
is a command and programming language that executes commands
read from a terminal or a file.
.B rksh93
is a restricted version of the
command interpreter
.BR ksh93 .
.B rksh93
is used to set up login names
and execution environments whose capabilities are more controlled than those
of the standard shell.
.sp
.LP
See
.B Invocation
for the meaning of arguments to the shell.
.SS "Definitions"
.sp
.LP
A
.I metacharacter
is defined as one of the following characters:
.sp
.in +2
.nf
; & ( ) | < > NEWLINE SPACE TAB
.fi
.in -2
.sp

.sp
.LP
A
.I blank
is a
.B TAB
or a
.BR SPACE .
.sp
.LP
An
.I identifier
is a sequence of letters, digits, or underscores
starting with a letter or underscore. Identifiers are used as components of
.IR "variable names" .
.sp
.LP
A
.I vname
is a sequence of one or more identifiers separated by a
period (\fB\&.\fR) and optionally preceded by a period (\fB\&.\fR).
.I vnames
are used as function and variable names.
.sp
.LP
A
.I word
is a sequence of
.I characters
from the character set
defined by the current locale, excluding non-quoted
.IR metacharacters .
.sp
.LP
A
.I command
is a sequence of characters in the syntax of the shell
language. The shell reads each command and carries out the desired action
either directly or by invoking separate utilities. A built-in command is a
command that is carried out by the shell itself without creating a separate
process. Some commands are built-in purely for convenience and are not
documented in this manual page. Built-ins that cause side effects in the
shell environment and built-ins that are found before performing a path
search
.RB "(see " Execution )
are documented in this manual page. For
historical reasons, some of these built-ins behave differently than other
built-ins and are called special built-ins.
.SS "Commands"
.sp
.LP
A
.I simple-command
is a list of variable assignments (see \fBVariable Assignments\fR) or a sequence of \fIblank\fR-separated words which can be
preceded by a list of variable assignments. See the
.B Environment
section of this manual page.
.sp
.LP
The first word specifies the name of the command to be executed. Except as
specified in this section, the remaining words are passed as arguments to
the invoked command. The command name is passed as argument 0. See
.BR exec (2).
The
.I value
of a simple-command is its exit status. If it
.RB "terminates normally, its value is " 0 - 255 .
If it terminates
abnormally, its value is \fB256+\fIsignum\fR. The name of the signal
corresponding to the exit status can be obtained by way of the
.BR -l
option of the kill built-in utility.
.sp
.LP
A
.I pipeline
is a sequence of one or more commands separated by
.BR | .
The standard output of each command but the last is connected by a
.BR pipe (2)
to the standard input of the next command. Each command,
except possibly the last, is run as a separate process. The shell waits for
the last command to terminate. The exit status of a pipeline is the exit
status of the last command unless the
.B pipefail
option is enabled. Each
pipeline can be preceded by the reserved word\fB!\fR. This causes the exit
status of the pipeline to become
.B 0
if the exit status of the last
command is
.BR non-zero ,
and
.B 1
if the exit status of the last
command is
.BR 0 .
.sp
.LP
A
.I list
is a sequence of one or more pipelines separated by \fB;, &, |&, &&, or |\fR, and optionally terminated by \fB;, &,\fR or
.BR |& .
Of
these five symbols,
.BR ";, &" ,
and
.B |&
have equal precedence, which is
lower than that of
.B &&
and
.BR || .
The symbols
.B &&
and
.BR ||
also have equal precedence.
.sp
.LP
A semicolon
.RB ( ; )
causes sequential execution of the preceding
pipeline. An ampersand
.RB ( & )
causes asynchronous execution of the
preceding pipeline, that is, the shell does
.I not
wait for that pipeline
to finish. The symbol
.B |&
causes asynchronous execution of the
preceding pipeline with a two-way pipe established to the parent shell. The
standard input and output of the spawned pipeline can be written to and read
from by the parent shell by applying the redirection operators
.B <&
and
.B >&
with
.B "arg p"
to commands and by using
.B -p
option of the
built-in commands
.B read
and
.BR print .
The symbol
.B &&
.RB ( || )
causes the
.I list
following it to be executed only if the preceding
pipeline returns a zero
.RB ( non-zero )
value. One or more NEWLINEs can
appear in a
.I list
instead of a semicolon, to delimit a command. The
first
.I item
of the first
.I pipeline
of a
.I list
that is a
simple command not beginning with a redirection, and not occurring within a
.BR while ,
.BR until ,
or
.B if
.I list
, can be preceded by a
semicolon. This semicolon is ignored unless the
.B showme
option is
enabled as described with the
.B set
built-in.
.sp
.LP
A
.I command
is either a simple-command or one of commands in the
following list. Unless otherwise stated, the value returned by a command is
that of the last simple-command executed in the command.
.sp
.ne 2
.mk
.na
.B for
.I vname
.B [ in
.I word
\fB\&.\|.\|. ] ;do\fR \fIlist\fR
.B ;done
.ad
.sp .6
.RS 4n
Each time a
.B for
command is executed,
.I vname
is set to the next
.I word
taken from the
.B in
.I word
list. If
.B in
\fIword
\&.\|.\|.\fR is omitted, the \fBfor\fR command executes the
.B do
\fIlist\fR
once for each positional parameter that is set starting from 1. Execution
ends when there are no more words in the list. See \fBParameter Expansion\fR.
.RE

.sp
.ne 2
.mk
.na
\fB(( [\fIexpr1\fB] ; [\fIexpr2\fR] ; [\fIexpr3\fB] )) ;do\fR \fIlist\fR \fB;done\fR
.ad
.sp .6
.RS 4n
The arithmetic expression
.I expr1
is evaluated first. The arithmetic
expression
.I expr2
is repeatedly evaluated until it evaluates to
.B zero
and when
.BR non-zero ,
.I list
is executed and the
arithmetic expression
.I expr3
evaluated. If any expression is omitted,
then it behaves as if it evaluated to
.BR 1 .
See \fBArithmetic Evaluation\fR.
.RE

.sp
.ne 2
.mk
.na
.B select
.I vname
[ in
.I word
\fB\&.\|.\|. ] ;do\fR \fIlist\fR
.B ;done
.ad
.sp .6
.RS 4n
A
.B select
command prints on standard error (file descriptor 2) the set
of
.IR words ,
each preceded by a number. If
.B in
\fIword.\|.\|.\fR is
omitted, the positional parameters starting from
.B 1
are used instead.
See
.BR "Parameter Expansion" .
The
.B PS3
prompt is printed and a line is
read from the standard input. If this line consists of the number of one of
the listed
.IR word s,
then the value of the variable
.I vname
is set to
the
.I word
corresponding to this number. If this line is empty, the
selection list is printed again. Otherwise the value of the variable
.I vname
is set to
.BR null .
The contents of the line read from
standard input is saved in the variable
.BR REPLY .
The
.I list
is
executed for each selection until a break or
.B EOF
is encountered. If
the
.B REPLY
variable is set to
.B null
by the execution of
.IR list ,
the selection list is printed before displaying the
.BR PS3
prompt for the next selection.
.RE

.sp
.ne 2
.mk
.na
.B case
.I word
.B in [ [(]
.I pattern
.B [ |
.I pattern
\fB] .\|.\|. )\fR
.I list
\fB;; ] .\|.\|. esac\fR
.ad
.sp .6
.RS 4n
A
.B case
command executes the
.I list
associated with the first
.I pattern
that matches
.IR word .
The form of the patterns is the same
as that used for file name generation. See
.BR "File Name Generation" .
.sp
The
.B ;;
operator causes execution of
.B case
to terminate. If
.B ;&
is used in place of
.B ;;
the next subsequent list, if any, is
executed.
.RE

.sp
.ne 2
.mk
.na
.B if
.I list
.B ;then
.I list
.B [ ;elif
.I list
.B ;then
.I list
] \fB\&.\|.\|. [ ;else\fR
.I list
\fB]\fR
.B ;fi
.ad
.sp .6
.RS 4n
The
.I list
following
.B if
is executed and, if it returns a
.B zero
exit status, the
.I list
following the first
.B then
is
executed. Otherwise, the
.I list
following
.B elif
is executed, and,
if its value is
.BR zero ,
the
.I list
following the next
.B then
is
executed. Failing each successive
.B elif
.IR list ,
the
.BR else
.I list
is executed. If the
.B if
.I list
has
.B non-zero
exit
status and there is no
.BR else
.IR list ,
then the
.B if
command
returns a
.B zero
exit status.
.RE

.sp
.ne 2
.mk
.na
.B while
.I list
.B ;do
.I list
.B ;done
.ad
.br
.na
.BI "until " list
\fB;do\fR \fIlist\fR \fB;done\fR
.ad
.sp .6
.RS 4n
A
.B while
command repeatedly executes the while
.I list
and, if the
exit status of the last command in the list is zero, executes the
.B do
.IR list ,
otherwise the loop terminates. If no commands in the
.B do
.I list
are executed, then the
.B while
command returns a
.BR zero
exit status,
.B until
can be used in place of
.B while
to negate the
loop termination test.
.RE

.sp
.ne 2
.mk
.na
\fB((\fIexpression\fB))\fR
.ad
.sp .6
.RS 4n
The
.I expression
is evaluated using the rules for arithmetic evaluation
described in this manual page. If the value of the arithmetic expression is
.BR non-zero ,
the exit status is
.BR 0 .
Otherwise the exit status is
.BR 1 .
.RE

.sp
.ne 2
.mk
.na
\fB(\fIlist\fB;)\fR
.ad
.sp .6
.RS 4n
Execute list in a separate environment. If two adjacent open parentheses
are needed for nesting, a SPACE must be inserted to avoid evaluation as an
arithmetic command as described in this section.
.sp
.I list
is simply executed. Unlike the metacharacters,
.B (
and
.BR ) ,
.B {
and
.B }
are
.I "reserved words"
and must occur at the
beginning of a line or after a
.B ;
to be recognized.
.RE

.sp
.ne 2
.mk
.na
.B [[
.I expression
.B ]]
.ad
.sp .6
.RS 4n
Evaluates
.I expression
and returns a
.B zero
exit status when
.I expression
is true. See
.B "Conditional Expressions"
for a
description of
.IR expression .
.RE

.sp
.ne 2
.mk
.na
.B function
.I varname
.B {
.I list
.B ;}
.ad
.br
.na
.I varname
.B "() {"
.I list
.B ;}
.ad
.sp .6
.RS 4n
Define a function which is referenced by
.IR varname .
A function whose
.I varname
contains a \fB\&.\fR is called a discipline function and the
portion of the
.I varname
preceding the last \fB\&.\fR must refer to an
existing variable.
.sp
The body of the function is the
.I list
of commands between
.BR { " and"
.BR } .
A function defined with the function
.I varname
syntax can also
be used as an argument to the \fB\&.\fR special built-in command to get the
equivalent behavior as if the
.IB varname ()
syntax were used to
define it. See
.BR Functions .
.RE

.sp
.ne 2
.mk
.na
.B time [
.I pipeline
.B ]
.ad
.sp .6
.RS 4n
If
.I pipeline
is omitted, the user and system time for the current
shell and completed child processes is printed on standard error. Otherwise,
.I pipeline
is executed and the elapsed time as well as the user and
system time are printed on standard error. The
.B TIMEFORMAT
variable can
be set to a format string that specifies how the timing information should
be displayed. See
.B "Shell Variables"
for a description of the
.B TIMEFORMAT
variable.
.RE

.sp
.LP
The following reserved words are recognized as reserved only when they are
the first word of a command and are not quoted:
.br
.in +2
.B case
.in -2
.br
.in +2
.B do
.in -2
.br
.in +2
.B done
.in -2
.br
.in +2
.B else
.in -2
.br
.in +2
.B elif
.in -2
.br
.in +2
.B esac
.in -2
.br
.in +2
.B for
.in -2
.br
.in +2
.B fi
.in -2
.br
.in +2
.B function
.in -2
.br
.in +2
.B if
.in -2
.br
.in +2
.B select
.in -2
.br
.in +2
.B then
.in -2
.br
.in +2
.B time
.in -2
.br
.in +2
.B until
.in -2
.br
.in +2
.B while
.in -2
.br
.in +2
.B { }
.in -2
.br
.in +2
.B [[ ]]
.in -2
.br
.in +2
.B !
.in -2
.SS "Variable Assignments"
.sp
.LP
One or more variable assignments can start a simple command or can be
arguments to the
.BR typeset ,
.BR export ,
or
.B readonly
special
built-in commands. The syntax for an
.I assignment
is of the form:
.sp
.ne 2
.mk
.na
\fIvarname\fB=\fIword\fR
.ad
.br
.na
\fIvarname\fB[\fIword\fB]=\fIword\fR
.ad
.sp .6
.RS 4n
No space is permitted between
.I varname
and the
.B =
or between
.B =
and
.IR word .
.RE

.sp
.ne 2
.mk
.na
\fIvarname\fB=(\fIassignlist\fB)\fR
.ad
.sp .6
.RS 4n
No space is permitted between
.I varname
and the
.BR = .
An
.I assignlist
can be one of the following:
.sp
.ne 2
.mk
.na
\fIword .\|.\|.\fR
.ad
.sp .6
.RS 4n
Indexed array assignment.
.RE

.sp
.ne 2
.mk
.na
\fB[\fIword\fB]=\fIword .\|.\|.\fR
.ad
.sp .6
.RS 4n
Associative array assignment. If prefixed by
.BR "typeset -a" ,
creates an indexed array instead.
.RE

.sp
.ne 2
.mk
.na
\fIassignment .\|.\|.\fR
.ad
.sp .6
.RS 4n
Compound variable assignment. This creates a compound variable
.I varname
with sub-variables of the form
.IR varname.name ,
where
.I name
is the name portion of assignment. The value of
.I varname
contains all the assignment elements. Additional assignments made to
sub-variables of
.I varname
are also displayed as part of the value of
.IR varname .
If no
.IR assignment s
are specified,
.I varname
is a
compound variable allowing subsequence child elements to be defined.
.RE

.sp
.ne 2
.mk
.na
\fBtypeset [\fIoptions\fR]
.I assignment
\fB\&.\|.\|.\fR
.ad
.sp .6
.RS 4n
Nested variable assignment. Multiple assignments can be specified by
separating each of them with a
.BR ; .
The previous value is unset before
the assignment.
.RE

In addition, a
.B +=
can be used in place of the
.B =
to signify
adding to or appending to the previous value. When
.B +=
is applied to an
arithmetic type,
.I word
is evaluated as an arithmetic expression and
added to the current value. When applied to a string variable, the value
defined by
.I word
is appended to the value. For compound assignments,
the previous value is not unset and the new values are appended to the
current ones provided that the types are compatible.
.RE

.SS "Comments"
.sp
.LP
A word beginning with
.B #
causes that word and all the following
characters up to a NEWLINE to be commented, or ignored.
.SS "Aliasing"
.sp
.LP
The first word of each command is replaced by the text of an alias if an
alias for this word has been defined. An alias name consists of any number
of characters excluding metacharacters, quoting characters, file expansion
characters, parameter expansion characters, command substitution characters,
and
.BR = .
The replacement string can contain any valid shell script
including the metacharacters listed in the
.B Commands
section. The first
word of each command in the replaced text, other than any that are in the
process of being replaced, are tested for aliases. If the last character of
the alias value is a BLANK then the word following the alias is also checked
for alias substitution.
.sp
.LP
Aliases can be used to redefine built-in commands but cannot be used to
redefine the reserved words listed in the
.B Commands
section. Aliases
can be created and listed with the alias command and can be removed with the
.B unalias
command.
.sp
.LP
Aliasing is performed when scripts are read, not while they are executed.
For an alias to take effect, the
.B alias
definition command has to be
executed before the command which references the alias is read. The
following aliases are compiled into the shell but can be unset or
redefined:
.sp
.in +2
.nf
autoload='typeset -fu'
command='command '
fc=hist
float='typeset -lE'
functions='typeset -f'
hash='alias -t --'
history='hist -l'
integer='typeset -li'
nameref='typeset -n'
nohup='nohup '
r='hist -s'
redirect='command exec'
source='command .'
stop='kill -s STOP'
suspend='kill -s STOP $$'
times='{ { time;} 2>&1;}'
type='whence -v'
.fi
.in -2
.sp

.SS "Tilde Substitution"
.sp
.LP
After alias substitution is performed, each word is checked to see if it
begins with an unquoted tilde
.RB ( ~ ).
.RI "For tilde substitution," " word"
also refers to the
.I word
portion of parameter expansion. See
.BR "Parameter Expansion" .
.sp
.LP
If it does, the word up to a
.B /
is checked to see if it matches a user
name in the password database. If a match is found, the
.B ~
and the
matched login name are replaced by the login directory of the matched user.
If no match is found, the original text is left unchanged. A
.B ~
by
itself, or in front of a
.BR / ,
is replaced by
.BR $HOME .
A
.BR ~
followed by a
.B +
or
.B -
is replaced by the value of
.B $PWD
and
.B $OLDPWD
respectively.
.sp
.LP
In addition, when expanding a
.IR "variable assignment" ,
tilde substitution
is attempted when the value of the assignment begins with a
.BR ~ ,
and
when a
.B ~
appears after a colon
.RB ( : ).
The
.B :
also terminates
a
.B ~
login name.
.SS "Command Substitution"
.sp
.LP
The standard output from a command enclosed in parentheses preceded by a
.RB "dollar sign (" $ ") or a pair of grave accents (" `` )
can be used as
part or all of a word. Trailing NEWLINEs are removed. In the second
(obsolete) form, the string between the quotes is processed for special
quoting characters before the command is executed. See
.BR Quoting .
.sp
.LP
The command substitution
.B "$(cat file)"
can be replaced by the
equivalent but faster
.BR $(<file) .
The command substitution
\fB$(\fIn\fB<#)\fR expands to the current byte offset for file
descriptor
.IR n .
.SS "Arithmetic Substitution"
.sp
.LP
An arithmetic expression enclosed in double parentheses preceded by a
dollar sign ( \fB$((\fIarithmetic_expression\fB))\fR) is replaced by
the value of the arithmetic expression within the double parentheses.
.SS "Process Substitution"
.sp
.LP
Process substitution is only available on versions of the UNIX operating
system that support the
.B /dev/fd
directory for naming open files.
.sp
.LP
Each command argument of the form \fB<(\fIlist\fB)\fR or
\fB>(\fIlist\fB)\fR runs process
.I list
asynchronously connected
to some file in
.BR /dev/fd .
The name of this file becomes the argument to
the command. If the form with
.B >
is selected then writing on this file
provides input for
.IR list .
If
.B <
is used, then the file passed as
an argument contains the output of the
.I list
process.
.sp
.LP
For example,
.sp
.in +2
.nf
paste <(cut -f1 \fIfile1\fR) <(cut -f3 \fIfile2\fR) | tee \e
     >(\fIprocess1\fR) >(\fIprocess2\fR)
.fi
.in -2
.sp

.sp
.LP
\fBcut\fRs fields 1 and 3 from the files
.I file1
and \fIfile2\fR
respectively,
.BR paste s
the results together, and sends it to the
processes
.I process1
and
.IR process2 .
It also displays the results to
the standard output. The file, which is passed as an argument to the
command, is a UNIX
.BR pipe (2).
Programs that expect to
.BR lseek (2)
on
the file do not work.
.SS "Parameter Expansion"
.sp
.LP
A parameter is a variable, one or more digits, or any of the characters
.BR * ,
.BR @ ,
.BR # ,
.BR ? ,
.BR - ,
.BR $ ,
and
.BR ! .
A
variable is denoted by a
.IR vname .
To create a variable whose
.IR vname
contains a \fB\&.\fR, a variable whose
.B vname
consists of everything
before the last . must already exist. A variable has a value and zero or
more attributes. Variables can be assigned values and attributes by using
the
.B typeset
special built-in command. The attributes supported by the
shell are described later with the
.B typeset
special built-in command.
Exported variables pass values and attributes to the environment.
.sp
.LP
The shell supports both indexed and associative arrays. An element of an
array variable is referenced by a subscript. A subscript for an indexed
array is denoted by an arithmetic expression, (see \fBArithmetic Evaluation\fR), between a \fB[\fR and a
.BR ] .
Use
.B "set -A"
\fIvname
value .\|.\|.\fR to assign values to an indexed array. The value of all
subscripts must be in the range of
.B 0
through
.BR 1,048,575 .
Indexed
arrays do not need to be declared. Any reference to a variable with a valid
subscript is legal and an array is created if necessary.
.sp
.LP
An associative array is created with the
.B -A
option to
.BR typeset .
A subscript for an associative array is denoted by a string enclosed between
.B [
and
.BR ] .
.sp
.LP
Referencing any array without a subscript is equivalent to referencing the
array with subscript
.BR 0 .
.sp
.LP
The value of a variable can be assigned by:
.sp
.in +2
.nf
\fIvname\fR=\fIvalue\fR [\fIvname\fR=\fIvalue\fR] .\|.\|.
.fi
.in -2
.sp

.sp
.LP
or
.sp
.in +2
.nf
\fIvname\fR[\fIsubscript\fR]=\fIvalue\fR [\fIvname\fR[\fIsubscript\fR]=\fIvalue\fR] .\|.\|.
.fi
.in -2
.sp

.sp
.LP
No space is allowed before or after the
.BR = .
A
.I nameref
is a
variable that is a reference to another variable. A
.I nameref
is created
with the
.B -n
attribute of
.BR typeset .
The value of the variable at
the time of the
.B typeset
command becomes the variable that is
referenced whenever the
.I nameref
variable is used. The name of a
.I nameref
cannot contain a dot (\fI\&.\fR). When a variable or function
name contains a \fB\&.,\fR and the portion of the name up to the first
\fB\&.\fR matches the name of a
.IR nameref ,
the variable referred to is
obtained by replacing the
.I nameref
portion with the name of the
variable referenced by the
.IR nameref .
If a
.I nameref
is used as the
index of a
.B for
loop, a name reference is established for each item in
the list. A
.I nameref
provides a convenient way to refer to the variable
inside a function whose name is passed as an argument to a function. For
example, if the name of a variable is passed as the first argument to a
function, the command
.sp
.in +2
.nf
 typeset -n var=$1
.fi
.in -2
.sp

.sp
.LP
inside the function causes references and assignments to
.I var
to be
references and assignments to the variable whose name has been passed to the
function. If either of the floating point attributes,
.BR -E ,
or
.BR -F ,
or the integer attribute,
.BR -i ,
is set for
.IR vname ,
then the
.I value
is subject to arithmetic evaluation as described in this manual
page. Positional parameters, parameters denoted by a number, can be assigned
values with the
.B set
special built-in command. Parameter
.B $0
is
set from argument zero when the shell is invoked. The character
.B $
is
used to introduce substitutable parameters.
.sp
.ne 2
.mk
.na
\fB${\fIparameter\fB}\fR
.ad
.sp .6
.RS 4n
The shell reads all the characters from
.BR ${ " to the matching"
.B }
as
part of the same word even if it contains braces or metacharacters. The
value, if any, of the parameter is substituted. The braces are required when
.I parameter
is followed by a letter, digit, or underscore that is not to
be interpreted as part of its name, when the variable name contains a
\fB\&.\fR, or when a variable is subscripted. If
.I parameter
is one or
more digits then it is a positional parameter. A positional parameter of
more than one digit must be enclosed in braces. If
.I parameter
is
.B *
or
.BR @ ,
then all the positional parameters, starting with
.BR $1 ,
are substituted and separated by a field separator character. If
an array
.I vname
with subscript
.B *
or
.B @
is used, then the
value for each of the elements is substituted, separated by the first
character of the value of
.BR IFS .
.RE

.sp
.ne 2
.mk
.na
\fB${#\fIparameter\fB}\fR
.ad
.sp .6
.RS 4n
If
.I parameter
is
.B *
or
.BR @ ,
the number of positional
parameters is substituted. Otherwise, the length of the value of the
.I parameter
is substituted.
.RE

.sp
.ne 2
.mk
.na
\fB${#\fIvname\fB[*]}\fR
.ad
.br
.na
\fB${#\fIvname\fB[@]}\fR
.ad
.sp .6
.RS 4n
The number of elements in the array
.I vname
is substituted.
.RE

.sp
.ne 2
.mk
.na
\fB${!\fIvname\fB}\fR
.ad
.sp .6
.RS 4n
Expands to the name of the variable referred to by
.IR vname .
This is
.I vname
except when
.I vname
is a name reference.
.RE

.sp
.ne 2
.mk
.na
\fB${!\fIvname\fB[\fIsubscript\fB]}\fR
.ad
.sp .6
.RS 4n
Expands to name of the subscript unless
.I subscript
is
.B *
or
.BR @ .
When
.I subscript
is
.BR * ,
the list of array subscripts for
.I vname
is generated. For a variable that is not an array, the value is
.B 0
if the variable is set. Otherwise it is
.BR null .
When
.I subscript
is
.BR @ ,
it is the same as \fB$ {\fIvname\fB[\fI*\fB]}\fR, except that when used in double
quotes, each array subscript yields a separate argument.
.RE

.sp
.ne 2
.mk
.na
\fB${!\fIprefix\fB*}\fR
.ad
.sp .6
.RS 4n
Expands to the names of the variables whose names begin with
.IR prefix .
.RE

.sp
.ne 2
.mk
.na
\fB${\fIparameter\fB:-\fIword\fB}\fR
.ad
.sp .6
.RS 4n
If
.I parameter
is set and is non-null then substitute its value.
Otherwise substitute
.IR word .
.sp
.I word
is not evaluated unless it is to be used as the substituted
string.
.sp
In the following example,
.B pwd
is executed only if
.B d
is not set
or is NULL:
.sp
.in +2
.nf
print ${d:-$(pwd)}
.fi
.in -2
.sp

If the colon (\fB:\fR ) is omitted from the expression, the shell only
checks whether
.I parameter
is set or not.
.RE

.sp
.ne 2
.mk
.na
\fB${\fIparameter\fB:=\fIword\fB}\fR
.ad
.sp .6
.RS 4n
If
.I parameter
is not set or is
.BR null ,
set it to
.IR word .
The
value of the parameter is then substituted. Positional parameters cannot be
assigned to in this way.
.sp
.I word
is not evaluated unless it is to be used as the substituted
string.
.sp
In the following example,
.B pwd
is executed only if
.B d
is not set
or is NULL:
.sp
.in +2
.nf
print ${d:-$(pwd)}
.fi
.in -2
.sp

If the colon
.RB ( : )
is omitted from the expression, the shell only
checks whether
.I parameter
is set or not.
.RE

.sp
.ne 2
.mk
.na
\fB${\fIparameter\fB:?\fIword\fB}\fR
.ad
.sp .6
.RS 4n
If
.I parameter
is set and is non-null, substitute its value. Otherwise,
print
.I word
and exit from the shell , if the shell is not interactive.
If
.I word
is omitted then a standard message is printed.
.sp
.I word
is not evaluated unless it is to be used as the substituted
string.
.sp
In the following example,
.B pwd
is executed only if
.B d
is not set
or is NULL:
.sp
.in +2
.nf
print ${d:-$(pwd)}
.fi
.in -2
.sp

If the colon (\fB:\fR ) is omitted from the expression, the shell only
checks whether
.I parameter
is set or not.
.RE

.sp
.ne 2
.mk
.na
\fB${\fIparameter\fB:+\fIword\fB}\fR
.ad
.sp .6
.RS 4n
If
.I parameter
is set and is non-null, substitute
.IR word .
Otherwise
substitute nothing.
.sp
.I word
is not evaluated unless it is to be used as the substituted
string.
.sp
In the following example,
.B pwd
is executed only if
.B d
is not set
or is NULL:
.sp
.in +2
.nf
print ${d:-$(pwd)}
.fi
.in -2
.sp

If the colon
.RB ( : )
is omitted from the expression, the shell only
checks whether
.I parameter
is set or not.
.RE

.sp
.ne 2
.mk
.na
\fB${\fIparameter\fB:\fIoffset\fR:\fIlength\fR}\fR
.ad
.br
.na
\fB${\fIparameter\fB:\fIoffset\fB}\fR
.ad
.sp .6
.RS 4n
Expands to the portion of the value of
.I parameter
starting at the
character (counting from
.BR 0 )
determined by expanding offset as an
arithmetic expression and consisting of the number of characters determined
by the arithmetic expression defined by
.IR length .
.sp
In the second form, the remainder of the value is used. A negative offset
counts backwards from the end of
.IR parameter .
.sp
One or more BLANKs is required in front of a minus sign to prevent the
shell from interpreting the operator as
.BR :- .
If parameter is
.B *
or
.BR @ ,
or is an array name indexed by
.B *
or
.BR @ ,
then
.I offset
and
.I length
refer to the array index and number of
elements respectively. A negative
.I offset
is taken relative to one
greater than the highest subscript for indexed arrays. The order for
associative arrays is unspecified.
.RE

.sp
.ne 2
.mk
.na
\fB${\fIparameter\fB#\fIpattern\fB}\fR
.ad
.br
.na
\fB${\fIparameter\fB##\fIpattern\fB}\fR
.ad
.sp .6
.RS 4n
If the shell
.I pattern
matches the beginning of the value of
.IR parameter ,
then the value of this expansion is the value of the
.I parameter
with the matched portion deleted. Otherwise the value of
this
.I parameter
is substituted. In the first form the smallest matching
.I pattern
is deleted and in the second form the largest matching
.I pattern
is deleted. When
.I parameter
is
.BR @ ,
.BR * ,
or an
array variable with subscript
.B @
or
.BR * ,
the substring operation is
applied to each element in turn.
.RE

.sp
.ne 2
.mk
.na
\fB${\fIparameter\fB%\fIpattern\fB}\fR
.ad
.br
.na
\fB${\fIparameter\fB%%\fIpattern\fB}\fR
.ad
.sp .6
.RS 4n
If the shell
.I pattern
matches the end of the value of
.IR parameter ,
then the value of this expansion is the value of the parameter with the
matched part deleted. Otherwise substitute the value of
.IR parameter .
In
the first form the smallest matching pattern is deleted, and in the second
form the largest matching pattern is deleted. When parameter is
.BR @ ,
.BR * ,
or an array variable with subscript
.B @
or
.BR * ,
the
substring operation is applied to each element in turn.
.RE

.sp
.ne 2
.mk
.na
\fB${\fIparameter\fB/\fIpattern\fB/\fIstring\fB}\fR
.ad
.br
.na
\fB${\fIparameter\fB//\fIpattern\fB/\fIstring\fB}\fR
.ad
.br
.na
\fB${\fIparameter\fB/#\fIpattern\fB/\fIstring\fB}\fR
.ad
.br
.na
\fB${\fIparameter\fB/%\fIpattern\fB/\fIstring\fB}\fR
.ad
.sp .6
.RS 4n
Expands
.I parameter
and replaces the longest match of
.IR pattern
with the specified
.IR string .
Each occurrence of \fB\e\fIn\fR in
.I string
is replaced by the portion of
.I parameter
that matches the
.IB n th
sub-pattern.
.sp
When
.I string
is null, the
.I pattern
is deleted and the
.B /
in
front of string can be omitted. When
.I parameter
is
.BR @ ,
.BR * ,
or
an array variable with subscript
.B @
or
.BR * ,
the substitution
.RI "operation is applied to each element in turn. In this case, the" " string"
portion of
.I word
is re-evaluated for each element.
.sp
In the first form, only the first occurrence of
.I pattern
is replaced.

.sp
In the second form, each match for
.I pattern
is replaced by the
specified
.IR string .
.sp
The third form restricts the pattern match to the beginning of the
.IR string .
.sp
The fourth form restricts the pattern match to the end of the
.IR string .

.RE

.sp
.LP
The following parameters are automatically set by the shell:
.sp
.ne 2
.mk
.na
.B #
.ad
.RS 19n
.rt
The number of positional parameters in decimal.
.RE

.sp
.ne 2
.mk
.na
.B -
.ad
.RS 19n
.rt
Options supplied to the shell on invocation or by the
.B set
command.
.RE

.sp
.ne 2
.mk
.na
.B ?
.ad
.RS 19n
.rt
The decimal value returned by the last executed command.
.RE

.sp
.ne 2
.mk
.na
.B $
.ad
.RS 19n
.rt
The process number of this shell.
.RE

.sp
.ne 2
.mk
.na
.B _
.ad
.RS 19n
.rt
Initially, the value of
.B _
is the absolute pathname of the shell or
script being executed as passed in the environment. It is subsequently
assigned the last argument of the previous command.
.sp
This parameter is not set for commands which are asynchronous. This
parameter is also used to hold the name of the matching
.B MAIL
file when
checking for mail.
.RE

.sp
.ne 2
.mk
.na
.B !
.ad
.RS 19n
.rt
The process number of the last background command invoked or the most
recent job put in the background with the
.B bg
built-in command.
.RE

.sp
.ne 2
.mk
.na
\fB\&.sh.command\fR
.ad
.RS 19n
.rt
When processing a
.B DEBUG
trap, this variable contains the current
command line that is about to run.
.RE

.sp
.ne 2
.mk
.na
\fB\&.sh.edchar\fR
.ad
.RS 19n
.rt
This variable contains the value of the keyboard character (or sequence of
characters if the first character is an ESC,
.BR "ASCII 033" )
that has been
entered when processing a
.B KEYBD
trap. If the value is changed as part
of the trap action, then the new value replaces the key (or key sequence)
that caused the trap. See the
.B "Key Bindings"
section of this manual
page.
.RE

.sp
.ne 2
.mk
.na
\fB\&.sh.edcol\fR
.ad
.RS 19n
.rt
The character position of the cursor at the time of the most recent
.B KEYBD
trap.
.RE

.sp
.ne 2
.mk
.na
\fB\&.sh.edmode\fR
.ad
.RS 19n
.rt
The value is set to ESC when processing a
.B KEYBD
trap while in
.B vi
insert mode. Otherwise, \fB\&.sh.edmode\fR is null when processing
a
.B KEYBD
trap. See the
.B "vi Editing Mode"
section of this manual
page.
.RE

.sp
.ne 2
.mk
.na
\fB\&.sh.edtext\fR
.ad
.RS 19n
.rt
The characters in the input buffer at the time of the most recent
.B KEYBD
trap. The value is null when not processing a
.B KEYBD
trap.
.RE

.sp
.ne 2
.mk
.na
\fB\&.sh.file\fR
.ad
.RS 19n
.rt
The pathname of the file than contains the current command.
.RE

.sp
.ne 2
.mk
.na
\fB\&.sh.fun\fR
.ad
.RS 19n
.rt
The name of the current function that is being executed.
.RE

.sp
.ne 2
.mk
.na
\fB\&.sh.match\fR
.ad
.RS 19n
.rt
An indexed array which stores the most recent match and sub-pattern matches
after conditional pattern matches that match and after variables expansions
using the operators
.BR # ,
.BR % ,
or
.BR / .
The
.BR 0 "th element"
stores the complete match and the
.IR i th
element stores the \fIi\fRth
sub-match. The \fB\&.sh.match\fR variable is unset when the variable that
has expanded is assigned a new value.
.RE

.sp
.ne 2
.mk
.na
\fB\&.sh.name\fR
.ad
.RS 19n
.rt
Set to the name of the variable at the time that a discipline function is
invoked.
.RE

.sp
.ne 2
.mk
.na
\fB\&.sh.subscript\fR
.ad
.RS 19n
.rt
Set to the name subscript of the variable at the time that a discipline
function is invoked.
.RE

.sp
.ne 2
.mk
.na
\fB\&.sh.subshell\fR
.ad
.RS 19n
.rt
The current depth for sub-shells and command substitution.
.RE

.sp
.ne 2
.mk
.na
\fB\&.sh.value\fR
.ad
.RS 19n
.rt
Set to the value of the variable at the time that the set or append
discipline function is invoked.
.RE

.sp
.ne 2
.mk
.na
\fB\&.sh.version\fR
.ad
.RS 19n
.rt
Set to a value that identifies the version of this shell.
.RE

.sp
.ne 2
.mk
.na
.B LINENO
.ad
.RS 19n
.rt
The current line number within the script or function being executed.
.RE

.sp
.ne 2
.mk
.na
.B OLDPWD
.ad
.RS 19n
.rt
The previous working directory set by the
.B cd
command.
.RE

.sp
.ne 2
.mk
.na
.B OPTARG
.ad
.RS 19n
.rt
The value of the last option argument processed by the
.BR getopts
built-in command.
.RE

.sp
.ne 2
.mk
.na
.B OPTIND
.ad
.RS 19n
.rt
The index of the last option argument processed by the
.BR getopts
built-in command.
.RE

.sp
.ne 2
.mk
.na
.B PPID
.ad
.RS 19n
.rt
The process number of the parent of the shell.
.RE

.sp
.ne 2
.mk
.na
.B PWD
.ad
.RS 19n
.rt
The present working directory set by the
.B cd
command.
.RE

.sp
.ne 2
.mk
.na
.B RANDOM
.ad
.RS 19n
.rt
Each time this variable is referenced, a random integer, uniformly
distributed between
.B 0
and
.BR 32767 ,
is generated. The sequence of
random numbers can be initialized by assigning a numeric value to
.BR RANDOM .
.RE

.sp
.ne 2
.mk
.na
.B REPLY
.ad
.RS 19n
.rt
This variable is set by the
.B select
statement and by the
.BR read
built-in command when no arguments are supplied.
.RE

.sp
.ne 2
.mk
.na
.B SECONDS
.ad
.RS 19n
.rt
Each time this variable is referenced, the number of seconds since shell
invocation is returned. If this variable is assigned a value, then the value
returned upon reference is the value that was assigned plus the number of
seconds since the assignment.
.RE

.sp
.LP
The following variables are used by the shell:
.sp
.ne 2
.mk
.na
.B CDPATH
.ad
.RS 14n
.rt
Defines the search path for the
.B cd
command.
.RE

.sp
.ne 2
.mk
.na
.B COLUMNS
.ad
.RS 14n
.rt
Defines the width of the edit window for the shell edit modes and for
printing select lists.
.RE

.sp
.ne 2
.mk
.na
.B EDITOR
.ad
.RS 14n
.rt
If the
.B VISUAL
variable is not set, the value of this variable is
checked for the patterns as described with
.B VISUAL
and the
corresponding editing option is turned on.
.sp
See the
.B set
command in the
.B "Special Command"
section of this
manual page.
.RE

.sp
.ne 2
.mk
.na
.B ENV
.ad
.RS 14n
.rt
Performs parameter expansion, command substitution, and arithmetic
substitution on the value to generate the pathname of the script that is
executed when the shell is invoked. This file is typically used for alias
and function definitions. The default value is
.BR $HOME/.kshrc .
.sp
See the
.B Invocation
section of this manual page.
.sp
.B ENV
is not set by the shell.
.RE

.sp
.ne 2
.mk
.na
.B FCEDIT
.ad
.RS 14n
.rt
Obsolete name for the default editor name for the
.B hist
command.
.B FCEDIT
is not used when
.B HISTEDIT
is set.
.sp
The shell specifies a default value to
.BR FCEDIT .
.RE

.sp
.ne 2
.mk
.na
.B FIGNORE
.ad
.RS 14n
.rt
A pattern that defines the set of file names that is ignored when
performing file name matching.
.RE

.sp
.ne 2
.mk
.na
.B FPATH
.ad
.RS 14n
.rt
The search path for function definitions. The directories in this path are
searched for a file with the same name as the function or command when a
function with the
.B -u
attribute is referenced and when a command is not
found. If an executable file with the name of that command is found, then it
is read and executed in the current environment. Unlike
.BR PATH ,
the
current directory must be represented explicitly by dot (\fB\&.\fR) rather
than by adjacent colon
.RB ( : )
characters or a beginning or ending colon
.RB ( : ).
.RE

.sp
.ne 2
.mk
.na
.B HISTCMD
.ad
.RS 14n
.rt
The number of the current command in the history file.
.RE

.sp
.ne 2
.mk
.na
.B HISTEDIT
.ad
.RS 14n
.rt
The name for the default editor name for the
.B hist
command.
.RE

.sp
.ne 2
.mk
.na
.B HISTFILE
.ad
.RS 14n
.rt
If this variable is set when the shell is invoked, the value is the
pathname of the file that is used to store the command history. See the
.B Command Re-entry
section of this manual page.
.RE

.sp
.ne 2
.mk
.na
.B HISTSIZE
.ad
.RS 14n
.rt
If this variable is set when the shell is invoked, then the number of
previously entered commands that are accessible by this shell is greater
than or equal to this number. The default is
.BR 512 .
.RE

.sp
.ne 2
.mk
.na
.B HOME
.ad
.RS 14n
.rt
The default argument (home directory) for the
.B cd
command.
.sp
.B HOME
is not set by the shell.
.B HOME
is set by
.BR login (1).
.RE

.sp
.ne 2
.mk
.na
.B IFS
.ad
.RS 14n
.rt
Internal field separators, normally SPACE, TAB, and NEWLINE that are used
to separate the results of command substitution or parameter expansion and
to separate fields with the built-in command read. The first character of
the \fBIFS\fR variable is used to separate arguments for the \fB"$*"\fR
substitution. See the
.B Quoting
section of this manual page.
.sp
Each single occurrence of an
.B IFS
character in the string to be split,
that is not in the
.B issspace
character class, and any adjacent
characters in
.B IFS
that are in the
.B issspace
character class,
delimit a field. One or more characters in IFS that belong to the
.B issspace
character class, delimit a field. In addition, if the same
.B issspace
character appears consecutively inside
.BR IFS ,
this
character is treated as if it were not in the
.B issspace
class, so that
if
.B IFS
consists of two tab characters, then two adjacent tab
characters delimit a null field.
.sp
The shell specifies a default value to
.BR IFS .
.RE

.sp
.ne 2
.mk
.na
.B LANG
.ad
.RS 14n
.rt
This variable determines the locale category for any category not
specifically selected with a variable starting with
.B LC_
or
.BR LANG .
.RE

.sp
.ne 2
.mk
.na
.B LC_ALL
.ad
.RS 14n
.rt
This variable overrides the value of the
.B LANG
variable and any other
.B LC_
variable.
.RE

.sp
.ne 2
.mk
.na
.B LC_COLLATE
.ad
.RS 14n
.rt
This variable determines the locale category for character collation
information.
.RE

.sp
.ne 2
.mk
.na
.B LC_CTYPE
.ad
.RS 14n
.rt
This variable determines the locale category for character handling
functions. It determines the character classes for pattern matching. See the
.B File Name Generation
section of this manual page.
.RE

.sp
.ne 2
.mk
.na
.B LC_NUMERIC
.ad
.RS 14n
.rt
This variable determines the locale category for the decimal point
character.
.RE

.sp
.ne 2
.mk
.na
.B LINES
.ad
.RS 14n
.rt
If this variable is set, the value is used to determine the column length
for printing select lists. Select lists prints vertically until about
two-thirds of
.B LINES
lines are filled.
.RE

.sp
.ne 2
.mk
.na
.B MAIL
.ad
.RS 14n
.rt
If this variable is set to the name of a mail file
.B and
the
.B MAILPATH
variable is not set, then the shell informs the user of
arrival of mail in the specified file.
.sp
.B MAIL
is not set by the shell. On some systems,
.B MAIL
is set by
.BR login (1).
.RE

.sp
.ne 2
.mk
.na
.B MAILCHECK
.ad
.RS 14n
.rt
Specifies how often in seconds the shell checks for changes in the
modification time of any of the files specified by the
.B MAILPATH
or
.B MAIL
variables. The default value is
.B 600
seconds. When the time
has elapsed the shell checks before issuing the next prompt.
.sp
The shell specifies a default value to
.BR MAILCHECK .
.RE

.sp
.ne 2
.mk
.na
.B MAILPATH
.ad
.RS 14n
.rt
A colon (
.B :
) separated list of file names. If this variable is set,
then the shell informs the user of any modifications to the specified files
that have occurred within the last
.B MAILCHECK
seconds. Each file name
can be followed by a
.B ?
and a message that is printed. The message
undergoes parameter expansion, command substitution, and arithmetic
substitution with the variable
.B $_
defined as the name of the file that
has changed. The default message is
.BR "you have mail in $_" .
.RE

.sp
.ne 2
.mk
.na
.B PATH
.ad
.RS 14n
.rt
The search path for commands. Except in \fB\&.profile\fR, users cannot
change
.B PATH
if executing under
.BR rksh93 .
See the
.BR Execution
section of this manual page.
.sp
The shell specifies a default value to
.BR PATH .
.RE

.sp
.ne 2
.mk
.na
.B PS1
.ad
.RS 14n
.rt
The value of this variable is expanded for parameter expansion, command
substitution, and arithmetic substitution to define the primary prompt
string which by default is
.BR $ .
The character
.B !
in the primary
prompt string is replaced by the command number. Two successive occurrences
of
.B !
produces a single
.B !
when the prompt string is printed. See
the
.B "Command Re-entry"
section of this manual page.
.sp
The shell specifies a default value to
.BR PS1 .
.RE

.sp
.ne 2
.mk
.na
.B PS2
.ad
.RS 14n
.rt
Secondary prompt string, by default,
.BR > .
.sp
The shell specifies a default value to
.BR PS2 .
.RE

.sp
.ne 2
.mk
.na
.B PS3
.ad
.RS 14n
.rt
Selection prompt string used within a select loop, by default
.BR #? .
.sp
The shell specifies a default value to
.BR PS3 .
.RE

.sp
.ne 2
.mk
.na
.B PS4
.ad
.RS 14n
.rt
The value of this variable is expanded for parameter evaluation, command
substitution, and arithmetic substitution and precedes each line of an
execution trace. By default,
.B PS4
is
.BR + .
When
.B PS4
is unset,
the execution trace prompt is also
.B +
\&.
.sp
The shell specifies a default value to
.BR PS4 .
.RE

.sp
.ne 2
.mk
.na
.B SHELL
.ad
.RS 14n
.rt
The pathname of the shell is kept in the environment. At invocation, if the
basename of this variable is
.BR rsh ,
.BR rksh ,
.BR rksh93 ,
or
.BR krsh ,
the shell becomes restricted.
.sp
.B SHELL
is not set by the shell. On some systems,
.B SHELL
is set by
.BR login (1).
.RE

.sp
.ne 2
.mk
.na
.B TIMEFORMAT
.ad
.RS 14n
.rt
The value of this parameter is used as a format string specifying how the
timing information for pipelines prefixed with the
.B time
reserved word
should be displayed. The
.B %
character introduces a format sequence that
is expanded to a time value or other information.
.sp
The format sequences and their meanings are as follows.
.sp
.ne 2
.mk
.na
.B %%
.ad
.sp .6
.RS 4n
A literal
.BR % .
.RE

.sp
.ne 2
.mk
.na
\fB%[\fIp\fR][l]R\fR
.ad
.sp .6
.RS 4n
The elapsed time in seconds.
.RE

.sp
.ne 2
.mk
.na
\fB%[\fIp\fR][l]U\fR
.ad
.sp .6
.RS 4n
The number of CPU seconds spent in user mode.
.RE

.sp
.ne 2
.mk
.na
\fB%[\fIp\fR][l]S\fR
.ad
.sp .6
.RS 4n
The number of CPU seconds spent in system mode.
.RE

.sp
.ne 2
.mk
.na
.B %P
.ad
.sp .6
.RS 4n
The CPU percentage, computed as
.BR "(U + S) / R" .
.RE

The braces denote optional portions. The optional
.I p
is a digit
specifying the
.IR precision ,
the number of fractional digits after a
decimal point. A value of
.B 0
causes no decimal point or fraction to be
output. At most three places after the decimal point can be displayed.
Values of
.I p
greater than
.B 3
are treated as
.BR 3 .
If
.I p
is
not specified, the value
.B 3
is used.
.sp
The optional
.B l
specifies a longer format, including hours if greater
than zero, minutes, and seconds of the form
.IR HHhMMmSS.FFs .
The value of
.I p
determines whether or not the fraction is included.
.sp
All other characters are output without change and a trailing NEWLINE is
added. If unset, the default value,
\fB$'\enreal\et%2lR\enuser\et%2lU\ensys\et%2lS'\fR, is used. If the value is
null,
no timing information is displayed.
.RE

.sp
.ne 2
.mk
.na
.B TMOUT
.ad
.RS 14n
.rt
If set to a value greater than zero,
.B TMOUT
is the default time-out
value for the
.B read
built-in command. The
.B select
compound command
terminates after
.B TMOUT
seconds when input is from a terminal.
Otherwise, the shell terminates if a line is not entered within the
prescribed number of seconds while reading from a terminal. The shell can be
compiled with a maximum bound for this value which cannot be exceeded.
.sp
The shell specifies a default value to
.BR TMOUT .
.RE

.sp
.ne 2
.mk
.na
.B VISUAL
.ad
.RS 14n
.rt
If the value of this variable matches the pattern
.BR *[Vv][Ii]* ,
then
the
.B vi
option is turned on. See
.BR "Special Commands" .
If the value
matches the pattern
.B *gmacs*
, the
.B gmacs
option is turned on. If
the value matches the pattern
.BR *macs* ,
then the
.B emacs
option is
turned on. The value of
.B VISUAL
overrides the value of
.BR EDITOR .
.RE

.SS "Field Splitting"
.sp
.LP
After parameter expansion and command substitution, the results of
substitutions are scanned for the field separator characters (those found in
.BR IFS )
and split into distinct fields where such characters are found.
Explicit null fields (\fB""\fR or \fB\&''\fR) are retained. Implicit null
fields, those resulting from parameters that have no values or command
substitutions with no output, are removed.
.sp
.LP
If the
.B braceexpand
.RB ( -B )
option is set, each of the fields
resulting from
.B IFS
are checked to see if they contain one or more of
the brace patterns. Valid brace patterns:
.BR {* ,\fB*}\fR,
\fB{\fIl1\fB\&..\fIl2\fB}\fR ,
\fB{\fIn1\fB\&..\fIn2\fB}\fR, \fB{\fIn1\fB\&..\fIn2\fB%\fIfmt\fB} {\fIn1\fB\&..\fIn2\fR \fB\&..\fIn3\fB}\fR, or
\fB{\fIn1\fB\&..\fIn2\fR \fB\&..\fIn3\fB%\fIfmt\fB}\fR
, where
.B *
represents any character, \fIl1\fR,\fIl2\fR are letters and
\fIn1\fR,\fIn2\fR,\fIn3\fR are signed numbers and
.I fmt
is a format
specified as used by
.BR printf .
In each case, fields are created by
prepending the characters before the
.BR { " and appending the characters"
after the } to each of the strings generated by the characters between the
.B {
and
.BR } .
The resulting fields are checked to see if they have
any brace patterns.
.sp
.LP
In the first form, a field is created for each string between
.B {
and
.B ,,
between
.B ,
and
.B ,,
and between , and
.BR } .
The string
represented by
.B *
can contain embedded matching { and } without
quoting. Otherwise, each
.B {
and
.B }
with
.B *
must be quoted.
.sp
.LP
In the second form,
.I l1
and
.I l2
must both be either upper case or
both be lower case characters in the C locale. In this case a field is
created for each character from
.I l1
through
.IR l2 .
.sp
.LP
In the remaining forms, a field is created for each number starting at
.IR n1 .
This continues until it reaches
.I n2
and increments
.IR n1
by
.IR n3 .
The cases where
.I n3
is not specified behave as if
.IR n3
were 1 if \fIn1\fB<=\fIn2\fR, and
.B -1
otherwise. In forms which
specify \fB%\fIfmt\fR, any format flags, widths and precisions can be
specified and
.I fmt
can end in any of the specifiers
.BR cdiouxX .
For
example, \fB{a,z}{1..5..3%02d}{b..c}x\fR expands to the 8 fields, \fBa01bx, a01cx, a04bx, a04cx, z01bx, z01cx, z04bx,\fR and
.BR z4cx .
.SS "File Name Generation"
.sp
.LP
Following splitting, each field is scanned for the characters
.BR * ,
.BR ? ,
.BR ( ,
and
.BR [ ,
unless the
.B -f
option has been set. If
one of these characters appears, then the word is regarded as a pattern.
.sp
.LP
Each file name component that contains any pattern character is replaced
with a lexicographically sorted set of names that matches the pattern from
that directory. If no file name is found that matches the pattern, then that
component of the file name is left unchanged unless the pattern is prefixed
with
.B ~(N)
in which case it is removed. If
.B FIGNORE
is set, then
each file name component that matches the pattern defined by the value of
.B FIGNORE
is ignored when generating the matching file names. The names
\fB\&.\fR and \fB\&..\fR are also ignored. If
.B FIGNORE
is not set, the
character \fB\&.\fR at the start of each file name component is ignored
unless the first character of the pattern corresponding to this component is
the character \fB\&.\fR itself. For other uses of pattern matching the
.B /
and \fB\&.\fR are not specially treated.
.sp
.ne 2
.mk
.na
.B *
.ad
.RS 11n
.rt
Match any string, including the null string. When used for file name
expansion, if the
.B globstar
option is on, two adjacent
.BR * s
by
themselves match all files and zero or more directories and subdirectories.
If the two adjacent
.BR * s
are followed by a
.BR / ,
only directories and
subdirectories match.
.RE

.sp
.ne 2
.mk
.na
.B ?
.ad
.RS 11n
.rt
Matches any single character.
.RE

.sp
.ne 2
.mk
.na
\fB[\&.\|.\|.\fR]\fR
.ad
.RS 11n
.rt
Match any one of the enclosed characters. A pair of characters separated by
.B -
matches any character lexically between the pair, inclusive. If the
first character following the opening
.B [
is a
.BR ! ,
any character
not enclosed is matched. A
.B -
can be included in the character set by
putting it as the first or last character. Within
.B [
and
.BR ] ,
character classes can be specified with the syntax
\fB[:\fIclass\fB:]\fR where
.I class
is one of the following
classes defined in the
.B ANSI-C
standard:
.sp
.in +2
.nf
\fIalnum alpha blank cntrl digit graph
lower print punct space upper
word xdigit\fR
.fi
.in -2
.sp

.I word
is equivalent to
.I alnum
plus the character
.BR _ .
Within
.B [
and
.BR ] ,
an equivalence class can be specified with the syntax
\fB[=\fIc\fB=]\fR which matches all characters with the same primary
collation weight (as defined by the current locale) as the character
.IR c .
Within
.B [
and \fB]\fR, [\fI\&.symbol.\fR] matches the
collating symbol
.IR symbol .
.RE

.sp
.LP
A
.I pattern-list
is a list of one or more patterns separated from each
other with an
.B &
or
.BR | .
An
.B &
signifies that all patterns
must be matched whereas
.B |
requires that only one pattern be matched.
Composite patterns can be formed with one or more of the following
sub-patterns:
.sp
.ne 2
.mk
.na
\fB?(\fIpattern-list\fB)\fR
.ad
.RS 22n
.rt
Optionally matches any one of the specified patterns.
.RE

.sp
.ne 2
.mk
.na
\fB*(\fIpattern-list\fB)\fR
.ad
.RS 22n
.rt
Matches zero or more occurrences of the specified patterns.
.RE

.sp
.ne 2
.mk
.na
\fB+(\fIpattern-list\fB)\fR
.ad
.RS 22n
.rt
Matches one or more occurrences of the specified patterns.
.RE

.sp
.ne 2
.mk
.na
\fB{\fIn\fB(\fIpattern-list\fB)\fR
.ad
.RS 22n
.rt
Matches
.I n
occurrences of the specified patterns.
.RE

.sp
.ne 2
.mk
.na
\fB{\fIm\fB,\fIn\fB(\fIpattern-list\fB)\fR
.ad
.RS 22n
.rt
Matches from
.I m
to
.I n
occurrences of the specified patterns. If
.I m
is omitted,
.B 0
is used. If
.I n
is omitted at least
.IR m
occurrences are matched.
.RE

.sp
.ne 2
.mk
.na
\fB@(\fIpattern-list\fB)\fR
.ad
.RS 22n
.rt
Matches exactly one of the specified patterns.
.RE

.sp
.ne 2
.mk
.na
\fB!(\fIpattern-list\fB)\fR
.ad
.RS 22n
.rt
Matches anything except one of the specified patterns.
.RE

.sp
.LP
By default, each pattern, or sub-pattern matches the longest string
possible consistent with generating the longest overall match. If more than
one match is possible, the one starting closest to the beginning of the
string is chosen. However, for each of the compound patterns a
.B -
can
be inserted in front of the
.B (
to cause the shortest match to the
specified
.I pattern-list
to be used.
.sp
.LP
When
.I pattern-list
is contained within parentheses, the backslash
character \fB\e\fR is treated specially even when inside a character class.
All
.B ANSI-C
character escapes are recognized and match the specified
character. In addition the following escape sequences are recognized:
.sp
.ne 2
.mk
.na
\fB\ed\fR
.ad
.RS 7n
.rt
Matches any character in the digit class.
.RE

.sp
.ne 2
.mk
.na
\fB\eD\fR
.ad
.RS 7n
.rt
Matches any character not in the digit class.
.RE

.sp
.ne 2
.mk
.na
\fB\es\fR
.ad
.RS 7n
.rt
Matches any character in the space class.
.RE

.sp
.ne 2
.mk
.na
\fB\eS\fR
.ad
.RS 7n
.rt
Matches any character not in the space class.
.RE

.sp
.ne 2
.mk
.na
\fB\ew\fR
.ad
.RS 7n
.rt
Matches any character in the word class.
.RE

.sp
.ne 2
.mk
.na
\fB\eW\fR
.ad
.RS 7n
.rt
Matches any character not in the word class.
.RE

.sp
.LP
A pattern of the form \fB%(\fIpattern-pairs\fB)\fR is a sub-pattern
that can be used to match nested character expressions. Each
.I pattern-pair
is a two character sequence which cannot contain
.BR &
or
.BR | .
The first
.I pattern-pair
specifies the starting and ending
characters for the match. Each subsequent
.I pattern-pair
represents the
beginning and ending characters of a nested group that is skipped over when
counting starting and ending character matches. The behavior is unspecified
when the first character of a
.I pattern-pair
is alphanumeric except for
the following:
.sp
.ne 2
.mk
.na
.B D
.ad
.RS 5n
.rt
Causes the ending character to terminate the search for this pattern
without finding a match.
.RE

.sp
.ne 2
.mk
.na
.B E
.ad
.RS 5n
.rt
Causes the ending character to be interpreted as an escape character.
.RE

.sp
.ne 2
.mk
.na
.B L
.ad
.RS 5n
.rt
Causes the ending character to be interpreted as a quote character causing
all characters to be ignored when looking for a match.
.RE

.sp
.ne 2
.mk
.na
.B Q
.ad
.RS 5n
.rt
Causes the ending character to be interpreted as a quote character causing
all characters other than any escape character to be ignored when looking
for a match.
.RE

.sp
.LP
\fB%({}Q"E\e)\fR, matches characters starting at \fB{\fR until the matching
.B }
is found not counting any
.B {
or
.B }
that is inside a double
quoted string or preceded by the escape character \fB\e\fR\&. Without the
.B {}
this pattern matches any C language string.
.sp
.LP
Each sub-pattern in a composite pattern is numbered, starting at
.BR 1 ,
by the location of the
.B (
within the pattern. The sequence
\fB\e\fIn\fR, where
.I n
is a single digit and \fB\e\fIn\fR comes
after the
.IR n "th. sub-pattern, matches the same string as the sub-pattern"
itself.
.sp
.LP
A pattern can contain sub-patterns of the form
\fB~(\fIoptions\fB:\fIpattern-list\fB)\fR, where either
\fIoptions\fR or \fB:\fIpattern-list\fR can be omitted. Unlike the other
compound patterns, these sub-patterns are not counted in the numbered
sub-patterns. If
.I options
is present, it can consist of one or more of
the following:
.sp
.ne 2
.mk
.na
.B +
.ad
.RS 5n
.rt
Enable the following options. This is the default.
.RE

.sp
.ne 2
.mk
.na
.B -
.ad
.RS 5n
.rt
Disable the following options.
.RE

.sp
.ne 2
.mk
.na
.B E
.ad
.RS 5n
.rt
The remainder of the pattern uses extended regular expression syntax like
the
.BR egrep (1)
command.
.RE

.sp
.ne 2
.mk
.na
.B F
.ad
.RS 5n
.rt
The remainder of the pattern uses
.BR fgrep (1)
expression syntax.
.RE

.sp
.ne 2
.mk
.na
.B g
.ad
.RS 5n
.rt
File the longest match (greedy).
.sp
This is the default.
.RE

.sp
.ne 2
.mk
.na
.B G
.ad
.RS 5n
.rt
The remainder of the pattern uses basic regular expression syntax like the
.BR grep (1)
command.
.RE

.sp
.ne 2
.mk
.na
.B i
.ad
.RS 5n
.rt
Treat the match as case insensitive.
.RE

.sp
.ne 2
.mk
.na
.B K
.ad
.RS 5n
.rt
The remainder of the pattern uses shell pattern syntax.
.sp
This is the default.
.RE

.sp
.ne 2
.mk
.na
.B l
.ad
.RS 5n
.rt
Left anchor the pattern.
.sp
This is the default for
.B K
style patterns.
.RE

.sp
.ne 2
.mk
.na
.B N
.ad
.RS 5n
.rt
This is ignored. However, when it is the first letter and is used with file
name generation, and no matches occur, the file pattern expands to the empty
string.
.RE

.sp
.ne 2
.mk
.na
.B r
.ad
.RS 5n
.rt
Right anchor the pattern.
.sp
This is the default for
.B K
style patterns.
.RE

.sp
.LP
If both
.I options
and \fB:\fIpattern-list\fR are specified, then the
options apply only to
.IR pattern-list .
Otherwise, these options remain in
effect until they are disabled by a subsequent \fB~(.\|.\|.)\fR or at the end of
the sub-pattern containing
.BR ~(.\|.\|.) .
.SS "Quoting"
.sp
.LP
Each of the metacharacters listed in the
.B Definitions
has a special
meaning to the shell.
.sp
.ne 2
.mk
.na
.B g
.ad
.RS 5n
.rt
File the longest match (greedy). This is the default.
.RE

.sp
.ne 2
.mk
.na
.B i
.ad
.RS 5n
.rt
Treat the match as case insensitive.
.RE

.sp
.LP
If both
.I options
and \fB:\fIpattern-list\fR are specified, then the
options apply only to
.IR pattern-list .
Otherwise, the options remain in
effect until they are disabled by a subsequent \fB~(.\|.\|.)\fR or at the end of
the sub-pattern containing
.BR ~(.\|.\|.) .
.sp
.LP
Each of the metacharacters listed in the
.B Definitions
section of this
manual page has a special meaning to the shell and causes termination of a
word unless quoted. A character can be quoted, that is, made to stand for
itself, by preceding it with a backslash (\fB\e\fR). The pair
\fB\e\fRNEWLINE is removed. All characters enclosed between a pair of single
quote marks (\fB\&''\fR) that is not preceded by a
.B $
are quoted. A
single quote cannot appear within the single quotes. A single quoted string
preceded by an unquoted
.B $
is processed as an
.B ANSI-C
string
except for the following:
.sp
.ne 2
.mk
.na
\fB\e0\fR
.ad
.RS 19n
.rt
Causes the remainder of the string to be ignored.
.RE

.sp
.ne 2
.mk
.na
\fB\ec\fIx\fR
.ad
.RS 19n
.rt
Expands to the character CTRL-x.
.RE

.sp
.ne 2
.mk
.na
\fB\eC\fR[\fB\&.\fIname\fB\&.\fR]\fR
.ad
.RS 19n
.rt
Expands to the collating element
.IR name .
.RE

.sp
.ne 2
.mk
.na
\fB\ee\fR
.ad
.RS 19n
.rt
Equivalent to the escape character (\fBASCII\fR 033),
.RE

.sp
.ne 2
.mk
.na
\fB\eE\fR
.ad
.RS 19n
.rt
Equivalent to the escape character (\fBASCII\fR 033),
.RE

.sp
.LP
Inside double quote marks (\fB""\fR), parameter and command substitution
occur and \fB\e\fR quotes the characters \fB\e\fR, \fB`\fR, \fB"\fR, and
.BR $ .
A
.B $
in front of a double quoted string is ignored in the
.B C
or
.B POSIX
locale, and might cause the string to be replaced by
a locale specific string otherwise. The meaning of
.B $*
and
.B $@
is
identical when not quoted or when used as a variable assignment value or as
a file name. However, when used as a command argument, \fB"$*"\fR is
equivalent to \fB"$1\fId\fR$2\fId\fR.\|.\|."\fR, where \fId\fR is the first
character of the IFS variable, whereas \fB"$@"\fR is equivalent to \fB"$1"
"$2" ....\fR Inside grave quote marks (\fB``\fR), \fB\efR quotes the
characters
.BR \e ,
.BR ` ,
and
.BR $ .
If the grave quotes occur within
double quotes, then \fB\e\fR also quotes the character \fB"\fR.
.sp
.LP
The special meaning of reserved words or aliases can be removed by quoting
any character of the reserved word. The recognition of function names or
built-in command names cannot be altered by quoting them.
.SS "Arithmetic Evaluation"
.sp
.LP
The shell performs arithmetic evaluation for arithmetic substitution, to
evaluate an arithmetic command, to evaluate an indexed array subscript, and
to evaluate arguments to the built-in commands
.B shift
and
.BR let .
Arithmetic evaluation is also performed on argument operands of the built-in
command printf that correspond to numeric format specifiers in the format
operand. See
.BR printf (1).
Evaluations are performed using double
precision floating point arithmetic or long double precision floating point
for systems that provide this data type. Floating point constants follow the
.B ANSI-C
programming language floating point conventions. Integer
constants follow the
.B ANSI-C
programming language integer constant
conventions although only single byte character constants are recognized and
character casts are not recognized. Constants can be of the form
\fB[\fIbase#\fB]\fIn\fR where
.I base
is a decimal number
between two and sixty-four representing the arithmetic base and
.I n
is a
number in that base. The digits greater than
.B 9
are represented by the
lower case letters, the upper case letters,
.BR @ ,
and
.BR _
respectively. For bases less than or equal to
.BR 36 ,
upper and lower case
characters can be used interchangeably.
.sp
.LP
An arithmetic expression uses the same syntax, precedence, and
associativity of expression as the C language. All the C language operators
that apply to floating point quantities can be used. In addition, the
operator
.B **
can be used for exponentiation. It has higher precedence
than multiplication and is left associative. When the value of an arithmetic
variable or subexpression can be represented as a long integer, all C
language integer arithmetic operations can be performed. Variables can be
referenced by name within an arithmetic expression without using the
parameter expansion syntax. When a variable is referenced, its value is
evaluated as an arithmetic expression.
.sp
.LP
Any of the following math library functions that are in the C math library
can be used within an arithmetic expression:
.sp
.in +2
.nf
abs acos acosh asin asinh atan atan2 atanh cbrt
copysign cos cosh erf erfc exp exp2 expm1 fabs
fdim finite floor fma fmax fmod hypot ilogb
int isinf isnan lgamma log log2 logb
nearbyint nextafter nexttoward pow remainder
rint round sin sinh sqrt tan tanh tgamma trunc
.fi
.in -2
.sp

.sp
.LP
An internal representation of a
.I variable
as a double precision
floating point can be specified with the \fB-E [\fIn\fB]\fR or \fB-F [\fIn\fB]\fR option of the \fBtypeset\fR special built-in command. The
.B -E
option causes the expansion of the value to be represented using
scientific notation when it is expanded. The optional option argument
.I n
defines the number of significant figures. The
.B -F
option
causes the expansion to be represented as a floating decimal number when it
is expanded. The optional option argument
.I n
defines the number of
places after the decimal point in this case.
.sp
.LP
An internal integer representation of a
.I variable
can be specified
with the \fB-i\fR \fB[\fIn\fB]\fR option of the
.B typeset
special
built-in command. The optional option argument
.I n
specifies an
arithmetic base to be used when expanding the variable. If you do not
specify an arithmetic base, base 10 is used.
.sp
.LP
Arithmetic evaluation is performed on the value of each assignment to a
variable with the
.BR -E ,
.BR -F ,
or
.B -i
option. Assigning a
floating point number to a variable whose type is an integer causes the
fractional part to be truncated.
.SS "Prompting"
.sp
.LP
When used interactively, the shell prompts with the value of
.B PS1
after expanding it for parameter expansion, command substitution, and
arithmetic substitution, before reading a command. In addition, each single
.B !
in the prompt is replaced by the command number. A
.B !!
is
required to place
.B !
in the prompt. If at any time a NEWLINE is typed
and further input is needed to complete a command, then the secondary
prompt, that is, the value of
.BR PS2 ,
is issued.
.SS "Conditional Expressions"
.sp
.LP
A
.BR "conditional expression" " is used with the "
.B [[
compound command
to test attributes of files and to compare strings. Field splitting and file
name generation are not performed on the words between
.B [[
and
.BR ]] .
.sp
.LP
Each expression can be constructed from one or more of the following unary
or binary expressions:
.sp
.ne 2
.mk
.na
.B -a
.I file
.ad
.RS 21n
.rt
True, if
.I file
exists.
.sp
This option is the same as
.BR -e .
This option is obsolete.
.RE

.sp
.ne 2
.mk
.na
.B -b
.I file
.ad
.RS 21n
.rt
True, if
.I file
exists and is a block special file.
.RE

.sp
.ne 2
.mk
.na
.B -c
.I file
.ad
.RS 21n
.rt
True, if
.I file
exists and is a character special file.
.RE

.sp
.ne 2
.mk
.na
.B -d
.I file
.ad
.RS 21n
.rt
True, if
.I file
exists and is a directory.
.RE

.sp
.ne 2
.mk
.na
.B -e
.I file
.ad
.RS 21n
.rt
True, if
.I file
exists.
.RE

.sp
.ne 2
.mk
.na
.B -f
.I file
.ad
.RS 21n
.rt
True, if
.I file
exists and is an ordinary file.
.RE

.sp
.ne 2
.mk
.na
.B -g
.I file
.ad
.RS 21n
.rt
True, if
.I file
exists and it has its
.B setgid
bit set.
.RE

.sp
.ne 2
.mk
.na
.B -G
.I file
.ad
.RS 21n
.rt
True, if
.I file
exists and its group matches the effective group id of
this process.
.RE

.sp
.ne 2
.mk
.na
.B -h
.I file
.ad
.RS 21n
.rt
True, if
.I file
exists and is a symbolic link.
.RE

.sp
.ne 2
.mk
.na
.B -k
.I file
.ad
.RS 21n
.rt
True, if
.I file
exists and it has its sticky bit set.
.RE

.sp
.ne 2
.mk
.na
.B -L
.I file
.ad
.RS 21n
.rt
True, if
.I file
exists and is a symbolic link.
.RE

.sp
.ne 2
.mk
.na
.B -n
.I string
.ad
.RS 21n
.rt
True, if length of
.I string
is
.BR non-zero .
.RE

.sp
.ne 2
.mk
.na
.B -N
.I file
.ad
.RS 21n
.rt
True, if
.I file
exists and the modification time is greater than the
last access time.
.RE

.sp
.ne 2
.mk
.na
.B -o
.I option
.ad
.RS 21n
.rt
True, if option named
.I option
is on.
.RE

.sp
.ne 2
.mk
.na
.B -o
.I ?option
.ad
.RS 21n
.rt
True, if option named
.I option
is a valid option name.
.RE

.sp
.ne 2
.mk
.na
.B -O
.I file
.ad
.RS 21n
.rt
True, if
.I file
exists and is owned by the effective user id of this
process.
.RE

.sp
.ne 2
.mk
.na
.B -p
.I file
.ad
.RS 21n
.rt
True, if
.IR file " exists and is a "
.B FIFO
special file or a pipe.
.RE

.sp
.ne 2
.mk
.na
.B -r
.I file
.ad
.RS 21n
.rt
True, if
.I file
exists and is readable by current process.
.RE

.sp
.ne 2
.mk
.na
.B -s
.I file
.ad
.RS 21n
.rt
True, if
.I file
exists and has size greater than zero.
.RE

.sp
.ne 2
.mk
.na
.B -S
.I file
.ad
.RS 21n
.rt
True, if
.I file
exists and is a socket.
.RE

.sp
.ne 2
.mk
.na
.B -t
.I fildes
.ad
.RS 21n
.rt
True, if file descriptor number
.I fildes
is open and associated with a
terminal device.
.RE

.sp
.ne 2
.mk
.na
.B -u
.I file
.ad
.RS 21n
.rt
True, if
.I file
exists and it has its
.B setuid
bit set.
.RE

.sp
.ne 2
.mk
.na
.B -w
.I file
.ad
.RS 21n
.rt
True, if
.I file
exists and is writable by current process.
.RE

.sp
.ne 2
.mk
.na
.B -x
.I file
.ad
.RS 21n
.rt
True, if
.I file
exists and is executable by current process. If
.I file
exists and is a directory, then true if the current process has
permission to search in the directory.
.RE

.sp
.ne 2
.mk
.na
.B -z
.I string
.ad
.RS 21n
.rt
True, if length of
.I string
is zero.
.RE

.sp
.ne 2
.mk
.na
.I file1
.B -ef
.I file2
.ad
.RS 21n
.rt
True, if
.IR file1 " and "
.I file2
exist and refer to the same file.
.RE

.sp
.ne 2
.mk
.na
.I file1
.B -nt
.I file2
.ad
.RS 21n
.rt
True, if \fIfile1\fR exists and \fIfile2\fR does not, or
.I file1
is
newer than
.IR file2 .
.RE

.sp
.ne 2
.mk
.na
.I file1
.B -ot
.I file2
.ad
.RS 21n
.rt
True, if \fIfile2\fR exists and \fIfile1\fR does not, or
.I file1
is
older than
.IR file2 .
.RE

.sp
.ne 2
.mk
.na
.I string
.ad
.RS 21n
.rt
True, if
.I string
is not null.
.RE

.sp
.ne 2
.mk
.na
.I string
.B ==
.I pattern
.ad
.RS 21n
.rt
True, if
.I string
matches
.IR pattern .
Any part of
.I pattern
can
be quoted to cause it to be matched as a string. With a successful match to
.IR pattern ,
the \fB\&.sh.match\fR array variable contains the match and
sub-pattern matches.
.RE

.sp
.ne 2
.mk
.na
.I string
.B =
.I pattern
.ad
.RS 21n
.rt
Same as
.BR == ,
but is obsolete.
.RE

.sp
.ne 2
.mk
.na
.I string
.B !=
.I pattern
.ad
.RS 21n
.rt
True, if
.I string
does not match
.IR pattern .
When the
.IR string
matches the
.I pattern
the \fB\&.sh.match\fR array variable contains the
match and sub-pattern matches.
.RE

.sp
.ne 2
.mk
.na
.I string
.B =~
.I ere
.ad
.RS 21n
.rt
True if
.I string
matches the pattern \fB~(E)\fIere\fR where
.I ere
is an extended regular expression.
.RE

.sp
.ne 2
.mk
.na
.I string1
.B <
.I string2
.ad
.RS 21n
.rt
True, if
.I string1
comes before
.I string2
based on
.BR ASCII
value of their characters.
.RE

.sp
.ne 2
.mk
.na
.I string1
.B >
.I string2
.ad
.RS 21n
.rt
True, if
.I string1
comes after
.I string2
based on
.B ASCII
value
of their characters.
.RE

.sp
.LP
In each of the following expressions, if
.I file
is of the form
\fB/dev/fd/\fIn\fR, where
.I n
is an integer, the test is applied to
the open file whose descriptor number is
.IR n .
The following obsolete
arithmetic comparisons are supported:
.sp
.ne 2
.mk
.na
.I exp1
.B -eq
.I exp2
.ad
.RS 17n
.rt
True, if
.I exp1
is equal to
.IR exp2 .
.RE

.sp
.ne 2
.mk
.na
.I exp1
.B -ge
.I exp2
.ad
.RS 17n
.rt
True, if
.I exp1
is greater than or equal to
.IR exp2 .
.RE

.sp
.ne 2
.mk
.na
.I exp1
.B -gt
.I exp2
.ad
.RS 17n
.rt
True, if
.I exp1
is greater than
.IR exp2 .
.RE

.sp
.ne 2
.mk
.na
.I exp1
.B -le
.I exp2
.ad
.RS 17n
.rt
True, if
.I exp1
is less than or equal to
.IR exp2 .
.RE

.sp
.ne 2
.mk
.na
.I exp1
.B -lt
.I exp2
.ad
.RS 17n
.rt
True, if
.I exp1
is less than
.IR exp2 .
.RE

.sp
.ne 2
.mk
.na
.I exp1
.B -ne
.I exp2
.ad
.RS 17n
.rt
True, if
.I exp1
is not equal to
.IR exp2 .
.RE

.sp
.LP
A compound expression can be constructed from these primitives by using any
of the following, listed in decreasing order of precedence:
.sp
.ne 2
.mk
.na
\fB(\fIexpression\fB)\fR
.ad
.RS 30n
.rt
True, if
.I expression
is true. Used to group expressions.
.RE

.sp
.ne 2
.mk
.na
.B !
.I expression
.ad
.RS 30n
.rt
True, if
.I expression
is false.
.RE

.sp
.ne 2
.mk
.na
.I expression1
.B &&
.I expression2
.ad
.RS 30n
.rt
True, if
.I expression1
and
.I expression2
are both true.
.RE

.sp
.ne 2
.mk
.na
.I expression1
.B ||
.I expression2
.ad
.RS 30n
.rt
True, if either
.I expression1
or
.I expression2
is true.
.RE

.SS "Input and Output"
.sp
.LP
Before a command is executed, its input and output can be redirected using
a special notation interpreted by the shell. The following can appear
anywhere in a simple command or can precede or follow a command and are
.B not
passed on to the invoked command. Command substitution, parameter
expansion, and arithmetic substitution occur before
.I word
or
.I digit
is used except as noted in this section. File name generation
occurs only if the shell is interactive and the pattern matches a single
file. Field splitting is not performed.
.sp
.LP
In each of the following redirections, if
.I file
is of the form
\fB/dev/sctp/\fIhost\fB/\fIport\fR, \fB/dev/tcp/\fIhost\fB/\fIport\fR,
or \fB/dev/udp/\fIhost\fB/\fIport\fR, where
.I host
is a
hostname or host address, and
.I port
is a service specified by name or
an integer port number, then the redirection attempts to make a
.BR tcp ,
.B sctp
or
.B udp
connection to the corresponding socket.
.sp
.LP
No intervening space is allowed between the characters of redirection
operators.
.sp
.ne 2
.mk
.na
.BI < word
.ad
.RS 14n
.rt
Use file
.I word
as standard input (file descriptor 0).
.RE

.sp
.ne 2
.mk
.na
.BI > word
.ad
.RS 14n
.rt
Use file
.I word
as standard output (file descriptor 1). If the file
does not exist then it is created. If the file exists, and the
.B noclobber
option is on, this causes an error. Otherwise, it is
truncated to zero length.
.RE

.sp
.ne 2
.mk
.na
.BI >| word
.ad
.RS 14n
.rt
Same as
.BR > ,
except that it overrides the
.B noclobber
option.
.RE

.sp
.ne 2
.mk
.na
.BI >> word
.ad
.RS 14n
.rt
Use file
.I word
as standard output. If the file exists, then output is
appended to it (by first seeking to the end-of-file). Otherwise, the file is
created.
.RE

.sp
.ne 2
.mk
.na
.BI <> word
.ad
.RS 14n
.rt
Open file
.I word
for reading and writing as standard input.
.RE

.sp
.ne 2
.mk
.na
.BI <<[-] word
.ad
.RS 14n
.rt
The shell input is read up to a line that is the same as
.I word
after
any quoting has been removed, or to an end-of-file. No parameter
substitution, command substitution, arithmetic substitution or file name
generation is performed on
.IR word .
The resulting document, called a
.BR here-document ,
becomes the standard input. If any character of
.I word
is quoted, then no interpretation is placed upon the characters
of the document. Otherwise, parameter expansion, command substitution, and
arithmetic substitution occur, \fB\e\fRNEWLINE is ignored, and \fB\e\fR must
be used to quote the characters
.BR \e ,
.BR $ ,
\fB`\fR\&. If
.B -
is
appended to
.BR << ,
then all leading tabs are stripped from
.I word
and
from the document. If
.B #
is appended to
.BR << ,
then leading SPACEs
and TABs are stripped off the first line of the document and up to an
equivalent indentation is stripped from the remaining lines and from
.IR word .
A tab stop is assumed to occur at every 8 columns for the
purposes of determining the indentation.
.RE

.sp
.ne 2
.mk
.na
.BI <<< word
.ad
.RS 14n
.rt
A short form of here document in which
.I word
becomes the contents of
the here-document after any parameter expansion, command substitution, and
arithmetic substitution occur.
.RE

.sp
.ne 2
.mk
.na
.BI <& digit
.ad
.RS 14n
.rt
The standard input is duplicated from file descriptor
.IR digit ,
and
similarly for the standard output using \fB>&\fIdigit\fR. See
.BR dup (2).
.RE

.sp
.ne 2
.mk
.na
\fB<&\fIdigit\fB-\fR
.ad
.RS 14n
.rt
The file descriptor specified by
.I digit
is moved to standard input.
Similarly for the standard output using \fB>&\fIdigit\fB-\fR.
.RE

.sp
.ne 2
.mk
.na
.B <&-
.ad
.RS 14n
.rt
The standard input is closed. Similarly for the standard output using
.BR >&- .
.RE

.sp
.ne 2
.mk
.na
.B <&p
.ad
.RS 14n
.rt
The input from the co-process is moved to standard input.
.RE

.sp
.ne 2
.mk
.na
.B >&p
.ad
.RS 14n
.rt
The output to the co-process is moved to standard output.
.RE

.sp
.ne 2
.mk
.na
\fB<#((\fIexpr\fB))\fR
.ad
.RS 14n
.rt
Evaluate arithmetic expression
.I expr
and position file descriptor 0 to
the resulting value bytes from the start of the file. The variables
.B CUR
and
.B EOF
evaluate to the current offset and end-of-file
offset respectively when evaluating
.IR expr .
.RE

.sp
.ne 2
.mk
.na
\fB>#((\fIexpr\fB))\fR
.ad
.RS 14n
.rt
The same as
.B <#
except applies to file descriptor 1.
.RE

.sp
.ne 2
.mk
.na
.BI <# pattern
.ad
.RS 14n
.rt
Seek forward to the beginning of the next line containing pattern.
.RE

.sp
.ne 2
.mk
.na
.BI <## pattern
.ad
.RS 14n
.rt
The same as
.BR <# ,
except that the portion of the file that is skipped
is copied to standard output.
.RE

.sp
.LP
If one of the redirection operators is preceded by a digit, with no
intervening space, then the file descriptor number referred to is that
specified by the digit (instead of the default 0 or 1). If one of the
redirection operators other than
.B >&-
and the
.B >#
and
.BR <#
forms, is preceded by \fB{\fIvarname\fB}\fR with no intervening space,
then a file descriptor number
.B "> 10"
is selected by the shell and stored
in the variable
.IR varname .
If
.B >&-
or the any of the
.B >#
and
\fB<#\fR forms is preceded by \fB{\fIvarname\fB}\fR the value of
.I varname
defines the file descriptor to close or position. For
example:
.sp
.in +2
.nf
\&.\|.\|. 2>&1
.fi
.in -2
.sp

.sp
.LP
means file descriptor 2 is to be opened for writing as a duplicate of file
descriptor 1 and
.sp
.in +2
.nf
exec [\fIn\fR]<\fIfile\fR
.fi
.in -2
.sp

.sp
.LP
means open
.I file
for reading and store the file descriptor number in
variable
.IR n .
The order in which redirections are specified is
significant. The shell evaluates each redirection in terms of the
.RI ( file_descriptor ,
.IR file )
association at the time of evaluation.
For example:
.sp
.in +2
.nf
\&.\|.\|. 1>\fIfname\fR 2>&1
.fi
.in -2
.sp

.sp
.LP
first associates file descriptor 1 with file
.IR fname .
It then
associates file descriptor 2 with the file associated with file descriptor
1, that is,
.IR fname .
If the order of redirections were reversed, file
descriptor 2 would be associated with the terminal (assuming file descriptor
1 had been) and then file descriptor 1 would be associated with file
.IR fname .
If a command is followed by
.B &
and job control is not
active, the default standard input for the command is the empty file
.BR /dev/null .
Otherwise, the environment for the execution of a command
contains the file descriptors of the invoking shell as modified by input and
output specifications.
.SS "Environment"
.sp
.LP
The
.I environment
is a list of name-value pairs that is passed to an
executed program in the same way as a normal argument list. See
.BR environ (5).
.sp
.LP
The names must be
.I identifiers
and the values are character strings.
The shell interacts with the environment in several ways. On invocation, the
shell scans the environment and creates a variable for each name found,
giving it the corresponding value and attributes and marking it
.BR export .
Executed commands inherit the environment. If the user
modifies the values of these variables or creates new ones, using the
.B export
or
.B "typeset -x"
commands, they become part of the
environment. The environment seen by any executed command is thus composed
of any name-value pairs originally inherited by the shell, whose values can
be modified by the current shell, plus any additions which must be noted in
.B export
or
.B "typeset -x"
commands. The environment for any
simple-command or function can be augmented by prefixing it with one or more
variable assignments. A variable assignment argument is a word of the form
\fIidentifier\fB=\fIvalue\fR. Thus:
.sp
.in +2
.nf
TERM=450 cmd args
.fi
.in -2
.sp

.sp
.LP
and
.sp
.in +2
.nf
(export TERM; TERM=450; cmd args)
.fi
.in -2
.sp

.sp
.LP
are equivalent (as far as the execution of
.I cmd
is concerned except
for special built-in commands listed in the
.B Built-Ins
section, those
that are preceded with a dagger. If the obsolete
.B -k
option is set, all
variable assignment arguments are placed in the environment, even if they
occur after the command name.
.sp
.LP
The following example first prints
.B "a=b c"
and then
.BR c :
.sp
.in +2
.nf
echo a=b c
set -k
echo a=b c
.fi
.in -2
.sp

.sp
.LP
This feature is intended for use with scripts written for early versions of
the shell and its use in new scripts is strongly discouraged.
.SS "Functions"
.sp
.LP
For historical reasons, there are two ways to define functions, the
.B name()
syntax and the
.B "function name"
syntax. These are
described in the
.B Commands
section of this manual page.
.sp
.LP
Shell functions are read in and stored internally. Alias names are resolved
when the function is read. Functions are executed like commands with the
arguments passed as positional parameters. See the
.B Execution
section
of this manual page for details.
.sp
.LP
Functions defined by the
.B "function name"
syntax and called by
name execute in the same process as the caller and share all files and
present working directory with the caller. Traps caught by the caller are
reset to their default action inside the function. A trap condition that is
not caught or ignored by the function causes the function to terminate and
the condition to be passed on to the caller. A trap on
.B EXIT
set inside
a function is executed in the environment of the caller after the function
completes. Ordinarily, variables are shared between the calling program and
the function. However, the
.B typeset
special built-in command used
within a function defines local variables whose scope includes the current
function. They can be passed to functions that they call in the variable
assignment list that precedes the call or as arguments passed as name
references. Errors within functions return control to the caller.
.sp
.LP
Functions defined with the
.B name()
syntax and functions defined with
the
.B function name
syntax that are invoked with the \fB\&.\fR
special built-in are executed in the caller's environment and share all
variables and traps with the caller. Errors within these function executions
cause the script that contains them to abort.
.sp
.LP
The special built-in command
.B return
is used to return from function
calls.
.sp
.LP
Function names can be listed with the
.BR -f " or "
.B +f
option of the
.B typeset
special built-in command. The text of functions, when
available, is also listed with
.BR -f .
Functions can be undefined with the
.B -f
option of the
.B unset
special built-in command.
.sp
.LP
Ordinarily, functions are unset when the shell executes a shell script.
Functions that need to be defined across separate invocations of the shell
should be placed in a directory and the
.B FPATH
variable should contain
the name of this directory. They can also be specified in the
.B ENV
file.
.SS "Discipline Functions"
.sp
.LP
Each variable can have zero or more discipline functions associated with
it. The shell initially understands the discipline names
.BR get ,
.BR set ,
.BR append ,
and
.B unset
but on most systems others can be
added at run time via the C programming interface extension provided by the
.B builtin
built-in utility. If the
.B get
discipline is defined for a
variable, it is invoked whenever the specified variable is referenced. If
the variable \fB\&.sh.value\fR is assigned a value inside the discipline
function, the referenced variable is evaluated to this value instead. If the
.B set
discipline is defined for a variable, it is invoked whenever the
specified variable is assigned a value. If the
.B append
discipline is
defined for a variable, it is invoked whenever a value is appended to the
specified variable. The variable \fB\&.sh.value\fR is specified the value of
the variable before invoking the discipline, and the variable is assigned
the value of \fB\&.sh.value\fR after the discipline completes. If
\&.\fBsh.value\fR is
.B unset
inside the discipline, then that value is
unchanged. If the
.B unset
discipline is defined for a variable, it is
invoked whenever the specified variable is unset. The variable is not unset
unless it is unset explicitly from within this discipline function.
.sp
.LP
The variable \fB\&.sh.name\fR contains the name of the variable for which
the discipline function is called, \fB\&.sh.subscript\fR is the subscript of
the variable, and \fB\&.sh.value\fR contains the value being assigned inside
the
.B set
discipline function. For the
.B set
discipline, changing
\fB\&.sh.value\fR changes the value that gets assigned.
.SS "Jobs"
.sp
.LP
If the monitor option of the
.B set
command is turned on, an interactive
shell associates a job with each pipeline. It keeps a table of current jobs,
printed by the
.B jobs
command, and assigns them small integer numbers.
When a job is started asynchronously with
.BR & ,
the shell prints a line
which looks like:
.sp
.in +2
.nf
[1] 1234
.fi
.in -2
.sp

.sp
.LP
indicating that the job which was started asynchronously was job number 1
and had one (top-level) process, whose process id was
.BR 1234 .
.sp
.LP
If you are running a job and wish to stop it, CTRL-z sends a
.B STOP
signal to the current job. The shell normally displays a message that the
job has been stopped, and displays another prompt. You can then manipulate
the state of this job, putting it in the background with the
.B bg
command, or run some other commands and then eventually bring the job back
into the foreground with the foreground command
.BR fg .
A CTRL-z takes
effect immediately and is like an interrupt in that pending output and
unread input are discarded when it is typed.
.sp
.LP
A job being run in the background stops if it tries to read from the
terminal. Background jobs are normally allowed to produce output, but this
can be disabled by giving the command
.BR sttytostop .
If you set this
.B tty
option, then background jobs stop when they try to produce output
like they do when they try to read input.
.sp
.LP
There are several ways to refer to jobs in the shell. A job can be referred
to by the process id of any process of the job or by one of the following:
.sp
.ne 2
.mk
.na
.BI % number
.ad
.RS 12n
.rt
The job with the specified number.
.RE

.sp
.ne 2
.mk
.na
.BI % string
.ad
.RS 12n
.rt
Any job whose command line begins with
.IR string .
.RE

.sp
.ne 2
.mk
.na
.BI %? string
.ad
.RS 12n
.rt
Any job whose command line contains
.IR string .
.RE

.sp
.ne 2
.mk
.na
.B %%
.ad
.RS 12n
.rt
Current job.
.RE

.sp
.ne 2
.mk
.na
.B %+
.ad
.RS 12n
.rt
Equivalent to
.BR %% .
.RE

.sp
.ne 2
.mk
.na
.B %-
.ad
.RS 12n
.rt
Previous job.
.RE

.sp
.LP
The shell learns immediately whenever a process changes state. It normally
informs you whenever a job becomes blocked so that no further progress is
possible, but only just before it prints a prompt. This is done so that it
does not otherwise disturb your work. The notify option of the
.B set
command causes the shell to print these job change messages as soon as they
occur.
.sp
.LP
When the
.B monitor
option is on, each background job that completes
triggers any trap set for
.BR CHLD .
.sp
.LP
When you try to leave the shell while jobs are running or stopped, you are
warned that
.B "You have stopped(running) jobs."
You can use the
.BR jobs
command to see what they are. If you immediately try to exit again, the
shell does not warn you a second time, and the stopped jobs are terminated.
When a login shell receives a
.B HUP
signal, it sends a
.B HUP
signal
to each job that has not been disowned with the
.B disown
built-in
command.
.SS "Signals"
.sp
.LP
The
.B INT
and
.B QUIT
signals for an invoked command are ignored if
the command is followed by
.B &
and the
.B monitor
option is not
active. Otherwise, signals have the values inherited by the shell from its
parent. See the
.B trap
built-in command.
.SS "Execution"
.sp
.LP
Each time a command is read, the substitutions are carried out. If the
command name matches one of the ones in the
.BR "Special Built-in Commands"
section of this manual page, it is executed within the current shell
process. Next, the command name is checked to see if it matches a user
defined function. If it does, the positional parameters are saved and then
reset to the arguments of the function call. A function is also executed in
the current shell process. When the function completes or issues a return,
the positional parameter list is restored. For functions defined with the
.B function name
syntax, any trap set on
.B EXIT
within the
function is executed. The exit value of a function is the value of the last
command executed. If a command name is not a special built-in command or a
user defined function, but it is one of the built-in commands, it is
executed in the current shell process.
.sp
.LP
The shell variable
.B PATH
defines the search path for the directory
containing the command. Alternative directory names are separated by a colon
.RB ( : ).
The default path is
.BR /bin:/usr/bin: ,
specifying
.BR /bin ,
.BR /usr/bin ,
and the current directory in that order. The current
directory can be specified by two or more adjacent colons, or by a colon at
the beginning or end of the path list. If the command name contains a slash
.RB ( / ),
the search path is not used. Otherwise, each directory in the
path is searched for an executable file of the specified name that is not a
directory. If found, and if the shell determines that there is a built-in
version of a command corresponding to a specified pathname, this built-in is
invoked in the current process. If found, and this directory is also
contained in the value of the
.B FPATH
variable, then this file is loaded
into the current shell environment as if it were the argument to the .
command except that only preset aliases are expanded, and a function of the
specified name is executed as described in this manual page. If not found,
and the file \fB\&.paths\fR is found, and this file contains a line of the
form \fBFPATH=\fIpath\fR where
.I path
is an existing directory, and
this directory contains a file of the specified name, then this file is
loaded into the current shell environment as if it were the argument to the
\fB\&. special\fR built-in command and a function of the specified name is
executed. Otherwise, if found, a process is created and an attempt is made
to execute the command using
.BR exec (2).
.sp
.LP
When an executable is found, the directory where it is found in is searched
for a file named \fB\&.paths\fR. If this file is found and it contains a
line of the form \fBBUILTIN_LIB=\fIvalue\fR, the library named by
.I value
is searched for as if it were an option argument to \fBbuiltin -f\fR, and if it contains a built-in of the specified name this is executed
instead of a command by this name. Otherwise, if this file is found and it
contains a line of the form \fIname\fB=\fIvalue\fR in the first or
second line, then the environment variable
.I name
is modified by
prepending the directory specified by
.I value
to the directory list. If
.I value
is not an absolute directory, then it specifies a directory
relative to the directory that the executable was found. If the environment
variable
.I name
does not already exist it is added to the environment
list for the specified command.
.sp
.LP
If the file has execute permission but is not an
.B a.out
file, it is
assumed to be a file containing shell commands. A separate shell is spawned
to read it. All non-exported variables are removed in this case. If the
shell command file doesn't have read permission, and/or if the
.B setuid
and
.B setgid
bits are set on the file, then the shell executes an agent
whose job it is to set up the permissions and execute the shell with the
shell command file passed down as an open file. A parenthesized command is
executed in a sub-shell without removing non-exported variables.
.SS "Command Re-entry"
.sp
.LP
The text of the last
.B HISTSIZE
(default 512) commands entered from a
terminal device is saved in a history file. The file
.B $HOME/.sh_history
is used if the
.B HISTFILE
variable is not set or if the file it names is
not writable. A shell can access the commands of all interactive shells
which use the same named
.BR HISTFILE .
The built-in command
.B hist
is
used to list or edit a portion of this file. The portion of the file to be
edited or listed can be selected by number or by giving the first character
or characters of the command. A single command or range of commands can be
specified. If you do not specify an editor program as an argument to
.B hist
then the value of the variable
.B HISTEDIT
is used. If
.B HISTEDIT
is unset, the obsolete variable
.B FCEDIT
is used. If
.B FCEDIT
is not defined, then
.B /bin/ed
is used. The edited commands
are printed and executed again upon leaving the editor unless you quit
without writing. The
.B -s
option (and in obsolete versions, the editor
name
.BR - )
is used to skip the editing phase and to re-execute the
command. In this case a substitution parameter of the form
\fIold\fB=\fInew\fRcan be used to modify the command before execution.
For example, with the preset alias
.BR r ,
which is aliased to \fB\&'hist
-s'\fR, typing
.B `r bad=good c'
re-executes the most recent command
which starts with the letter
.BR c ,
replacing the first occurrence of the
string bad with the string good.
.SS "Inline Editing Options"
.sp
.LP
Normally, each command line entered from a terminal device is simply typed
followed by a NEWLINE (RETURN or LINE FEED). If either the
.BR emacs ,
.BR gmacs ,
or
.B vi
option is active, the user can edit the command
line. To be in either of these edit modes set the corresponding option. An
editing option is automatically selected each time the
.B VISUAL
or
.B EDITOR
variable is assigned a value ending in either of these option
names.
.sp
.LP
The editing features require that the user's terminal accept RETURN as
carriage return without line feed and that a SPACE must overwrite the
current character on the screen.
.sp
.LP
Unless the
.B multiline
option is on, the editing modes implement a
concept where the user is looking through a window at the current line. The
window width is the value of
.B COLUMNS
if it is defined, otherwise
.BR 80 .
If the window width is too small to display the prompt and leave
at least 8 columns to enter input, the prompt is truncated from the left. If
the line is longer than the window width minus two, a mark is displayed at
the end of the window to notify the user. As the cursor moves and reaches
the window boundaries the window is centered about the cursor. The mark is a
.B >
.RB ( "<, *" )
if the line extends on the right , left, or both sides
of the window.
.sp
.LP
The search commands in each edit mode provide access to the history file.
Only strings are matched, not patterns, although a leading
.B ^
in the
string restricts the match to begin at the first character in the line.
.sp
.LP
Each of the edit modes has an operation to list the files or commands that
match a partially entered word. When applied to the first word on the line,
or the first word after a
.BR ; ,
.BR | ,
.BR & ,
or
.BR ( ,
and the
word does not begin with
.B ~
or contain a
.BR / ,
the list of aliases,
functions, and executable commands defined by the
.B PATH
variable that
could match the partial word is displayed. Otherwise, the list of files that
match the specified word is displayed. If the partially entered word does
not contain any file expansion characters, a
.B *
is appended before
generating these lists. After displaying the generated list, the input line
is redrawn. These operations are called command name listing and file name
listing, respectively. There are additional operations, referred to as
command name completion and file name completion, which compute the list of
matching commands or files, but instead of printing the list, replace the
current word with a complete or partial match. For file name completion, if
the match is unique, a
.B /
is appended if the file is a directory and a
space is appended if the file is not a directory. Otherwise, the longest
common prefix for all the matching files replaces the word. For command name
completion, only the portion of the file names after the last
.B /
are
used to find the longest command prefix. If only a single name matches this
prefix, then the word is replaced with the command name followed by a space.
When using a
.B TAB
for completion that does not yield a unique match, a
subsequent TAB provides a numbered list of matching alternatives. A specific
selection can be made by entering the selection number followed by a TAB.
.SS "Key Bindings"
.sp
.LP
The
.B KEYBD
trap can be used to intercept keys as they are typed and
change the characters that are actually seen by the shell. This trap is
executed after each character (or sequence of characters when the first
character is ESC) is entered while reading from a terminal.
.sp
.LP
The variable \fB\&.sh.edchar\fR contains the character or character
sequence which generated the trap. Changing the value of \fB\&.sh.edchar\fR
in the trap action causes the shell to behave as if the new value were
entered from the keyboard rather than the original value. The variable
\fB\&.sh.edcol\fR is set to the input column number of the cursor at the
time of the input. The variable \fB\&.sh.edmode\fR is set to
.B ESC
when
in
.B vi
insert mode and is null otherwise. By prepending
.B ${.sh.editmode}
to a value assigned to \fB\&.sh.edchar\fR it causes
the shell to change to control mode if it is not already in this mode.
.sp
.LP
This trap is not invoked for characters entered as arguments to editing
directives, or while reading input for a character search.
.SS "\fBemacs\fR Editing Mode"
.sp
.LP
This mode is entered by enabling either the
.B emacs
or
.BR gmacs
option. The only difference between these two modes is the way they handle
.BR ^T .
To edit, the user moves the cursor to the point needing correction
and then inserts or deletes characters or words as needed. All the editing
commands are control characters or escape sequences. The notation for
control characters is caret
.RB ( ^ )
followed by the character.
.sp
.LP
For example,
.B ^F
is the notation for CTRL/F. This is entered by
depressing
.B f
while holding down the CTRL (control) key. The SHIFT key
is not depressed. (The notation
.B ^?
indicates the DEL (delete) key.)
.sp
.LP
The notation for escape sequences is
.B M-
followed by a character. For
example,
.B M-f
(pronounced
.BR "Meta f" )
is entered by depressing ESC
.RB ( "ASCII 033" )
followed by
.BR f .
.B M-F
is the notation for ESC
followed by
.BR F .
.sp
.LP
All edit commands operate from any place on the line, not just at the
beginning. The RETURN or the LINE FEED key is not entered after edit
commands except when noted.
.sp
.ne 2
.mk
.na
.B ^F
.ad
.RS 13n
.rt
Move the cursor forward (right) one character.
.RE

.sp
.ne 2
.mk
.na
.B M-[C
.ad
.RS 13n
.rt
Move the cursor forward (right) one character.
.RE

.sp
.ne 2
.mk
.na
.B M-f
.ad
.RS 13n
.rt
Move the cursor forward one word. The
.B emacs
editor's idea of a word
is a string of characters consisting of only letters, digits and
underscores.
.RE

.sp
.ne 2
.mk
.na
.B ^B
.ad
.RS 13n
.rt
Move the cursor backward (left) one character.
.RE

.sp
.ne 2
.mk
.na
.B M-[D
.ad
.RS 13n
.rt
Move the cursor backward (left) one character.
.RE

.sp
.ne 2
.mk
.na
.B M-b
.ad
.RS 13n
.rt
Move the cursor backward one word.
.RE

.sp
.ne 2
.mk
.na
.B ^A
.ad
.RS 13n
.rt
Move the cursor to the beginning of the line.
.RE

.sp
.ne 2
.mk
.na
.B M-[H
.ad
.RS 13n
.rt
Move the cursor to the beginning of the line.
.RE

.sp
.ne 2
.mk
.na
.B ^E
.ad
.RS 13n
.rt
Move the cursor to the end of the line.
.RE

.sp
.ne 2
.mk
.na
.B M-[Y
.ad
.RS 13n
.rt
Move the cursor to the end of line.
.RE

.sp
.ne 2
.mk
.na
.BI ^] char
.ad
.RS 13n
.rt
Move the cursor forward to the character
.I char
on the current line.
.RE

.sp
.ne 2
.mk
.na
.BI M-^] char
.ad
.RS 13n
.rt
Move the cursor backwards to the character
.I char
on the current
line.
.RE

.sp
.ne 2
.mk
.na
.B ^X^X
.ad
.RS 13n
.rt
Interchange the cursor and the mark.
.RE

.sp
.ne 2
.mk
.na
.I erase
.ad
.RS 13n
.rt
Delete the previous character. The user-defined erase character is defined
by the
.BR stty (1)
command, and is usually
.B ^H
or
.BR # .
.RE

.sp
.ne 2
.mk
.na
.I lnext
.ad
.RS 13n
.rt
Removes the next character's editing features. The user-defined literal
next character is defined by the
.BR stty (1)
command, or is
.B ^V
if
not defined.
.RE

.sp
.ne 2
.mk
.na
.B ^D
.ad
.RS 13n
.rt
Delete the current character.
.RE

.sp
.ne 2
.mk
.na
.B M-d
.ad
.RS 13n
.rt
Delete the current word.
.RE

.sp
.ne 2
.mk
.na
.B M-^H
.ad
.RS 13n
.rt
MetaBACKSPACE. Delete the previous word.
.RE

.sp
.ne 2
.mk
.na
.B M-h
.ad
.RS 13n
.rt
Delete the previous word.
.RE

.sp
.ne 2
.mk
.na
.B M-^?
.ad
.RS 13n
.rt
MetaDEL. Delete the previous word. If your interrupt character is
.B ^?
(DEL, the default), this command does not work.
.RE

.sp
.ne 2
.mk
.na
.B ^T
.ad
.RS 13n
.rt
Transpose the current character with the previous character, and advance
the cursor in
.B emacs
mode. Transpose two previous characters in
.B gmacs
mode.
.RE

.sp
.ne 2
.mk
.na
.B ^C
.ad
.RS 13n
.rt
Capitalize the current character.
.RE

.sp
.ne 2
.mk
.na
.B M-c
.ad
.RS 13n
.rt
Capitalize the current word.
.RE

.sp
.ne 2
.mk
.na
.B M-l
.ad
.RS 13n
.rt
Change the current word to lower case.
.RE

.sp
.ne 2
.mk
.na
.B ^K
.ad
.RS 13n
.rt
Delete from the cursor to the end of the line. If preceded by a numerical
parameter whose value is less than the current cursor position, delete from
specified position up to the cursor. If preceded by a numerical parameter
whose value is greater than the current cursor position, then delete from
cursor up to specified cursor position.
.RE

.sp
.ne 2
.mk
.na
.B ^W
.ad
.RS 13n
.rt
Kill from the cursor to the mark.
.RE

.sp
.ne 2
.mk
.na
.B M-p
.ad
.RS 13n
.rt
Push the region from the cursor to the mark on the stack.
.RE

.sp
.ne 2
.mk
.na
.I kill
.ad
.RS 13n
.rt
Kill the entire current line. The user-defined kill character is defined by
the
.BR stty (1)
command, usually a
.B ^G
or
.BR @ .
If two kill
characters are entered in succession, all kill characters from then on cause
a line feed. This is useful when using paper terminals.
.RE

.sp
.ne 2
.mk
.na
.B ^Y
.ad
.RS 13n
.rt
Restore the last item removed from line. Yank the item back to the line.
.RE

.sp
.ne 2
.mk
.na
.B ^L
.ad
.RS 13n
.rt
Line feed and print the current line.
.RE

.sp
.ne 2
.mk
.na
.B M-^L
.ad
.RS 13n
.rt
Clear the screen.
.RE

.sp
.ne 2
.mk
.na
.B ^@
.ad
.RS 13n
.rt
Null character. Set mark.
.RE

.sp
.ne 2
.mk
.na
.BI M- space
.ad
.RS 13n
.rt
MetaSPACE. Set the mark.
.RE

.sp
.ne 2
.mk
.na
.B ^J
.ad
.RS 13n
.rt
New line. Execute the current line.
.RE

.sp
.ne 2
.mk
.na
.B ^M
.ad
.RS 13n
.rt
Return. Execute the current line.
.RE

.sp
.ne 2
.mk
.na
.B EOF
.ad
.RS 13n
.rt
End-of-file character, normally
.BR ^D ,
is processed as an
.B end-of-file
only if the current line is null.
.RE

.sp
.ne 2
.mk
.na
.B ^P
.ad
.RS 13n
.rt
Fetch the previous command. Each time
.B ^P
is entered the previous
command back in time is accessed. Moves back one line when it is not on the
first line of a multi-line command.
.RE

.sp
.ne 2
.mk
.na
.B M-[A
.ad
.RS 13n
.rt
Equivalent to
.BR ^P .
.RE

.sp
.ne 2
.mk
.na
.B M-<
.ad
.RS 13n
.rt
Fetch the least recent (oldest) history line.
.RE

.sp
.ne 2
.mk
.na
.B M->
.ad
.RS 13n
.rt
Fetch the most recent (youngest) history line.
.RE

.sp
.ne 2
.mk
.na
.B ^N
.ad
.RS 13n
.rt
Fetch the next command line. Each time
.B ^N
is entered the next command
line forward in time is accessed.
.RE

.sp
.ne 2
.mk
.na
.B M-[B
.ad
.RS 13n
.rt
Equivalent to
.BR ^N .
.RE

.sp
.ne 2
.mk
.na
.BI ^R string
.ad
.RS 13n
.rt
Reverse search history for a previous command line containing
.IR string .
If a parameter of zero is specified, the search is forward.
.I string
is
terminated by a RETURN or NEWLINE. If string is preceded by a
.BR ^ ,
the
matched line must begin with
.IR string .
If
.I string
is omitted, then
the next command line containing the most recent
.I string
is accessed.
In this case a parameter of zero reverses the direction of the search.
.RE

.sp
.ne 2
.mk
.na
.B ^O
.ad
.RS 13n
.rt
Operate. Execute the current line and fetch the next line relative to
current line from the history file.
.RE

.sp
.ne 2
.mk
.na
.BI M- digits
.ad
.RS 13n
.rt
Escape. Define numeric parameter. The digits are taken as a parameter to
the next command. The commands that accept a parameter are:
.BR ^F ,
.BR ^B ,
.BR ERASE ,
.BR ^C ,
.BR ^D ,
.BR ^K ,
.BR ^R ,
.BR ^P ,
.BR ^N ,
.BR ^] ,
.BR M-. ,
.BR M- ,
.BR M-^] ,
.BR M-_ ,
.BR M-= ,
.BR M-b ,
.BR M-c ,
.BR M-d ,
.BR M-f ,
.BR M-h ,
.BR M-l ,
and
.BR M-^H .
.RE

.sp
.ne 2
.mk
.na
.BI M- letter
.ad
.RS 13n
.rt
Soft-key. Search the alias list for an alias by the name
.IR letter .
If
an alias of
.I letter
is defined, insert its value on the input queue.
.I letter
must not be one of the metafunctions in this section.
.RE

.sp
.ne 2
.mk
.na
.BI M-[ letter
.ad
.RS 13n
.rt
Soft key. Search the alias list for an alias by the name
.IR letter .
If
an alias of this name is defined, insert its value on the input queue. This
can be used to program function keys on many terminals.
.RE

.sp
.ne 2
.mk
.na
.B M-.
.ad
.RS 13n
.rt
The last word of the previous command is inserted on the line. If preceded
by a numeric parameter, the value of this parameter determines which word to
insert rather than the last word.
.RE

.sp
.ne 2
.mk
.na
.B M-_
.ad
.RS 13n
.rt
Same as
.BR M-. .
.RE

.sp
.ne 2
.mk
.na
.B M-*
.ad
.RS 13n
.rt
Attempt filename generation on the current word. As asterisk is appended if
the word does not match any file or contain any special pattern
characters.
.RE

.sp
.ne 2
.mk
.na
.BR M- ESC
.ad
.RS 13n
.rt
Command or file name completion as described in this manual page.
.RE

.sp
.ne 2
.mk
.na
.BR ^I TAB
.ad
.RS 13n
.rt
Attempts command or file name completion as described in this manual page.
If a partial completion occurs, repeating this behaves as if
.B M-=
were
entered. If no match is found or entered after SPACE, a TAB is inserted.
.RE

.sp
.ne 2
.mk
.na
.B M-=
.ad
.RS 13n
.rt
If not preceded by a numeric parameter, generates the list of matching
commands or file names as described in this manual page. Otherwise, the word
under the cursor is replaced by the item corresponding to the value of the
numeric parameter from the most recently generated command or file list. If
the cursor is not on a word, the word is inserted instead.
.RE

.sp
.ne 2
.mk
.na
.B ^U
.ad
.RS 13n
.rt
Multiply parameter of next command by
.BR 4 .
.RE

.sp
.ne 2
.mk
.na
\fB\e\fR
.ad
.RS 13n
.rt
Escape the next character. Editing characters, the user's erase, kill and
interrupt
.RB "(normally " ^? )
characters can be entered in a command line or
in a search string if preceded by a \fB\e\fR\&. The \fB\e\fR removes the
next character's editing features, if any.
.RE

.sp
.ne 2
.mk
.na
.B M-^V
.ad
.RS 13n
.rt
Display the version of the shell.
.RE

.sp
.ne 2
.mk
.na
.B M-#
.ad
.RS 13n
.rt
If the line does not begin with a
.BR # ,
a
.B #
is inserted at the
beginning of the line and after each NEWLINE, and the line is entered. This
causes a comment to be inserted in the history file. If the line begins with
a
.BR # ,
the
.B #
is deleted and one
.B #
after each NEWLINE is also
deleted.
.RE

.SS "\fBvi\fR Editing Mode"
.sp
.LP
There are two typing modes. Initially, when you enter a command you are in
the input mode. To edit, the user enters control mode by typing ESC (033)
and moves the cursor to the point needing correction and then inserts or
deletes characters or words as needed. Most control commands accept an
optional repeat
.I count
prior to the command.
.sp
.LP
When in vi mode on most systems, canonical processing is initially enabled
and the command is echoed again if the speed is 1200 baud or greater and it
contains any control characters or less than one second has elapsed since
the prompt was printed. The ESC character terminates canonical processing
for the remainder of the command and the user can then modify the command
line. This scheme has the advantages of canonical processing with the
type-ahead echoing of raw mode.
.sp
.LP
If the option
.B viraw
is also set, the terminal is always have
canonical processing disabled. This mode is implicit for systems that do not
support two alternate end of line delimiters, and might be helpful for
certain terminals.
.SS "Input Edit Commands"
.sp
.LP
By default the editor is in input mode.
.sp
.LP
The following input edit commands are supported:
.sp
.ne 2
.mk
.na
.B ERASE
.ad
.RS 10n
.rt
User defined erase character as defined by the
.B stty
command, usually
.B ^H
or
.BR # .
Delete previous character.
.RE

.sp
.ne 2
.mk
.na
.B ^W
.ad
.RS 10n
.rt
.RB "Delete the previous blank separated word. On some systems the" " viraw"
option might be required for this to work.
.RE

.sp
.ne 2
.mk
.na
.B EOF
.ad
.RS 10n
.rt
As the first character of the line causes the shell to terminate unless the
.B ignoreeof
option is set. Otherwise this character is ignored.
.RE

.sp
.ne 2
.mk
.na
.I lnext
.ad
.RS 10n
.rt
User defined literal next character as defined by the
.BR stty (1)
or
.B ^V
if not defined. Removes the next character's editing features, if
any. On some systems the
.B viraw
option might be required for this to
work.
.RE

.sp
.ne 2
.mk
.na
\fB\e\fR
.ad
.RS 10n
.rt
Escape the next ERASE or KILL character.
.RE

.sp
.ne 2
.mk
.na
.BR ^I " TAB"
.ad
.RS 10n
.rt
Attempts command or file name completion as described in this manual page
and returns to input mode. If a partial completion occurs, repeating this
behaves as if
.B =
were entered from control mode. If no match is found
or entered after SPACE, a TAB is inserted.
.RE

.SS "Motion Edit Commands"
.sp
.LP
The motion edit commands move the cursor.
.sp
.LP
The following motion edit commands are supported:
.sp
.ne 2
.mk
.na
\fB[\fIcount\fB]l\fR
.ad
.RS 13n
.rt
Move the cursor forward (right) one character.
.RE

.sp
.ne 2
.mk
.na
\fB[\fIcount\fB][C\fR
.ad
.RS 13n
.rt
Move the cursor forward (right) one character.
.RE

.sp
.ne 2
.mk
.na
\fB[\fIcount\fB]w\fR
.ad
.RS 13n
.rt
Move the cursor forward one alphanumeric word.
.RE

.sp
.ne 2
.mk
.na
\fB[\fIcount\fB]W\fR
.ad
.RS 13n
.rt
Move the cursor to the beginning of the next word that follows a blank.
.RE

.sp
.ne 2
.mk
.na
\fB[\fIcount\fB]e\fR
.ad
.RS 13n
.rt
Move the cursor to the end of the word.
.RE

.sp
.ne 2
.mk
.na
\fB[\fIcount\fB]E\fR
.ad
.RS 13n
.rt
Move the cursor to the end of the current blank delimited word.
.RE

.sp
.ne 2
.mk
.na
\fB[\fIcount\fB]h\fR
.ad
.RS 13n
.rt
Move the cursor backward (left) one character.
.RE

.sp
.ne 2
.mk
.na
\fB[\fIcount\fB][D\fR
.ad
.RS 13n
.rt
Move the cursor backward (left) one character.
.RE

.sp
.ne 2
.mk
.na
\fB[\fIcount\fB]b\fR
.ad
.RS 13n
.rt
Move the cursor backward one word.
.RE

.sp
.ne 2
.mk
.na
\fB[\fIcount\fB]B\fR
.ad
.RS 13n
.rt
Move the cursor to the preceding blank separated word.
.RE

.sp
.ne 2
.mk
.na
\fB[\fIcount\fB]|\fR
.ad
.RS 13n
.rt
Move the cursor to column
.IR count .
.RE

.sp
.ne 2
.mk
.na
\fB[\fIcount\fB]f\fIc\fR
.ad
.RS 13n
.rt
Find the next character
.I c
in the current line.
.RE

.sp
.ne 2
.mk
.na
\fB[\fIcount\fB]F\fIc\fR
.ad
.RS 13n
.rt
Find the previous character
.I c
in the current line.
.RE

.sp
.ne 2
.mk
.na
\fB[\fIcount\fB]t\fIC\fR
.ad
.RS 13n
.rt
Equivalent to
.B f
followed by
.BR h .
.RE

.sp
.ne 2
.mk
.na
\fB[\fIcount\fB]T\fIc\fR
.ad
.RS 13n
.rt
Equivalent to
.B F
followed by
.BR l .
.RE

.sp
.ne 2
.mk
.na
\fB[\fIcount\fB];\fR
.ad
.RS 13n
.rt
Repeat
.I count
times the last single character find command:
.BR f ,
.BR F ,
.B t,
or
.BR T .
.RE

.sp
.ne 2
.mk
.na
\fB[\fIcount\fB],\fR
.ad
.RS 13n
.rt
Reverse the last single character find command
.I count
times.
.RE

.sp
.ne 2
.mk
.na
.B 0
.ad
.RS 13n
.rt
Move the cursor to the start of line.
.RE

.sp
.ne 2
.mk
.na
.B ^
.ad
.RS 13n
.rt
Move the cursor to start of line.
.RE

.sp
.ne 2
.mk
.na
.B [H
.ad
.RS 13n
.rt
Move the cursor to the first non-blank character in the line.
.RE

.sp
.ne 2
.mk
.na
.B $
.ad
.RS 13n
.rt
Move the cursor to the end of the line.
.RE

.sp
.ne 2
.mk
.na
.B [Y
.ad
.RS 13n
.rt
Move the cursor to the end of the line.
.RE

.sp
.ne 2
.mk
.na
.B %
.ad
.RS 13n
.rt
Moves to balancing
.BR ( ,
.BR ) ,
.BR { ,
.BR } ,
.BR [ ,
or
.BR ] .
If cursor is not on one of the characters described in this section, the
remainder of the line is searched for the first occurrence of one of the
characters first.
.RE

.SS "Search Edit Commands"
.sp
.LP
The search edit commands access your command history.
.sp
.LP
The following search edit commands are supported:
.sp
.ne 2
.mk
.na
\fB[\fIcount\fB]k\fR
.ad
.RS 13n
.rt
Fetch the previous command. Each time
.B k
is entered, the previous
command back in time is accessed.
.RE

.sp
.ne 2
.mk
.na
\fB[\fIcount\fB]-\fR
.ad
.RS 13n
.rt
Fetch the previous command. Each time
.B k
is entered, the previous
command back in time is accessed.
.sp
Equivalent to
.BR k .
.RE

.sp
.ne 2
.mk
.na
\fB[\fIcount\fB][A\fR
.ad
.RS 13n
.rt
Fetch the previous command. Each time
.B k
is entered, the previous
command back in time is accessed.
.sp
Equivalent to
.BR k .
.RE

.sp
.ne 2
.mk
.na
\fB[\fIcount\fB]j\fR
.ad
.RS 13n
.rt
Fetch the next command. Each time
.B j
is entered, the next command
forward in time is accessed.
.RE

.sp
.ne 2
.mk
.na
\fB[\fIcount\fB]+\fR
.ad
.RS 13n
.rt
Fetch the next command. Each time
.B j
is entered, the next command
forward in time is accessed.
.sp
Equivalent to
.BR j .
.RE

.sp
.ne 2
.mk
.na
\fB[\fIcount\fB][B\fR
.ad
.RS 13n
.rt
Fetch the next command. Each time
.B j
is entered, the next command
forward in time is accessed.
.sp
Equivalent to
.BR j .
.RE

.sp
.ne 2
.mk
.na
\fB[\fIcount\fB]G\fR
.ad
.RS 13n
.rt
Fetch command number
.IR count .
The default is the least recent history
command.
.RE

.sp
.ne 2
.mk
.na
.BI / string
.ad
.RS 13n
.rt
Search backward through history for a previous command containing
.IR string .
.I string
is terminated by a RETURN or NEWLINE. If string
is preceded by a
.BR ^ ,
the matched line must begin with
.IR string .
If
.I string
is null, the previous string is used.
.RE

.sp
.ne 2
.mk
.na
.BI ? string
.ad
.RS 13n
.rt
Search forward through history for a previous command containing
.IR string .
.I string
is terminated by a RETURN or NEWLINE. If string
is preceded by a
.BR ^ ,
the matched line must begin with
.IR string .
If
.I string
is null, the previous string is used.
.sp
Same as
.I /
except that search is in the forward direction.
.RE

.sp
.ne 2
.mk
.na
.B n
.ad
.RS 13n
.rt
Search in the backwards direction for the next match of the last pattern to
.I /
or
.I ?
commands.
.RE

.sp
.ne 2
.mk
.na
.B N
.ad
.RS 13n
.rt
Search in the forward direction for next match of the last pattern to
.I /
or
.IR ? .
.RE

.SS "Text Modification Edit Commands"
.sp
.LP
The following commands modify the line:
.sp
.ne 2
.mk
.na
.B a
.ad
.RS 19n
.rt
Enter input mode and enter text after the current character.
.RE

.sp
.ne 2
.mk
.na
.B A
.ad
.RS 19n
.rt
Append text to the end of the line. Equivalent to
.BR $a .
.RE

.sp
.ne 2
.mk
.na
\fB[\fIcount\fB]c\fImotion\fR
.ad
.br
.na
\fBc[\fIcount\fB]\fImotion\fR
.ad
.RS 19n
.rt
Delete current character through the character that
.I motion
would move
the cursor to and enter input mode. If
.I motion
is
.BR c ,
the entire
line is deleted and input mode entered.
.RE

.sp
.ne 2
.mk
.na
.B C
.ad
.RS 19n
.rt
Delete the current character through the end of line and enter input mode.
Equivalent to
.BR c$ .
.RE

.sp
.ne 2
.mk
.na
.B S
.ad
.RS 19n
.rt
Equivalent to
.BR cc .
.RE

.sp
.ne 2
.mk
.na
\fB[\fIcount\fB]s\fR
.ad
.RS 19n
.rt
Replace characters under the cursor in input mode.
.RE

.sp
.ne 2
.mk
.na
\fBD[\fIcount\fB]d\fImotion\fR
.ad
.RS 19n
.rt
Delete the current character through the end of line. Equivalent to d$.
.RE

.sp
.ne 2
.mk
.na
\fBd[\fIcount\fB]\fImotion\fR
.ad
.RS 19n
.rt
Delete current character through the character that
.I motion
would move
to. If
.I motion
is d , the entire line is deleted.
.RE

.sp
.ne 2
.mk
.na
.B i
.ad
.RS 19n
.rt
Enter input mode and insert text before the current character.
.RE

.sp
.ne 2
.mk
.na
.B I
.ad
.RS 19n
.rt
Insert text before the beginning of the line. Equivalent to
.BR 0i .
.RE

.sp
.ne 2
.mk
.na
\fB[\fIcount\fB]P\fR
.ad
.RS 19n
.rt
Place the previous text modification before the cursor.
.RE

.sp
.ne 2
.mk
.na
\fB[\fIcount\fB]p\fR
.ad
.RS 19n
.rt
Place the previous text modification after the cursor.
.RE

.sp
.ne 2
.mk
.na
.B R
.ad
.RS 19n
.rt
Enter input mode and replace characters on the screen with characters you
type overlay fashion.
.RE

.sp
.ne 2
.mk
.na
\fB[\fIcount\fB]r\fIc\fR
.ad
.RS 19n
.rt
Replace the
.I count
characters starting at the current cursor position
with
.IR c ,
and advance the cursor.
.RE

.sp
.ne 2
.mk
.na
\fB[\fIcount\fB]x\fR
.ad
.RS 19n
.rt
Delete current character.
.RE

.sp
.ne 2
.mk
.na
\fB[\fIcount\fR]X\fR
.ad
.RS 19n
.rt
Delete preceding character.
.RE

.sp
.ne 2
.mk
.na
\fB[\fIcount\fR].\fR
.ad
.RS 19n
.rt
Repeat the previous text modification command.
.RE

.sp
.ne 2
.mk
.na
\fB[\fIcount\fR]~\fR
.ad
.RS 19n
.rt
Invert the case of the
.I count
characters starting at the current
cursor position and advance the cursor.
.RE

.sp
.ne 2
.mk
.na
\fB[\fIcount\fR]_\fR
.ad
.RS 19n
.rt
Causes the
.I count
word of the previous command to be appended and
input mode entered. The last word is used if
.I count
is omitted.
.RE

.sp
.ne 2
.mk
.na
.B *
.ad
.RS 19n
.rt
Causes an
.B *
to be appended to the current word and file name
generation attempted. If no match is found, it rings the bell. Otherwise,
the word is replaced by the matching pattern and input mode is entered.
.RE

.sp
.ne 2
.mk
.na
\fB\e\fR
.ad
.RS 19n
.rt
Command or file name completion as described in this manual page.
.RE

.SS "Other Edit Commands"
.sp
.LP
The following miscellaneous edit commands are supported:
.sp
.ne 2
.mk
.na
\fB[\fIcount\fB]y\fImotion\fR
.ad
.br
.na
\fBy[\fIcount\fB]\fImotion\fR
.ad
.RS 18n
.rt
Yank the current character through the character to which
.IR motion
would move the cursor. Put the yanked characters in the delete buffer. The
text and cursor position are unchanged.
.RE

.sp
.ne 2
.mk
.na
.B yy
.ad
.RS 18n
.rt
Yank the current line.
.RE

.sp
.ne 2
.mk
.na
.B Y
.ad
.RS 18n
.rt
Yank the current line from the current cursor location to the end of the
line. Equivalent to
.BR y$ .
.RE

.sp
.ne 2
.mk
.na
.B u
.ad
.RS 18n
.rt
Undo the last text modifying command.
.RE

.sp
.ne 2
.mk
.na
.B U
.ad
.RS 18n
.rt
Undo all the text modifying commands performed on current line.
.RE

.sp
.ne 2
.mk
.na
\fB[\fIcount\fB]V\fR
.ad
.RS 18n
.rt
Return the command :
.sp
.in +2
.nf
hist -e ${VISUAL:-${EDITOR:-vi}} \fIcount\fR
.fi
.in -2
.sp

in the input buffer. If
.I count
is omitted, the current line is used.
.RE

.sp
.ne 2
.mk
.na
.B ^L
.ad
.RS 18n
.rt
Line feed and print the current line. This command only works in control
mode.
.RE

.sp
.ne 2
.mk
.na
.B ^J
.ad
.RS 18n
.rt
New line. Execute the current line, regardless of mode.
.RE

.sp
.ne 2
.mk
.na
.B ^M
.ad
.RS 18n
.rt
Return. Execute the current line, regardless of mode.
.RE

.sp
.ne 2
.mk
.na
.B #
.ad
.RS 18n
.rt
If the first character of the command is a
.B #
.RB ", delete this" " #"
and each
.B #
that follows a NEWLINE.
.sp
Otherwise, send the line after inserting a
.B #
in front of each line in
the command.
.sp
This is command is useful for causing the current line to be inserted in
the history as a comment and un-commenting previously commented commands in
the history file.
.RE

.sp
.ne 2
.mk
.na
\fB[\fIcount\fB]=\fR
.ad
.RS 18n
.rt
If
.I count
is not specified, generate the list of matching commands or
file names as described in this manual page.
.sp
Otherwise, replace the word at the current cursor location with the
.I count
item from the most recently generated command or file list. If
the cursor is not on a word, it is inserted after the current cursor
location.
.RE

.sp
.ne 2
.mk
.na
.BI @ letter
.ad
.RS 18n
.rt
Search your alias list for an alias by the name
.IR letter .
If an alias
of this name is defined, insert its value on the input queue for
processing.
.RE

.sp
.ne 2
.mk
.na
.B ^V
.ad
.RS 18n
.rt
Display version of the shell.
.RE

.SS "Built-in Commands"
.sp
.LP
The following simple-commands are executed in the shell process. Input and
output redirection is permitted. Unless otherwise indicated, the output is
written on file descriptor
.B 1
and the exit status, when there is no
syntax error, is
.BR 0 .
Except for
.BR : ,
.BR true ,
.BR false ,
.BR echo ,
.BR newgrp ,
and
.BR login ,
all built-in commands accept
.B --
to indicate the end of options. They also interpret the option
.B --man
as a request to display the manual page onto standard error and
.B -?
as a help request which prints a usage message on standard error.
.sp
.LP
Commands that are preceded by one or two
.B ++
symbols are special
built-in commands and are treated specially in the following ways:
.RS +4
.TP
1.
Variable assignment lists preceding the command remain in effect when the
command completes.
.RE
.RS +4
.TP
2.
I/O redirections are processed after variable assignments.
.RE
.RS +4
.TP
3.
Errors cause a script that contains them to abort.
.RE
.RS +4
.TP
4.
They are not valid function names.
.RE
.RS +4
.TP
5.
Words following a command preceded by
.B ++
that are in the format of a
variable assignment are expanded with the same rules as a variable
assignment. This means that tilde substitution is performed after the
.B =
sign and field splitting and file name generation are not
performed.
.RE
.sp
.ne 2
.mk
.na
\fB+ : [\fIarg .\|.\|.\fB]\fR
.ad
.sp .6
.RS 4n
The command only expands parameters.
.RE

.sp
.ne 2
.mk
.na
.B + .
.I name
\fB[\fIarg .\|.\|.\fB]\fR
.ad
.sp .6
.RS 4n
If
.I name
is a function defined with the
.B "function name"
reserved word syntax, the function is executed in the current environment
(as if it had been defined with the
.I name()
syntax.) Otherwise if
.I name
refers to a file, the file is read in its entirety and the
commands are executed in the current shell environment. The search path
specified by PATH is used to find the directory containing the file. If any
arguments
.I arg
are specified, they become the positional parameters
while processing the . command and the original positional parameters are
restored upon completion. Otherwise the positional parameters are unchanged.
The exit status is the exit status of the last command executed.
.RE

.sp
.ne 2
.mk
.na
\fB++ alias [-ptx] [\fIname\fB[ =\fIvalue\fB]] \&.\|.\|.\fR
.ad
.sp .6
.RS 4n
.B alias
with no arguments prints the list of aliases in the form
\fIname\fB=\fIvalue\fR on standard output. The
.B -p
option causes
the word alias to be inserted before each one. When one or more arguments
are specified, an
.I alias
is defined for each
.I name
whose
.I value
is specified. A trailing space in
.I value
causes the next
word to be checked for alias substitution. The obsolete
.B -t
option is
used to set and list tracked aliases. The value of a tracked alias is the
full pathname corresponding to the specified
.IR name .
The value becomes
undefined when the value of
.B PATH
is reset but the alias remains
tracked. Without the
.B -t
option, for each
.I name
in the argument
list for which no
.I value
is specified, the name and value of the alias
is printed. The obsolete -x option has no effect. The exit status is
.B non-zero
if a
.I name
is specified, but no value, and no alias has
been defined for the
.IR name .
.RE

.sp
.ne 2
.mk
.na
\fBbg [\fR \fIjob\fB\&.\|.\|.]\fR
.ad
.sp .6
.RS 4n
This command is only on systems that support job control. Puts each
specified
.I job
into the background. The current job is put in the
background if
.I job
is not specified. See the
.B Jobs
section of this
manual page for a description of the format of
.IR job .
.RE

.sp
.ne 2
.mk
.na
\fB+ break [\fIn\fB]\fR
.ad
.sp .6
.RS 4n
Exit from the enclosing
.BR for ,
.BR while ,
.BR until ,
or
.B select
loop, if any. If
.I n
is specified, then break
.I n
levels.
.RE

.sp
.ne 2
.mk
.na
.B builtin [-ds
.B ] [-f
\fIfile\fB] [\fIname \&.\|.\|.\fB]\fR
.ad
.sp .6
.RS 4n
If
.I name
is not specified, and no
.B -f
option is specified, the
built-ins are printed on standard output. The
.B -s
option prints only
the special built-ins. Otherwise, each
.I name
represents the pathname
whose basename is the name of the built-in. The entry point function name is
determined by prepending
.I b
to the built-in name. The ISO C/C++
prototype is
.BI b "mycommand(int argc, char *argv[], void *context)"
for the built-in command
.I mycommand
where
.I argv
is an array of
.I argc
elements and
.I context
is an optional pointer to a
.B Shell_t
structure as described in
.B <ast/shell.h>
Special
built-ins cannot be bound to a pathname or deleted. The
.B -d
option
deletes each of the specified built-ins. On systems that support dynamic
loading, the
.B -f
option names a shared library containing the code for
built-ins. The shared library prefix and/or suffix, which depend on the
system, can be omitted. Once a library is loaded, its symbols become
available for subsequent invocations of
.BR builtin .
Multiple libraries
can be specified with separate invocations of the
.B builtin
command.
Libraries are searched in the reverse order in which they are specified.
When a library is loaded, it looks for a function in the library whose name
is
.B lib_init()
and invokes this function with an argument of
.BR 0 .
.RE

.sp
.ne 2
.mk
.na
\fBcd\fR \fB[-LP] [\fIarg\fB]\fR
.ad
.br
.na
.B cd [-LP]
.I old new
.ad
.sp .6
.RS 4n
This command has two forms.
.sp
In the first form it changes the current directory to
.IR arg .
If
.I arg
is a
.BR - ,
the directory is changed to the previous directory.
The shell variable
.B HOME
is the default
.IR arg .
The variable
.B PWD
is set to the current directory. The shell variable
.B CDPATH
defines the search path for the directory containing
.IR arg .
Alternative
directory names are separated by a colon
.RB ( : ).
The default path is
.B NULL
(specifying the current directory). The current directory is
specified by a null path name, which can appear immediately after the equal
sign or between the colon delimiters anywhere else in the path list. If
.I arg
begins with a
.BR / ,
the search path is not used. Otherwise,
each directory in the path is searched for
.IR arg .
.sp
The second form of
.B cd
substitutes the string
.I new
for the string
.I old
in the current directory name,
.BR PWD ,
and tries to change to
this new directory. By default, symbolic link names are treated literally
when finding the directory name. This is equivalent to the
.B -L
option.
The
.B -P
option causes symbolic links to be resolved when determining
the directory. The last instance of
.B -L
or
.B -P
on the command line
determines which method is used. The
.B cd
command cannot be executed by
.BR rksh93 .
.RE

.sp
.ne 2
.mk
.na
.B command [-pvVx]
.I name
\fB[\fIarg \&.\|.\|.\fB]\fR
.ad
.sp .6
.RS 4n
Without the
.B -v
or
.B -V
options, executes
.I name
with the
arguments specified by
.IR arg .
.sp
The
.B -p
option causes a default path to be searched rather than the
one defined by the value of
.BR PATH .
Functions are not searched when
finding
.IR name .
In addition, if
.I name
refers to a special built-in,
none of the special properties associated with the leading daggers are
honored. For example, the predefined alias
.B "redirect='command exec'"
prevents a script from terminating when an invalid redirection is specified.

.sp
With the
.B -x
option, if command execution would result in a failure
because there are too many arguments,
.BR "errno E2BIG" ,
the shell invokes
command
.I name
multiple times with a subset of the arguments on each
invocation. Arguments that occur prior to the first word that expands to
multiple arguments and after the last word that expands to multiple
arguments are passed on each invocation. The exit status is the maximum
invocation exit status.
.sp
With the
.B -v
option,
.B command
is equivalent to the built-in
.B whence
command described in this section. The
.B -V
option causes
.B command
to act like
.BR "whence -v" .
.RE

.sp
.ne 2
.mk
.na
\fB+continue\fR \fB[\fIn\fB]\fR
.ad
.sp .6
.RS 4n
Resumes the next iteration of the enclosing
.BR for ,
.BR while ,
.BR until ,
or
.B select
loop. If
.I n
is specified, then resume at
the
.IR n "th enclosing loop."
.RE

.sp
.ne 2
.mk
.na
\fBdisown\fR \fB[\fIjob.\|.\|.\fB]\fR
.ad
.sp .6
.RS 4n
Causes the shell not to send a
.B HUP
signal to each specified
.IR job ,
or all active jobs if
.I job
is omitted, when a login shell
terminates.
.RE

.sp
.ne 2
.mk
.na
.B echo
\fB[\fIarg .\|.\|.\fB]\fR
.ad
.sp .6
.RS 4n
When the first
.I arg
does not begin with a
.BR - ,
and none of the
arguments contain a backslash (\fB\e\fR), prints each of its arguments
separated by a SPACE and terminated by a NEWLINE. Otherwise, the behavior of
.B echo
is system dependent and
.B print
or
.B printf
described in
this section should be used. See
.BR echo (1)
for usage and description.
.RE

.sp
.ne 2
.mk
.na
.B +eval
\fB[\fIarg .\|.\|.\fB]\fR
.ad
.sp .6
.RS 4n
The arguments are read as input to the shell and the resulting commands are
executed.
.RE

.sp
.ne 2
.mk
.na
.B +exec
[\fB-c\fR] [\fB-a\fR \fIname .\|.\|.\fR] \fB[\fIarg \&.\|.\|.\fB]\fR
.ad
.sp .6
.RS 4n
If
.I arg
is specified, the command specified by the arguments is
executed in place of this shell without creating a new process. The
.B -c
option causes the environment to be cleared before applying variable
assignments associated with the exec invocation. The
.B -a
option causes
.I name
rather than the first
.IR arg ,
to become \fBargv[0]\fR for the
new process. Input and output arguments can appear and affect the current
process. If
.I arg
is not specified, the effect of this command is to
modify file descriptors as prescribed by the input/output redirection list.
In this case, any file descriptor numbers greater than
.B 2
that are
opened with this mechanism are closed when invoking another program.
.RE

.sp
.ne 2
.mk
.na
\fB+exit\fR \fB[\fIn\fB]\fR
.ad
.sp .6
.RS 4n
Causes the shell to exit with the exit status specified by
.IR n .
The
value is the least significant 8 bits of the specified status. If
.I n
is
omitted, then the exit status is that of the last command executed. An
end-of-file also causes the shell to exit except for a shell which has the
.B ignoreeof
option turned on. See
.BR set .
.RE

.sp
.ne 2
.mk
.na
.B ++export [-p]
\fB[\fIname\fB[=\fIvalue\fB]] .\|.\|.\fR
.ad
.sp .6
.RS 4n
If
.I name
is not specified, the names and values of each variable with
the export attribute are printed with the values quoted in a manner that
allows them to be re-entered. The
.B -p
option causes the word export to
be inserted before each one. Otherwise, the specified
.IR name s
are marked
for automatic export to the environment of subsequently-executed commands.
.RE

.sp
.ne 2
.mk
.na
.B false
.ad
.sp .6
.RS 4n
Does nothing, and exits
.BR 1 .
Used with
.B until
for infinite
loops.
.RE

.sp
.ne 2
.mk
.na
.B fg
\fB[\fIjob .\|.\|.\fB]\fR
.ad
.sp .6
.RS 4n
.RI "This command is only on systems that support job control. Each" " job"
specified is brought to the foreground and waited for in the specified
order. Otherwise, the current job is brought into the foreground. See
.B Jobs
for a description of the format of
.IR job .
.RE

.sp
.ne 2
.mk
.na
\fBgetconf\fR \fB[\fIname\fR \fB[\fIpathname\fB]]\fR
.ad
.sp .6
.RS 4n
Prints the current value of the configuration parameter specified by
.IR name .
The configuration parameters are defined by the IEEE POSIX
1003.1 and IEEE POSIX 1003.2 standards. See
.BR pathconf (2)
and
.BR sysconf (3C).
.sp
The
.I pathname
argument is required for parameters whose value depends
on the location in the file system. If no arguments are specified,
.B getconf
prints the names and values of the current configuration
parameters. The pathname
.B /
is used for each of the parameters that
requires
.IR pathname .
.RE

.sp
.ne 2
.mk
.na
\fBgetopts [\fR
.B -a
\fIname\fB]\fR \fIoptstring\fR
.I vname
\fB[\fIarg .\|.\|.\fB]\fR
.ad
.sp .6
.RS 4n
Checks
.I arg
for legal options. If
.I arg
is omitted, the positional
parameters are used. An option argument begins with a
.B +
or a
.BR - .
An option that does not begin with
.B +
or
.B -
or the argument
.B --
ends the options. Options beginning with
.B +
are only
recognized when
.I optstring
begins with a
.BR + .
.I optstring
contains the letters that
.B getopts
recognizes. If a letter is followed
by a
.BR : ,
that option is expected to have an argument. The options can
be separated from the argument by blanks. The option
.BR -? causes
.B getopts
to generate a usage message on standard error. The
.B -a
option can be used to specify the name to use for the usage message, which
defaults to $0.
.B getopts
places the next option letter it finds inside
variable
.I vname
each time it is invoked. The option letter is prepended
with a
.B +
when
.I arg
begins with a
.BR + .
The index of the next
.I arg
is stored in
.BR OPTIND .
The option argument, if any, gets
stored in
.BR OPTARG .
A leading : in
.I optstring
causes
.BR getopts
to store the letter of an invalid option in
.BR OPTARG ,
and to set
.I vname
to
.B ?
for an unknown option and to: when a required option
argument is missing. Otherwise,
.B getopts
prints an error message. The
exit status is
.B non-zero
when there are no more options. There is no
way to specify any of the options
.BR : ,
.BR + ,
.BR - ,
.BR ? ,
.BR [ ,
and
.BR ] .
The option
.B #
can only be specified as the first
option.
.RE

.sp
.ne 2
.mk
.na
\fBhist [\fR
.B -e
\fIename\fB][-nlr]\fR
\fB[\fR \fIfirst\fB[\fIlast\fR \fB] ]\fR
.ad
.br
.na
\fR
.ad
.br
.na
\fBhist -s\fR
.B [
\fIold\fB=\fInew\fR \fB] [\fR
.IB command ]
.ad
.sp .6
.RS 4n
In the first form, a range of commands from
.I first
to
.I last
is
selected from the last
.B HISTSIZE
commands that were typed at the
terminal. The arguments
.IR first " and "
.I last
can be specified as a
number or as a string. A string is used to locate the most recent command
starting with the specified string. A negative number is used as an offset
to the current command number. If the -l option is selected, the commands
are listed on standard output. Otherwise, the editor program
.I ename
is
invoked on a file containing these keyboard commands. If
.I ename
is not
supplied, then the value of the variable
.B HISTEDIT
is used. If
.B HISTEDIT
is not set, then
.B FCEDIT
(default
.BR /bin/ed )
is used
as the editor. When editing is complete, the edited command(s) is executed
if the changes have been saved. If
.I last
is not specified, then it is
set to
.IR first .
If
.I first
is not specified, the default is the
previous command for editing and
.B -16
for listing. The option
.B -r
reverses the order of the commands and the option
.B -n
suppresses
command numbers when listing. In the second form,
.I command
is
interpreted as
.I first
described in this section and defaults to the
last command executed. The resulting command is executed after the optional
substitution \fIold\fB=\fInew\fR is performed.
.RE

.sp
.ne 2
.mk
.na
.B jobs -lnp
\fB[\fIjob .\|.\|.\fB]\fR
.ad
.sp .6
.RS 4n
Lists information about each specified job, or all active jobs if
.I job
is omitted. The
.B -l
option lists process ids in addition to the normal
information. The
.B -n
option only displays jobs that have stopped or
exited since last notified. The
.B -p
option causes only the process
group to be listed. See
.B Jobs
for a description of the format of
.IR job .
.RE

.sp
.ne 2
.mk
.na
\fBkill [-s\fR \fIsigname\fB]\fR \fIjob .\|.\|.\fR
.ad
.br
.na
\fBkill [-n\fR \fIsignum\fB]\fR \fIjob .\|.\|.\fR
.ad
.br
.na
.B kill -l
\fB[\fIsig .\|.\|.\fB]\fR
.ad
.sp .6
.RS 4n
Sends either the
.B TERM
(terminate) signal or the specified signal to
the specified jobs or processes. Signals are either specified by number with
the
.B -n
option or by name with the
.B -s
option (as specified in
\fB<signal.h\fR>, stripped of the prefix `\fBSIG\fR with the exception that
.B SIGCLD
is named
.BR CHLD ).
.RB "For backward compatibility, the" " n"
and
.B s
can be omitted and the number or name placed immediately after
the
.BR - .
If the signal being sent is
.B TERM
.RB "(terminate) or" " HUP"
(hang up), then the job or process is sent a
.B CONT
(continue) signal if
it is stopped. The argument
.I job
can be the process id of a process
that is not a member of one of the active jobs. See
.B Jobs
for a
description of the format of
.IR job .
In the third form,
.BR "kill -l" ,
if
.I sig
is not specified, the signal names are listed. Otherwise, for each
.I sig
that is a name, the corresponding signal number is listed. For
each
.I sig
that is a number, the signal name corresponding to the least
significant 8 bits of
.I sig
is listed.
.RE

.sp
.ne 2
.mk
.na
.B let
\fB[\fIarg .\|.\|.\fB]\fR
.ad
.sp .6
.RS 4n
Each
.I arg
is a separate arithmetic expression to be evaluated. See the
.B Arithmetic Evaluation
section of this manual page for a description of
arithmetic expression evaluation. The exit status is
.B 0
if the value of
the last expression is
.BR non-zero ,
and
.B 1
otherwise.
.RE

.sp
.ne 2
.mk
.na
.B +newgrp
\fB[\fIarg .\|.\|.\fB]\fR
.ad
.sp .6
.RS 4n
Equivalent to
.B "exec /bin/newgrp"
\fIarg .\|.\|.\fR
.RE

.sp
.ne 2
.mk
.na
.B print
[\fB-Renprs\fR]
.B [ -u
\fIunit\fB] [\fR
.B -f
.I format
.B ] [
\fIarg .\|.\|.\fB]\fR
.ad
.sp .6
.RS 4n
With no options or with option
.B -
or
.BR -- ,
each
.I arg
is
printed on standard output. The
.B -f
option causes the arguments to be
printed as described by
.BR printf .
In this case, any
.BR e ,
.BR n ,
.BR r ,
or
.B R
options are ignored. Otherwise, unless the
.B -R
or
.B -r,
are specified, the following escape conventions are applied:
.sp
.ne 2
.mk
.na
\fB\ea\fR
.ad
.RS 8n
.rt
Alert character (\fBASCII\fR 07)
.RE

.sp
.ne 2
.mk
.na
\fB\eb\fR
.ad
.RS 8n
.rt
Backspace character (\fBASCII\fR 010)
.RE

.sp
.ne 2
.mk
.na
\fB\ec\fR
.ad
.RS 8n
.rt
Causes print to end without processing more arguments and not adding a
NEWLINE
.RE

.sp
.ne 2
.mk
.na
\fB\ef\fR
.ad
.RS 8n
.rt
Form-feed character (\fBASCII\fR 014)
.RE

.sp
.ne 2
.mk
.na
\fB\en\fR
.ad
.RS 8n
.rt
NEWLINE character (\fBASCII\fR 012)
.RE

.sp
.ne 2
.mk
.na
\fB\er\fR
.ad
.RS 8n
.rt
RETURN character (\fBASCII\fR 015)
.RE

.sp
.ne 2
.mk
.na
\fB\et\fR
.ad
.RS 8n
.rt
TAB character (\fBASCII\fR 011)
.RE

.sp
.ne 2
.mk
.na
\fB\ev\fR
.ad
.RS 8n
.rt
Vertical TAB character (\fBASCII\fR 013)
.RE

.sp
.ne 2
.mk
.na
\fB\eE\fR
.ad
.RS 8n
.rt
Escape character (\fBASCII\fR 033)
.RE

.sp
.ne 2
.mk
.na
\fB\e\e\fR
.ad
.RS 8n
.rt
Backslash character \fB\e\fR
.RE

.sp
.ne 2
.mk
.na
\fB\e0\fIx\fR
.ad
.RS 8n
.rt
Character defined by the 1, 2, or 3-digit octal string specified by
.I x
.RE

The
.B -R
option prints all subsequent arguments and options other than
.BR -n .
The
.B -e
causes the escape conventions to be applied This is
the default behavior. It reverses the effect of an earlier
.BR -r .
The
.B -p
option causes the arguments to be written onto the pipe of the
process spawned with
.B |&
instead of standard output. The
.B -s
option causes the arguments to be written onto the history file instead of
standard output. The
.B -u
option can be used to specify a one digit file
descriptor unit number
.I unit
on which the output is placed. The default
is
.BR 1 .
If the option
.B -n
is used, no NEWLINE is added to the
output.
.RE

.sp
.ne 2
.mk
.na
\fBprintf\fR \fIformat\fB[\fIarg .\|.\|.\fB]\fR
.ad
.sp .6
.RS 4n
The arguments
.I arg
are printed on standard output in accordance with
the
.B ANSI-C
formatting rules associated with the format string
.IR format .
If the number of arguments exceeds the number of format
specifications, the format string is reused to format remaining arguments.
The following extensions can also be used: A
.B %b
format can be used
instead of
.B %s
to cause escape sequences in the corresponding
.IR arg
to be expanded as described in
.BR print .
A
.B %B
option causes each of
the arguments to be treated as variable names and the binary value of the
variables is printed. This is most useful for variables with an attribute of
b. A
.B %H
format can be used instead of
.B %s
to cause characters in
.I arg
that are special in
.B HTML
and
.B XML
to be output as their
entity name. A
.B %P
format can be used instead of
.B %s
to cause
.I arg
to be interpreted as an extended regular expression and be printed
as a shell pattern. A
.B %R
format can be used instead of
.B %s
to
cause
.I arg
to be interpreted as a shell pattern and to be printed as an
extended regular expression. A
.B %q
format can be used instead of
\fB%\fRs to cause the resulting string to be quoted in a manner than can be
input again to the shell. A \fB%(\fIdate-format\fB)T\fR format can be
use to treat an argument as a date/time string and to format the date/time
according to the
.I date-format
as defined for the
.BR date (1)
command.
A
.B %Z
format outputs a byte whose value is 0. The precision field of
the %d format can be followed by a . and the output base. In this case, the
\fB#\fR flag character causes \fBbase\fI#\fR to be prepended. The \fB#\fR
flag when used with the
.B d
specifier without an output base, causes the
output to be displayed in thousands units with one of the suffixes
.BR k
.B "M G"
.B "T P"
.B E
to indicate the unit. The
.B #
flag when used with the i specifier causes the output to be displayed in
.B 1024
with one of the suffixes
.B "Ki Mi"
.B Gi Ti
.B Pi Ei
to indicate the unit. The
.B =
flag has been added to
center the output within the specified field width.
.RE

.sp
.ne 2
.mk
.na
\fBpwd\fR [\fB-LP\fR]\fR
.ad
.sp .6
.RS 4n
Outputs the value of the current working directory. The
.B -L
option is
the default. It prints the logical name of the current directory. If the
.B -P
option is specified, all symbolic links are resolved from the name.
The last instance of
.B -L
or
.B -P
on the command line determines
which method is used.
.RE

.sp
.ne 2
.mk
.na
.B read [-Aprs] [-d
.IB delim "] ["
.B -n
.IB n "] [["
\fB-N\fR \fIn\fB] [[-t\fR
\fItimeout\fB] [-u\fR \fIunit\fB] [\fIvname\fB?\fIprompt\fB] [\fR \fIvname .\|.\|.\fR \fB]\fR
.ad
.sp .6
.RS 4n
The shell input mechanism. One line is read and is broken up into fields
using the characters in IFS as separators. The escape character,
.BR \e ,
is used to remove any special meaning for the next character and for line
continuation. The
.B -d
option causes the read to continue to the first
character of
.I delim
rather than
.BR NEWLINE .
The
.B -n
option
causes at most
.I n
bytes to read rather a full line but returns when
reading from a slow device as soon as any characters have been read. The
.B -N
option causes exactly
.I n
to be read unless an end-of-file has
been encountered or the read times out because of the
.B -t
option. In
raw mode,
.BR -r ,
the \fB\e\fR character is not treated specially. The
first field is assigned to the first
.IR vname ,
the second field to the
second
.IR vname ,
etc., with leftover fields assigned to the last
.IR vname .
When
.I vname
has the binary attribute and
.B -n
or
.B -N
is specified, the bytes that are read are stored directly into the
variable. If the -v is specified, then the value of the first
.I vname
is
used as a default value when reading from a terminal device. The
.B -A
option causes the variable
.I vname
to be unset and each field that is
read to be stored in successive elements of the indexed array
.IR vname .
The
.B -p
option causes the input line to be taken from the input pipe of
a process spawned by the shell using
.BR |& .
If the
.B -s
option is
present, the input is saved as a command in the history file. The option
.B -u
can be used to specify a one digit file descriptor unit
.IR unit
to read from. The file descriptor can be opened with the
.B exec
special
built-in command. The default value of unit
.I n
is
.BR 0 .
The option
.B -t
is used to specify a time out in seconds when reading from a
terminal or pipe. If
.I vname
is omitted, then REPLY is used as the
default
.IR vname .
An end-of-file with the
.B -p
option causes cleanup
for this process so that another can be spawned. If the first argument
contains a
.BR ? ,
the remainder of this word is used as a prompt on
.RB "standard error when the shell is interactive. The exit status is" " 0"
unless an end-of-file is encountered or read has timed out.
.RE

.sp
.ne 2
.mk
.na
.B ++readonly [-p] [
\fIvname\fB[=\fIvalue\fB]] .\|.\|.\fR
.ad
.sp .6
.RS 4n
If
.I vname
is not specified, the names and values of each variable with
the read-only attribute is printed with the values quoted in a manner that
allows them to be input again. The
.B -p
option causes the word
.B readonly
to be inserted before each one. Otherwise, the specified
\fIvname\fRs are marked
.B readonly
and these names cannot be changed by
subsequent assignment.
.RE

.sp
.ne 2
.mk
.na
\fB+return\fR \fB[\fIn\fB]\fR
.ad
.sp .6
.RS 4n
Causes a shell function or script to return to the invoking script with the
exit status specified by
.IR n .
The value is the least significant 8 bits
of the specified status. If
.B n
is omitted, then the return status is
that of the last command executed. If return is invoked while not in a
function or a script, then it behaves the same as exit.
.RE

.sp
.ne 2
.mk
.na
\fB+set [ \(+-BCGabefhkmnoprstuvx] [\(+-o [\fR
.I option
\fB] ] .\|.\|. [
\(+-A\fR \fIvname\fB]\fR \fB[\fIarg.\|.\|.\fB]\fR
.ad
.sp .6
.RS 4n
The
.B set
command supports the following options:
.sp
.ne 2
.mk
.na
.B -a
.ad
.sp .6
.RS 4n
All subsequent variables that are defined are automatically exported.
.RE

.sp
.ne 2
.mk
.na
.B -A
.ad
.sp .6
.RS 4n
Array assignment. Unset the variable
.I vname
and assign values
sequentially from the
.I arg
list. If
.B +A
is used, the variable
.I vname
is not unset first.
.RE

.sp
.ne 2
.mk
.na
.B -b
.ad
.sp .6
.RS 4n
Prints job completion messages as soon as a background job changes state
rather than waiting for the next prompt.
.RE

.sp
.ne 2
.mk
.na
.B -B
.ad
.sp .6
.RS 4n
Enable brace pattern field generation. This is the default behavior.
.RE

.sp
.ne 2
.mk
.na
.B -C
.ad
.sp .6
.RS 4n
Prevents redirection
.RB ( > )
from truncating existing files. Files that
are created are opened with the
.B O_EXCL
mode. Requires
.B >|
to
truncate a file when turned on.
.RE

.sp
.ne 2
.mk
.na
.B -e
.ad
.sp .6
.RS 4n
If a command has a
.B non-zero
exit status, execute the
.B ERR
trap,
if set, and exit. This mode is disabled while reading profiles.
.RE

.sp
.ne 2
.mk
.na
.B -f
.ad
.sp .6
.RS 4n
Disables file name generation.
.RE

.sp
.ne 2
.mk
.na
.B -G
.ad
.sp .6
.RS 4n
Causes the pattern
.B **
by itself to match files and zero or more
directories and subdirectories when used for file name generation. If
followed by a
.B /
only directories and subdirectories are matched.
.RE

.sp
.ne 2
.mk
.na
.B -h
.ad
.sp .6
.RS 4n
Each command becomes a tracked alias when first encountered.
.RE

.sp
.ne 2
.mk
.na
.B -k
.ad
.sp .6
.RS 4n
Obsolete. All variable assignment arguments are placed in the environment
for a command, not just those that precede the command name.
.RE

.sp
.ne 2
.mk
.na
.B -m
.ad
.sp .6
.RS 4n
Background jobs run in a separate process group and a line prints upon
completion. The exit status of background jobs is reported in a completion
message. On systems with job control, this option is turned on automatically
for interactive shells.
.RE

.sp
.ne 2
.mk
.na
.B -n
.ad
.sp .6
.RS 4n
Read commands and check them for syntax errors, but do not execute them.
Ignored for interactive shells.
.RE

.sp
.ne 2
.mk
.na
.B -o
.ad
.sp .6
.RS 4n
If no option name is supplied, the list of options and their current
settings are written to standard output. When invoked with a
.BR + ,
the
options are written in a format that can be input again to the shell to
restore the settings. This option can be repeated to enable or disable
multiple options.
.sp
The following argument can be one of the following option names:
.sp
.ne 2
.mk
.na
.B allexport
.ad
.sp .6
.RS 4n
Same as
.BR -a .
.RE

.sp
.ne 2
.mk
.na
.B bgnice
.ad
.sp .6
.RS 4n
All background jobs are run at a lower priority. This is the default
mode.
.RE

.sp
.ne 2
.mk
.na
.B braceexpand
.ad
.sp .6
.RS 4n
Same as
.BR - B.
.RE

.sp
.ne 2
.mk
.na
.B emacs
.ad
.sp .6
.RS 4n
Puts you in an
.B emacs
style inline editor for command entry.
.RE

.sp
.ne 2
.mk
.na
.B errexit
.ad
.sp .6
.RS 4n
Same as
.BR -e .
.RE

.sp
.ne 2
.mk
.na
.B globstar
.ad
.sp .6
.RS 4n
Same as
.BR -G .
.RE

.sp
.ne 2
.mk
.na
.B gmacs
.ad
.sp .6
.RS 4n
Puts you in a
.B gmacs
style inline editor for command entry.
.RE

.sp
.ne 2
.mk
.na
.B ignoreeof
.ad
.sp .6
.RS 4n
The shell does not exit on end-of-file. The command
.B exit
must be
used.
.RE

.sp
.ne 2
.mk
.na
.B keyword
.ad
.sp .6
.RS 4n
Same as
.BR -k .
.RE

.sp
.ne 2
.mk
.na
.B markdirs
.ad
.sp .6
.RS 4n
All directory names resulting from file name generation have a trailing /
appended.
.RE

.sp
.ne 2
.mk
.na
.B monitor
.ad
.sp .6
.RS 4n
Same as
.BR -m .
.RE

.sp
.ne 2
.mk
.na
.B multiline
.ad
.sp .6
.RS 4n
The built-in editors use multiple lines on the screen for lines that are
longer than the width of the screen. This might not work for all
terminals.
.RE

.sp
.ne 2
.mk
.na
.B noclobber
.ad
.sp .6
.RS 4n
Same as
.BR -C .
.RE

.sp
.ne 2
.mk
.na
.B noexec
.ad
.sp .6
.RS 4n
Same as
.BR -n .
.RE

.sp
.ne 2
.mk
.na
.B noglob
.ad
.sp .6
.RS 4n
Same as
.BR -f .
.RE

.sp
.ne 2
.mk
.na
.B nolog
.ad
.sp .6
.RS 4n
Do not save function definitions in the history file.
.RE

.sp
.ne 2
.mk
.na
.B notify
.ad
.sp .6
.RS 4n
Same as
.BR -b .
.RE

.sp
.ne 2
.mk
.na
.B nounset
.ad
.sp .6
.RS 4n
Same as
.BR -u .
.RE

.sp
.ne 2
.mk
.na
.B pipefail
.ad
.sp .6
.RS 4n
A pipeline does not complete until all components of the pipeline have
completed, and the return value is the value of the last
.B non-zero
command to fail or zero if no command has failed.
.RE

.sp
.ne 2
.mk
.na
.B privileged
.ad
.sp .6
.RS 4n
Same as
.BR -p .
.RE

.sp
.ne 2
.mk
.na
.B showme
.ad
.sp .6
.RS 4n
When enabled, simple commands or pipelines preceded by a a semicolon
.RB ( ; ") is displayed as if the " xtrace " option were enabled but is not"
executed. Otherwise, the leading
.B ;
is ignored.
.RE

.sp
.ne 2
.mk
.na
.B trackall
.ad
.sp .6
.RS 4n
Same as
.BR -h .
.RE

.sp
.ne 2
.mk
.na
.B verbose
.ad
.sp .6
.RS 4n
Same as
.BR -v .
.RE

.sp
.ne 2
.mk
.na
.B vi
.ad
.sp .6
.RS 4n
Puts you in insert mode of a
.B vi
style inline editor until you hit the
escape character 033. This puts you in control mode. A return sends the
line.
.RE

.sp
.ne 2
.mk
.na
.B viraw
.ad
.sp .6
.RS 4n
Each character is processed as it is typed in
.B vi
mode.
.RE

.sp
.ne 2
.mk
.na
.B xtrace
.ad
.sp .6
.RS 4n
Same as
.BR -x .
.sp
If no option name is supplied, the current options settings are printed.
.RE

.RE

.sp
.ne 2
.mk
.na
.B -p
.ad
.sp .6
.RS 4n
Disables processing of the
.B $HOME/.profile
file and uses the file
.B /etc/suid_profile
instead of the
.B ENV
file. This mode is on
whenever the effective
.B uid
.RB ( gid )
is not equal to the real
.B uid
.RB ( gid ).
Turning this off causes the effective
.B uid
and
.B gid
to be set to the real
.B uid
and
.BR gid .
.RE

.sp
.ne 2
.mk
.na
.B -r
.ad
.sp .6
.RS 4n
Enables the restricted shell. This option cannot be unset once set.
.RE

.sp
.ne 2
.mk
.na
.B -s
.ad
.sp .6
.RS 4n
Sort the positional parameters lexicographically.
.RE

.sp
.ne 2
.mk
.na
.B -t
.ad
.sp .6
.RS 4n
Obsolete. Exit after reading and executing one command.
.RE

.sp
.ne 2
.mk
.na
.B -u
.ad
.sp .6
.RS 4n
Treat
.B unset
parameters as an error when substituting.
.RE

.sp
.ne 2
.mk
.na
.B -v
.ad
.sp .6
.RS 4n
Print shell input lines as they are read.
.RE

.sp
.ne 2
.mk
.na
.B -x
.ad
.sp .6
.RS 4n
Print commands and their arguments as they are executed.
.RE

.sp
.ne 2
.mk
.na
.B --
.ad
.sp .6
.RS 4n
Do not change any of the options. This is useful in setting
.B $1
to a
value beginning with
.BR - .
If no arguments follow this option then the
positional parameters are unset.
.RE

As an obsolete feature, if the first
.I arg
is - then the
.B -x
and
.B -v
options are turned off and the next
.I arg
is treated as the
first argument. Using
.B +
rather than
.B -
causes these options to be
turned off. These options can also be used upon invocation of the shell. The
current set of options can be found in
.BR $- .
Unless
.B -A
is
specified, the remaining arguments are positional parameters and are
assigned, in order, to \fB$1 $2 \&....\fR If no arguments are specified,
then the names and values of all variables are printed on the standard
output.
.RE

.sp
.ne 2
.mk
.na
\fB+shift\fR \fB[\fIn\fB]\fR
.ad
.sp .6
.RS 4n
The positional parameters from \fB$\fIn\fB+1 .\|.\|.\fR are renamed \fB$1 \&.\|.\|.\fR, the default \fIn\fR is
.BR 1 .
The parameter
.I n
can be any
arithmetic expression that evaluates to a non-negative number less than or
equal to
.BR $# .
.RE

.sp
.ne 2
.mk
.na
.B sleep
.I seconds
.ad
.sp .6
.RS 4n
Suspends execution for the number of decimal seconds or fractions of a
second specified by
.IR seconds .
.RE

.sp
.ne 2
.mk
.na
\fB+trap -p\fR \fB[\fIaction\fB]\fR \fB[\fIsig\fB] \&.\|.\|.\fR
.ad
.sp .6
.RS 4n
The
.B -p
option causes the trap action associated with each trap as
specified by the arguments to be printed with appropriate quoting.
Otherwise,
.I action
is processed as if it were an argument to
.BR eval
when the shell receives signal(s)
.IR sig .
Each
.I sig
can be specified
as a number or as the name of the signal. Trap commands are executed in
order of signal number. Any attempt to set a trap on a signal that was
ignored on entry to the current shell is ineffective. If
.I action
is
omitted and the first
.I sig
is a number, or if
.I action
is
.BR - ,
then the trap(s) for each
.I sig
are reset to their original values. If
.I action
is the null string then this signal is ignored by the shell and
by the commands it invokes. If
.I sig
is
.B ERR
then
.I action
is
executed whenever a command has a
.B non-zero
exit status. If
.I sig
is
.B DEBUG
then
.I action
is executed before each command. The
variable \fB\&.sh.command\fR contains the contents of the current command
line when
.I action
is running. If
.I sig
is
.B 0
or
.B EXIT
and
the trap statement is executed inside the body of a function defined with
the
.B function
.I name
syntax, then the command
.I action
is
executed after the function completes. If
.I sig
is
.B 0
or
.BR EXIT
for a trap set outside any function then the command
.I action
is
executed on exit from the shell. If
.I sig
is
.BR KEYBD ,
then
.I action
is executed whenever a key is read while in
.BR emacs ,
.BR gmacs ,
or
.B vi
mode. The
.B trap
command with no arguments
prints a list of commands associated with each signal number.
.RE

.sp
.ne 2
.mk
.na
.B true
.ad
.sp .6
.RS 4n
Does nothing, and exits
.BR 0 .
Used with while for infinite loops.
.RE

.sp
.ne 2
.mk
.na
\fB++typeset [\(+-AHflabnprtux ] [ \(+-EFLRZi[\fIn\fB] ] [\fR
\fIvname\fB[=\fIvalue\fR \fB] ]\fR
.ad
.sp .6
.RS 4n
Sets attributes and values for shell variables and functions. When invoked
inside a function defined with the
.B function
.I name
syntax, a new
instance of the variable
.I vname
is created, and the variable's value
and type are restored when the function completes.
.sp
Using
.B +
rather than
.B -
causes these options to be turned off. If
no
.I vname
arguments are specified, a list of
.IR vname s
(and
optionally the
.IR value s)
of the variables is printed. Using \fB+\fR
rather than
.B -
keeps the values from being printed.) The
.B -p
option causes
.B typeset
followed by the option letters to be printed
before each name rather than the names of the options. If any option other
than
.B -p
is specified, only those variables which have all of the
specified options are printed. Otherwise, the
.IR vname s
and
.I attributes
of all variables that have attributes are printed.
.sp
The following list of attributes can be specified:
.sp
.ne 2
.mk
.na
.B -a
.ad
.RS 6n
.rt
Declares
.I vname
to be an indexed array. This is optional unless except
for compound variable assignments.
.RE

.sp
.ne 2
.mk
.na
.B -A
.ad
.RS 6n
.rt
Declares
.I vname
to be an associative array. Sub-scripts are strings
rather than arithmetic expressions.
.RE

.sp
.ne 2
.mk
.na
.B -b
.ad
.RS 6n
.rt
The variable can hold any number of bytes of data. The data can be text or
binary. The value is represented by the
.B base64
encoding of the data.
If
.B -Z
is also specified, the size in bytes of the data in the buffer
is determined by the size associated with the
.BR -Z .
If the
.BR base64
string assigned results in more data, it is truncated. Otherwise, it is
filled with bytes whose value is zero. The
.B printf
format
.B %B
can
be used to output the actual data in this buffer instead of the
.BR base64
encoding of the data.
.RE

.sp
.ne 2
.mk
.na
.B -E
.ad
.RS 6n
.rt
Declares
.I vname
to be a double precision floating point number. If
.I n
is
.BR non-zero ,
it defines the number of significant figures that
are used when expanding
.IR vname .
Otherwise, ten significant figures is
used.
.RE

.sp
.ne 2
.mk
.na
.B -f
.ad
.RS 6n
.rt
The names refer to function names rather than variable names. No
assignments can be made and the only other valid options are
.BR -t ,
.BR -u ,
and
.B -x.
The
.B -t
option turns on execution tracing for
this function. The
.B -u
option causes this function to be marked
undefined. The
.B FPATH
variable is searched to find the function
definition when the function is referenced. If no options other than
.B -f
is specified, then the function definition is displayed on standard
output. If
.B +f
is specified, then a line containing the function name
followed by a shell comment containing the line number and path name of the
file where this function was defined, if any, is displayed.
.sp
The
.B -i
attribute cannot be specified with
.BR -f .
.RE

.sp
.ne 2
.mk
.na
.B -F
.ad
.RS 6n
.rt
Declares
.I vname
to be a double precision floating point number. If
.I n
is
.BR non-zero ,
it defines the number of places after the decimal
point that are used when expanding
.IR vname .
Otherwise ten places after
the decimal point is used.
.RE

.sp
.ne 2
.mk
.na
.B -H
.ad
.RS 6n
.rt
This option provides UNIX to hostname file mapping on non-UNIX machines.
.RE

.sp
.ne 2
.mk
.na
.B -i
.ad
.RS 6n
.rt
Declares
.I vname
to be represented internally as integer. The right
hand side of an assignment is evaluated as an arithmetic expression when
assigning to an integer. If
.I n
is
.BR non-zero ,
it defines the output
arithmetic base, otherwise the output base is ten.
.sp
The
.B -i
attribute cannot be specified along with
.BR -R ,
.BR -L ,
.BR -Z ,
or
.BR -f .
.RE

.sp
.ne 2
.mk
.na
.B -l
.ad
.RS 6n
.rt
All uppercase characters are converted to lowercase. The uppercase option,
.BR -u ,
is turned off.
.RE

.sp
.ne 2
.mk
.na
.B -L
.ad
.RS 6n
.rt
Left justify and remove leading blanks from
.IR value .
If
.I n
is
.BR non-zero ,
it defines the width of the field, otherwise it is
determined by the width of the value of first assignment. When the variable
is assigned to, it is filled on the right with blanks or truncated, if
necessary, to fit into the field. The
.B -R
option is turned off.
.sp
The
.B -i
attribute cannot be specified with
.BR -L .
.RE

.sp
.ne 2
.mk
.na
.B -n
.ad
.RS 6n
.rt
Declares
.I vname
to be a reference to the variable whose name is
defined by the value of variable
.IR vname .
This is usually used to
reference a variable inside a function whose name has been passed as an
argument.
.RE

.sp
.ne 2
.mk
.na
.B -R
.ad
.RS 6n
.rt
Right justify and fill with leading blanks. If
.I n
is
.BR non-zero ,
it defines the width of the field, otherwise it is determined by the width
of the value of first assignment. The field is left filled with blanks or
truncated from the end if the variable is reassigned. The
.B -L
option is
turned off.
.sp
The
.B -i
attribute cannot be specified with
.BR -R .
.RE

.sp
.ne 2
.mk
.na
.B -r
.ad
.RS 6n
.rt
The specified
.IR vname "s are marked read-only and these names cannot be"
changed by subsequent assignment.
.RE

.sp
.ne 2
.mk
.na
.B -t
.ad
.RS 6n
.rt
Tags the variables. Tags are user definable and have no special meaning to
the shell.
.RE

.sp
.ne 2
.mk
.na
.B -u
.ad
.RS 6n
.rt
All lowercase characters are converted to uppercase. The lowercase option,
.BR -l ,
is turned off.
.RE

.sp
.ne 2
.mk
.na
.B -x
.ad
.RS 6n
.rt
The specified
.IR vname s
are marked for automatic export to the
environment of subsequently-executed commands. Variables whose names contain
a . cannot be exported.
.RE

.sp
.ne 2
.mk
.na
.B -Z
.ad
.RS 6n
.rt
Right justify and fill with leading zeros if the first non-blank character
is a digit and the
.B -L
option has not been set. Remove leading zeros if
the
.B -L
option is also set. If
.I n
is
.BR non-zero ,
it defines
the width of the field, otherwise it is determined by the width of the value
of first assignment.
.sp
The
.B -i
attribute cannot be specified with
.BR -Z .
.RE

.RE

.sp
.ne 2
.mk
.na
\fBulimit [-HSacdfmnpstv] [\fR \fIlimit\fB]\fR
.ad
.sp .6
.RS 4n
Set or display a resource limit. Many systems do not support one or more of
these limits. The limit for a specified resource is set when
.I limit
is
specified. The value of
.I limit
can be a number in the unit specified
with each resource, or the value unlimited. When more than one resource is
specified, then the limit name and unit is printed before the value.
.sp
If no option is specified,
.B -f
is assumed.
.sp
The following are the available resource limits:
.sp
.ne 2
.mk
.na
.B -a
.ad
.RS 6n
.rt
Lists all of the current resource limits.
.RE

.sp
.ne 2
.mk
.na
.B -c
.ad
.RS 6n
.rt
The number of 512-byte blocks on the size of core dumps.
.RE

.sp
.ne 2
.mk
.na
.B -d
.ad
.RS 6n
.rt
The number of Kbytes on the size of the data area.
.RE

.sp
.ne 2
.mk
.na
.B -f
.ad
.RS 6n
.rt
The number of 512-byte blocks on files that can be written by the current
process or by child processes (files of any size can be read).
.RE

.sp
.ne 2
.mk
.na
.B -H
.ad
.RS 6n
.rt
Specifies a hard limit for the specified resource.
.sp
A hard limit cannot be increased once it is set.
.sp
If neither the
.B -H
nor
.B -S
option is specified, the limit applies
to both. The current resource limit is printed when
.I limit
is omitted.
In this case, the soft limit is printed unless
.B -H
is specified.
.RE

.sp
.ne 2
.mk
.na
.B -m
.ad
.RS 6n
.rt
The number of Kbytes on the size of physical memory.
.RE

.sp
.ne 2
.mk
.na
.B -n
.ad
.RS 6n
.rt
The number of file descriptors plus 1.
.RE

.sp
.ne 2
.mk
.na
.B -p
.ad
.RS 6n
.rt
The number of 512-byte blocks for pipe buffering.
.RE

.sp
.ne 2
.mk
.na
.B -s
.ad
.RS 6n
.rt
The number of Kbytes on the size of the stack area.
.RE

.sp
.ne 2
.mk
.na
.B -S
.ad
.RS 6n
.rt
Specifies a soft limit for the specified resource.
.sp
A soft limit can be increased up to the value of the hard limit.
.sp
If neither the
.B -H
nor
.B -S
option is specified, the limit applies
to both. The current resource limit is printed when
.I limit
is omitted.
In this case, the soft limit is printed unless
.B -H
is specified.
.RE

.sp
.ne 2
.mk
.na
.B -t
.ad
.RS 6n
.rt
The number of CPU seconds to be used by each process.
.RE

.sp
.ne 2
.mk
.na
.B -v
.ad
.RS 6n
.rt
The number of Kbytes for virtual memory.
.RE

.RE

.sp
.ne 2
.mk
.na
\fBumask\fR \fB[-S][\fImask\fB]\fR
.ad
.sp .6
.RS 4n
The user file-creation mask is set to
.IR mask .
.I mask
can either be
an octal number or a symbolic value as described in
.BR chmod (1).
.sp
If a symbolic value is specified, the new
.B umask
value is the
complement of the result of applying
.I mask
to the complement of the
previous
.B umask
value. If
.I mask
is omitted, the current value of
the mask is printed. The
.B -S
option causes the mode to be printed as a
symbolic value. Otherwise, the mask is printed in octal.
.sp
See
.BR umask (2)
.RE

.sp
.ne 2
.mk
.na
.B +unalias [-a]
.I name
.ad
.sp .6
.RS 4n
The aliases specified by the list of
.IR name s
are removed from the alias
list. The
.B -a
option causes all the aliases to be unset.
.RE

.sp
.ne 2
.mk
.na
.B +unset
.BI [-fnv] " vname"
.ad
.sp .6
.RS 4n
The variables specified by the list of
.IR vname "s are unassigned, i.e.,"
their values and attributes are erased. Read-only variables cannot be unset.
If the
.B -f
option is set, then the names refer to function names. If
the
.B -v
option is set, then the names refer to variable names. The
.B -f
option overrides
.BR -v .
If
.B -n
is set and
.I name
is a
name reference, then
.I name
is unset rather than the variable that it
references. The default is equivalent to
.BR -v .
Unsetting
.BR LINENO ,
.BR MAILCHECK ,
.BR OPTARG ,
.BR OPTIND ,
.BR RANDOM ,
.BR SECONDS ,
.BR TMOUT ,
and
.B _
removes their special meaning even if they are
subsequently assigned to.
.RE

.sp
.ne 2
.mk
.na
\fBwait\fR \fB[\fIjob\fB]\fR
.ad
.sp .6
.RS 4n
Wait for the specified job and report its termination status. If
.I job
is not specified, then all currently active child processes are waited for.
The exit status from this command is that of the last process waited for if
.I job
is specified; otherwise it is zero. See
.B Jobs
for a
description of the format of
.IR job .
.RE

.sp
.ne 2
.mk
.na
.B whence
\fB[-afpv]\fR \fIname .\|.\|.\fR
.ad
.sp .6
.RS 4n
For each
.IR name ,
indicate how it would be interpreted if used as a
command name. The
.B -v
option produces a more verbose report. The
.B -f
option skips the search for functions. The
.B -p
option does a
path search for
.I name
even if name is an alias, a function, or a
reserved word. The
.B -a
option is similar to the -v option but causes
all interpretations of the specified name to be reported.
.RE

.SS "Invocation"
.sp
.LP
If the shell is invoked by
.BR exec (2),
and the first character of
argument zero
.RB ( $0 )
is
.BR - ,
then the shell is assumed to be a login
shell and commands are read from
.B /etc/profile
and then from either
\&.\fBprofile\fR in the current directory or
.BR $HOME/.profile ,
if either
file exists. Next, for interactive shells, commands are read first from
.BR /etc/ksh.kshrc ,
and then from the file named by performing parameter
expansion, command substitution, and arithmetic substitution on the value of
the environment variable
.B ENV
if the file exists. If the
.B -s
option is not present and
.I arg
and a file by the name of
.IR arg
exists, then it reads and executes this script. Otherwise, if the first
.I arg
does not contain a
.BR / ,
a path search is performed on the
first
.I arg
to determine the name of the script to execute. The script
.I arg
must have execute permission and any
.B setuid
and
.BR setgid
settings are ignored. If the script is not found on the path,
.I arg
is
processed as if it named a built-in command or function.
.sp
.LP
Commands are then read as described, and the following options are
interpreted by the shell when it is invoked:
.sp
.ne 2
.mk
.na
.B -c
.ad
.RS 15n
.rt
If the
.B -c
option is present, then commands are read from the first
.IR arg .
Any remaining arguments become positional parameters starting at
.BR 0 .
.RE

.sp
.ne 2
.mk
.na
.B -D
.ad
.RS 15n
.rt
A list of all double quoted strings that are preceded by a
.B $
is
printed on standard output and the shell exits. This set of strings is
subject to language translation when the locale is not C or POSIX. No
commands are executed.
.RE

.sp
.ne 2
.mk
.na
.B -i
.ad
.RS 15n
.rt
If the
.B -i
option is present or if the shell input and output are
attached to a terminal (as told by
.BR tcgetattr (3C),
this shell is
interactive. In this case
.B TERM
is ignored (so that
.B "kill 0"
does
not kill an interactive shell) and
.B INTR
is caught and ignored (so that
wait is interruptible). In all cases,
.B QUIT
is ignored by the shell.
.RE

.sp
.ne 2
.mk
.na
.B -R
.I filename
.ad
.RS 15n
.rt
The
.B -R
.I filename
option is used to generate a cross reference
database that can be used by a separate utility to find definitions and
references for variables and commands.
.RE

.sp
.ne 2
.mk
.na
.B -r
.ad
.RS 15n
.rt
If the
.B -r
option is present, the shell is a restricted shell.
.RE

.sp
.ne 2
.mk
.na
.B -s
.ad
.RS 15n
.rt
If the
.B -s
option is present or if no arguments remain, then commands
are read from the standard input. Shell output, except for the output of the
.B Special Commands
listed, is written to file descriptor 2.
.RE

.sp
.LP
The remaining options and arguments are described under the
.BR set
command. An optional
.B -
as the first argument is ignored.
.SS "\fBrksh93\fR Only"
.sp
.LP
.B rksh93
is used to set up login names and execution environments whose
capabilities are more controlled than those of the standard shell.
.sp
.LP
The actions of
.B rksh93
are identical to those of
.BR ksh93 ,
except
that the following are disallowed:
.RS +4
.TP
.ie t \(bu
.el o
Unsetting the restricted option
.RE
.RS +4
.TP
.ie t \(bu
.el o
Changing directory. See
.BR cd (1).
.RE
.RS +4
.TP
.ie t \(bu
.el o
Setting or unsetting the value or attributes of
.BR SHELL ,
.BR ENV ,
.BR FPATH ,
or
.BR PATH
.RE
.RS +4
.TP
.ie t \(bu
.el o
Specifying path or command names containing
.BR / ,
.RE
.RS +4
.TP
.ie t \(bu
.el o
Redirecting output
.RB ( > ,
.BR >| ,
.BR <> ,
and
.BR >> ).
.RE
.RS +4
.TP
.ie t \(bu
.el o
Adding or deleting built-in commands.
.RE
.RS +4
.TP
.ie t \(bu
.el o
Using
.B "command -p"
to invoke a command.
.RE
.sp
.LP
.RB "These restrictions are enforced after ." profile " and the " ENV 
files are interpreted.
.sp
.LP
When a command to be executed is found to be a shell procedure,
.B rksh93
invokes
.B ksh93
to execute it. Thus, it is possible to
provide to the end-user shell procedures that have access to the full power
of the standard shell, while imposing a limited menu of commands. This
scheme assumes that the end-user does not have write and execute permissions
in the same directory. The net effect of these rules is that the writer of
the .\fBprofile\fR has complete control over user actions, by performing
guaranteed setup actions and leaving the user in an appropriate directory
(probably not the login directory). The system administrator often sets up a
directory of commands, for example,
.BR /usr/rbin ,
that can be safely
invoked by
.BR rksh .
.SH USAGE
.sp
.LP
See
.BR largefile (5)
for the description of the behavior of
.BR ksh93
and
.B rksh93
when encountering files greater than or equal to 2 Gbyte (
2^31 bytes).
.SH EXIT STATUS
.sp
.LP
The following exit values are returned:
.sp
.ne 2
.mk
.na
.B non-zero
.ad
.sp .6
.RS 4n
Returns
.B non-zero
when errors, such as syntax errors, are detected by
the shell.
.sp
If the shell is being used non-interactively, then execution of the shell
file is abandoned unless the error occurs inside a sub-shell in which case
the sub-shell is abandoned.
.RE

.sp
.ne 2
.mk
.na
.I "exit status of last command executed
.ad
.sp .6
.RS 4n
Returns the exit status of the last command executed.
.sp
Run time errors detected by the shell are reported by printing the command
or function name and the error condition. If the line number that the error
occurred on is greater than one, then the line number is also printed in
square brackets
.RB ( [] )
after the command or function name.
.sp
See the
.B "ksh93 exit"
command for additional details.
.RE

.SH FILES
.sp
.ne 2
.mk
.na
.B /etc/profile
.ad
.sp .6
.RS 4n
The system initialization file, executed for login shells.
.RE

.sp
.ne 2
.mk
.na
.B /etc/ksh.kshrc
.ad
.sp .6
.RS 4n
The system wide startup file, executed for interactive shells.
.RE

.sp
.ne 2
.mk
.na
.B $HOME/.profile
.ad
.sp .6
.RS 4n
The personal initialization file, executed for login shells after
.BR /etc/profile .
.RE

.sp
.ne 2
.mk
.na
.B $HOME/.kshrc
.ad
.sp .6
.RS 4n
Default personal initialization file, executed after
.BR /etc/ksh.kshrc ,
for interactive shells when
.B ENV
is not set.
.RE

.sp
.ne 2
.mk
.na
.B /etc/suid-profile
.ad
.sp .6
.RS 4n
Alternative initialization file, executed instead of the personal
initialization file when the real and effective user or group id do not
match.
.RE

.sp
.ne 2
.mk
.na
.B /dev/null
.ad
.sp .6
.RS 4n
NULL device.
.RE

.SH AUTHORS
.sp
.LP
.RB "David Korn," " dgk@research.att.com"
.SH ATTRIBUTES
.sp
.LP
See
.BR attributes (5)
for descriptions of the following attributes:
.sp

.sp
.TS
tab() box;
cw(2.75i) |cw(2.75i)
lw(2.75i) |lw(2.75i)
.
ATTRIBUTE TYPEATTRIBUTE VALUE
_
AvailabilitySUNWcsu
_
Interface StabilitySee below.
.TE

.sp
.LP
The scripting interface is Uncommitted. The environment variables,
\fB\&.paths\fR feature, and editing modes are Volatile.
.SH SEE ALSO
.sp
.LP
.BR cat (1),
.BR cd (1),
.BR chmod (1),
.BR cut (1),
.BR date (1),
.BR egrep (1),
.BR echo (1),
.BR egrep (1),
.BR env (1),
.BR fgrep (1),
.BR grep (1),
.BR login (1),
.BR newgrp (1),
.BR paste (1),
.BR printf (1),
.BR stty (1),
.BR test (1),
.BR umask (1),
.BR vi (1),
.BR dup (2),
.BR exec (2),
.BR fork (2),
.BR ioctl (2),
.BR lseek (2),
.BR pathconf (2),
.BR pipe (2),
.BR sysconf (3C),
.BR ulimit (2),
.BR umask (2),
\fBrand\fR(3C)\fBtcgetattr\fR(3C), \fBwait\fR(3C),
.BR a.out (4),
.BR profile (4),
.BR attributes (5),
.BR environ (5),
.BR largefile (5),
.BR standards (5)
.sp
.LP
Bolsky, Morris I. and Korn, David G., \fIThe New KornShell Command and Programming Language\fR, Prentice Hall, 1995.
.sp
.LP
\fIPOSIX-Part 2: Shell and Utilities, IEEE Std 1003.2-1992, ISO/IEC
9945-2\fR, IEEE, 1993.
.SH NOTES
.sp
.LP
.B ksh93
scripts should choose shell function names outside the
namespace used by reserved keywords of the ISO C99, C++ and JAVA languages
to avoid collisions with future enhancements to
.BR ksh93 .
.sp
.LP
If a command is executed, and then a command with the same name is
installed in a directory in the search path before the directory where the
original command was found, the shell continues to
.B exec
the original
command. Use the
.B -t
option of the alias command to correct this
situation.
.sp
.LP
Some very old shell scripts contain a caret
.RB ( ^ )
as a synonym for the
pipe character
.RB ( | ).
.sp
.LP
Using the
.B hist
built-in command within a compound command causes the
whole command to disappear from the history file.
.sp
.LP
The built-in command
.BR \&. " "
.I file
reads the whole file before any
commands are executed.
.B alias
and
.B unalias
commands in the file do
not apply to any commands defined in the file.
.sp
.LP
Traps are not processed while a job is waiting for a foreground process.
Thus, a trap on
.B CHLD
is not executed until the foreground job
terminates.
.sp
.LP
It is a good idea to leave a space after the comma operator in arithmetic
expressions to prevent the comma from being interpreted as the decimal point
character in certain locales.
.sp
.LP
There might be some restrictions on creating a \fB\&.paths\fR file which is
portable across other operating systems.
.sp
.LP
If the system supports the 64-bit instruction set,
.B /bin/ksh93
executes the 64-bit version of
.BR ksh93 .
