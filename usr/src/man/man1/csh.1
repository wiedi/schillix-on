'\" te
.\" Copyright 1989 AT&T
.\" Copyright (c) 2007 Sun Microsystems, Inc. All Rights Reserved.
.\" CDDL HEADER START
.\"
.\" The contents of this file are subject to the terms of the
.\" Common Development and Distribution License (the "License").
.\" You may not use this file except in compliance with the License.
.\"
.\" You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
.\" or http://www.opensolaris.org/os/licensing.
.\" See the License for the specific language governing permissions
.\" and limitations under the License.
.\"
.\" When distributing Covered Code, include this CDDL HEADER in each
.\" file and include the License file at usr/src/OPENSOLARIS.LICENSE.
.\" If applicable, add the following below this CDDL HEADER, with the
.\" fields enclosed by brackets "[]" replaced with your own identifying
.\" information: Portions Copyright [yyyy] [name of copyright owner]
.\"
.\" CDDL HEADER END
.TH csh 1 "27 Jul 2007" "SunOS 5.11" "User Commands"
.SH NAME
csh \- shell command interpreter with a C-like syntax
.SH SYNOPSIS
.LP
.nf
\fBcsh\fR [\fB-bcefinstvVxX\fR] [\fIargument\fR]...
.fi

.SH DESCRIPTION
.sp
.LP
.BR csh ,
the C shell, is a command interpreter with a syntax reminiscent
of the C language. It provides a number of convenient features for
interactive use that are not available with the Bourne shell, including
filename completion, command aliasing, history substitution, job control,
and a number of built-in commands. As with the Bourne shell, the C shell
provides variable, command and filename substitution.
.SS "Initialization and Termination"
.sp
.LP
When first started, the C shell normally performs commands from the
\fB\&.cshrc\fR file in your home directory, provided that it is readable and
you either own it or your real group
.B ID
matches its group
.BR ID .
If
the shell is invoked with a name that starts with `\fB\(mi\fR\&', as when
started by
.BR login (1),
the shell runs as a
.B login
shell.
.sp
.LP
If the shell is a login shell, this is the sequence of invocations: First,
commands in
.B /etc/.login
are executed. Next, commands from the
\fB\&.cshrc\fR file your \fBhome\fR directory are executed. Then the shell
executes commands from the \fB\&.login\fR file in your home directory; the
same permission checks as those for \fB\&.cshrc\fR are applied to this file.
Typically, the \fB\&.login\fR file contains commands to specify the terminal
type and environment. (For an explanation of file interpreters, see
\fBCommand Execution\fR and \fBexec\fR(2).)
.sp
.LP
As a login shell terminates, it performs commands from the \fB\&.logout\fR
file in your home directory; the same permission checks as those for
\fB\&.cshrc\fR are applied to this file.
.SS "Interactive Operation"
.sp
.LP
After startup processing is complete, an interactive C shell begins reading
commands from the terminal, prompting with \fBhostname\fB%\fR (or
\fBhostname\fB#\fR for the privileged user). The shell then repeatedly
performs the following actions: a line of command input is read and broken
into
.IR words .
This sequence of words is placed on the history list and
then parsed, as described under USAGE. Finally, the shell executes each
command in the current line.
.SS "Noninteractive Operation"
.sp
.LP
When running noninteractively, the shell does not prompt for input from the
terminal. A noninteractive C shell can execute a command supplied as an
\fIargument\fR on its command line, or interpret commands from a file, also
known as a script.
.SH OPTIONS
.sp
.LP
The following options are supported:
.sp
.ne 2
.mk
.na
.B -b
.ad
.RS 6n
.rt
Forced a "break" from option processing. Subsequent command line arguments
are not interpreted as C shell options. This allows the passing of options
to a script without confusion. The shell does not run set-user-ID or
set-group-ID scripts unless this option is present.
.RE

.sp
.ne 2
.mk
.na
.B -c
.ad
.RS 6n
.rt
Executes the first
.IR argument ,
which must be present. Remaining
arguments are placed in
.BR argv ,
the argument-list variable, and passed
directly to
.BR csh .
.RE

.sp
.ne 2
.mk
.na
.B -e
.ad
.RS 6n
.rt
Exits if a command terminates abnormally or yields a nonzero exit status.
.RE

.sp
.ne 2
.mk
.na
\fB-f\fR
.ad
.RS 6n
.rt
Fast start. Reads neither the \fB\&.cshrc\fR file, nor the \fB\&.login\fR
file (if a login shell) upon startup.
.RE

.sp
.ne 2
.mk
.na
.B -i
.ad
.RS 6n
.rt
Forced interactive. Prompts for command line input, even if the standard
input does not appear to be a terminal (character-special device).
.RE

.sp
.ne 2
.mk
.na
.B -n
.ad
.RS 6n
.rt
Parses (interprets), but does not execute commands. This option can be used
to check C shell scripts for syntax errors.
.RE

.sp
.ne 2
.mk
.na
.B -s
.ad
.RS 6n
.rt
Takes commands from the standard input.
.RE

.sp
.ne 2
.mk
.na
.B -t
.ad
.RS 6n
.rt
Reads and executes a single command line. A `\fB\e\fR\&' (backslash) can be
used to escape each newline for continuation of the command line onto
subsequent input lines.
.RE

.sp
.ne 2
.mk
.na
.B -v
.ad
.RS 6n
.rt
Verbose. Sets the
.B verbose
predefined variable. Command input is
echoed after history substitution, but before other substitutions and before
execution.
.RE

.sp
.ne 2
.mk
.na
.B -V
.ad
.RS 6n
.rt
Sets
.B verbose
before reading \fB\&.cshrc\fR.
.RE

.sp
.ne 2
.mk
.na
.B -x
.ad
.RS 6n
.rt
Echo. Sets the
.B echo
variable. Echoes commands after all substitutions
and just before execution.
.RE

.sp
.ne 2
.mk
.na
.B -X
.ad
.RS 6n
.rt
Sets
.B echo
before reading \fB\&.cshrc\fR.
.RE

.sp
.LP
Except with the options
.BR -c ,
.BR -i ,
.BR -s ,
or
.BR -t ,
the
first nonoption
.I argument
is taken to be the name of a command or
script. It is passed as argument zero, and subsequent arguments are added to
the argument list for that command or script.
.SH USAGE
.SS "Filename Completion"
.sp
.LP
When enabled by setting the variable
.BR filec ,
an interactive C shell
can complete a partially typed filename or user name. When an unambiguous
partial filename is followed by an
.B ESC
character on the terminal input
line, the shell fills in the remaining characters of a matching filename
from the working directory.
.sp
.LP
If a partial filename is followed by the
.B EOF
character (usually typed
as Control-d), the shell lists all filenames that match. It then prompts
once again, supplying the incomplete command line typed in so far.
.sp
.LP
When the last (partial) word begins with a tilde
.RB ( ~ ),
the shell
attempts completion with a user name, rather than a file in the working
directory.
.sp
.LP
The terminal bell signals errors or multiple matches. This bell signal can
be inhibited by setting the variable
.BR nobeep .
You can exclude files
with certain suffixes by listing those suffixes in the variable
\fBfignore\fR. If, however, the only possible completion includes a suffix
in the list, it is not ignored. \fBfignore\fR does not affect the listing of
filenames by the
.B EOF
character.
.SS "Lexical Structure"
.sp
.LP
The shell splits input lines into words at space and tab characters, except
as noted below. The characters
.BR & ,
.BR | ,
.BR ; ,
.BR < ,
.BR > ,
.BR ( ,
and
.B )
form separate words; if paired, the pairs form single
words. These shell metacharacters can be made part of other words, and their
special meaning can be suppressed by preceding them with a `\fB\e\fR\&'
(backslash). A newline preceded by a \fB\e\fR is equivalent to a space
character.
.sp
.LP
In addition, a string enclosed in matched pairs of single-quotes
(\fB\&'\fR), double-quotes (\fB"\fR), or backquotes (\fB`\fR), forms a
partial word. Metacharacters in such a string, including any space or tab
characters, do not form separate words. Within pairs of backquote (\fB`\fR)
or double-quote (\fB"\fR) characters, a newline preceded by a `\fB\e\fR\&'
(backslash) gives a true newline character. Additional functions of each
type of quote are described, below, under \fBVariable Substitution\fR,
.BR "Command Substitution" ,
and
.BR "Filename Substitution" .
.sp
.LP
When the shell's input is not a terminal, the character
.B #
introduces
a comment that continues to the end of the input line. Its special meaning
is suppressed when preceded by a \fB\e\fR or enclosed in matching quotes.
.SS "Command Line Parsing"
.sp
.LP
A
.I "simple command"
is composed of a sequence of words. The first word
(that is not part of an I/O redirection) specifies the command to be
executed. A simple command, or a set of simple commands separated by \fB|\fR
or
.B |&
characters, forms a
.IR pipeline .
With
.BR | ,
the standard
output of the preceding command is redirected to the standard input of the
command that follows. With \fB|\|&\fR, both the standard error and the
standard output are redirected through the pipeline.
.sp
.LP
Pipelines can be separated by semicolons (\|\fB;\fR\|), in which case they
are executed sequentially. Pipelines that are separated by
.B &&
or
\fB|\||\fR form conditional sequences in which the execution of pipelines on
the right depends upon the success or failure, respectively, of the pipeline
on the left.
.sp
.LP
A pipeline or sequence can be enclosed within parentheses `()' to form a
simple command that can be a component in a pipeline or sequence.
.sp
.LP
A sequence of pipelines can be executed asynchronously or "in the
background" by appending an `\fB&\fR\&'; rather than waiting for the
sequence to finish before issuing a prompt, the shell displays the job
number (see
.BR "Job Control" ,
below) and associated process IDs and prompts
immediately.
.SS "History Substitution"
.sp
.LP
History substitution allows you to use words from previous command lines in
the command line you are typing. This simplifies spelling corrections and
the repetition of complicated commands or arguments. Command lines are saved
in the history list, the size of which is controlled by the \fBhistory\fR
variable. The most recent command is retained in any case. A history
substitution begins with a
.B !
(although you can change this with the
\fBhistchars\fR variable) and occurs anywhere on the command line; history
substitutions do not nest. The
.B !
can be escaped with \fB\e\fR to
suppress its special meaning.
.sp
.LP
Input lines containing history substitutions are echoed on the terminal
after being expanded, but before any other substitutions take place or the
command gets executed.
.SS "Event Designators"
.sp
.LP
An event designator is a reference to a command line entry in the history
list.
.sp
.ne 2
.mk
.na
.B !
.ad
.sp .6
.RS 4n
Start a history substitution, except when followed by a space character,
tab, newline,
.B =
or
.BR ( .
.RE

.sp
.ne 2
.mk
.na
.B !!
.ad
.sp .6
.RS 4n
Refer to the previous command. By itself, this substitution repeats the
previous command.
.RE

.sp
.ne 2
.mk
.na
\fB!\fIn\fR
.ad
.sp .6
.RS 4n
Refer to command line
.IR n .
.RE

.sp
.ne 2
.mk
.na
\fB!\fB-n\fR
.ad
.sp .6
.RS 4n
Refer to the current command line minus
.IR n .
.RE

.sp
.ne 2
.mk
.na
\fB!\fIstr\fR
.ad
.sp .6
.RS 4n
Refer to the most recent command starting with
.IR str .
.RE

.sp
.ne 2
.mk
.na
\fB!?\fIstr\fB?\fR
.ad
.sp .6
.RS 4n
Refer to the most recent command containing
.IR str .
.RE

.sp
.ne 2
.mk
.na
\fB!?\fIstr\fB?\fR \fIadditional\fR
.ad
.sp .6
.RS 4n
Refer to the most recent command containing
.I str
and append
\fIadditional\fR to that referenced command.
.RE

.sp
.ne 2
.mk
.na
\fB!{\fIcommand\fB}\fR \fIadditional\fR
.ad
.sp .6
.RS 4n
Refer to the most recent command beginning with
.I command
and append
\fIadditional\fR to that referenced command.
.RE

.sp
.ne 2
.mk
.na
\fB^\fIprevious_word\fB^\fIreplacement\fB^\fR
.ad
.sp .6
.RS 4n
Repeat the previous command line replacing the string
.IR previous_word
with the string
.IR replacement .
This is equivalent to the history
substitution:
.sp
.in +2
.nf
!:s/\fIprevious_word\fR/\fIreplacement\fR/.
.fi
.in -2
.sp

To re-execute a specific previous command AND make such a substitution,
say, re-executing command #6,
.sp
.in +2
.nf
!:6s/\fIprevious_word\fR/\fIreplacement\fR/.
.fi
.in -2
.sp

.RE

.SS "Word Designators"
.sp
.LP
A `\fB:\fR' (colon) separates the event specification from the word
designator. It can be omitted if the word designator begins with a \fB^\fR,
.BR $ ,
.BR * ,
\fB\(mi\fR or
.BR % .
If the word is to be selected from
the previous command, the second
.B !
character can be omitted from the
event specification. For instance,
.B !!:1
and
.B !:1
both refer to
the first word of the previous command, while
.B !!$
and
.B !$
both
refer to the last word in the previous command. Word designators include:
.sp
.ne 2
.mk
.na
.B #
.ad
.RS 10n
.rt
The entire command line typed so far.
.RE

.sp
.ne 2
.mk
.na
.B 0
.ad
.RS 10n
.rt
The first input word (command).
.RE

.sp
.ne 2
.mk
.na
.I n
.ad
.RS 10n
.rt
The
.IR n "'th argument."
.RE

.sp
.ne 2
.mk
.na
.B ^
.ad
.RS 10n
.rt
The first argument, that is, \fB1\fR.
.RE

.sp
.ne 2
.mk
.na
.B $
.ad
.RS 10n
.rt
The last argument.
.RE

.sp
.ne 2
.mk
.na
.B %
.ad
.RS 10n
.rt
The word matched by the \fB?\fIs\fR search.
.RE

.sp
.ne 2
.mk
.na
\fIx\fB\(mi\fIy\fR
.ad
.RS 10n
.rt
A range of words; \fB\(mi\fIy\fR abbreviates \fB0\(mi\fIy\fR.
.RE

.sp
.ne 2
.mk
.na
.B *
.ad
.RS 10n
.rt
All the arguments, or a null value if there is just one word in the
event.
.RE

.sp
.ne 2
.mk
.na
\fIx\fB*\fR
.ad
.RS 10n
.rt
Abbreviates \fIx\fB\(mi$\fI\&.\fR
.RE

.sp
.ne 2
.mk
.na
\fIx\fB\(mi\fR
.ad
.RS 10n
.rt
Like
.I x*
but omitting word
.BR $ .
.RE

.SS "Modifiers"
.sp
.LP
After the optional word designator, you can add one of the following
modifiers, preceded by a \fB:\fR.
.sp
.ne 2
.mk
.na
.B h
.ad
.RS 10n
.rt
Remove a trailing pathname component, leaving the head.
.RE

.sp
.ne 2
.mk
.na
.B r
.ad
.RS 10n
.rt
Remove a trailing suffix of the form `\fB\&.\fIxxx\fR', leaving the
basename.
.RE

.sp
.ne 2
.mk
.na
.B e
.ad
.RS 10n
.rt
Remove all but the suffix, leaving the Extension.
.RE

.sp
.ne 2
.mk
.na
\fBs/\fIl\fB/\fIr\fB/\fR
.ad
.RS 10n
.rt
Substitute
.I r
for
.IR l .
.RE

.sp
.ne 2
.mk
.na
.B t
.ad
.RS 10n
.rt
Remove all leading pathname components, leaving the tail.
.RE

.sp
.ne 2
.mk
.na
.B &
.ad
.RS 10n
.rt
Repeat the previous substitution.
.RE

.sp
.ne 2
.mk
.na
.B g
.ad
.RS 10n
.rt
Apply the change to the first occurrence of a match in each word, by
prefixing the above (for example, \fBg&\fR).
.RE

.sp
.ne 2
.mk
.na
.B p
.ad
.RS 10n
.rt
Print the new command but do not execute it.
.RE

.sp
.ne 2
.mk
.na
.B q
.ad
.RS 10n
.rt
Quote the substituted words,escaping further substitutions.
.RE

.sp
.ne 2
.mk
.na
.B x
.ad
.RS 10n
.rt
Like
.BR q ,
but break into words at each space character, tab or
newline.
.RE

.sp
.LP
Unless preceded by a
.BR g ,
the modification is applied only to the first
string that matches
.IR l ;
an error results if no string matches.
.sp
.LP
The left-hand side of substitutions are not regular expressions, but
character strings. Any character can be used as the delimiter in place of
.BR / .
A backslash quotes the delimiter character. The character \fB&\fR,
in the right hand side, is replaced by the text from the left-hand-side. The
\fB&\fR can be quoted with a backslash. A null \fIl\fR uses the previous
string either from a
.I l
or from a contextual scan string
.I s
from
\fB!?\fIs\fR. You can omit the rightmost delimiter if a newline
immediately follows
.IR r ;
the rightmost
.B ?
in a context scan can
similarly be omitted.
.sp
.LP
Without an event specification, a history reference refers either to the
previous command, or to a previous history reference on the command line (if
any).
.SS "Quick Substitution"
.sp
.ne 2
.mk
.na
\fB^\fIl\fB^\fIr\fB^\fR
.ad
.RS 9n
.rt
This is equivalent to the history substitution:
.sp
.in +2
.nf
!:s/\fIl\fR/\fIr\fR/.
.fi
.in -2
.sp

.RE

.SS "Aliases"
.sp
.LP
The C shell maintains a list of aliases that you can create, display, and
modify using the
.B alias
and
.B unalias
commands. The shell checks
the first word in each command to see if it matches the name of an existing
alias. If it does, the command is reprocessed with the alias definition
replacing its name; the history substitution mechanism is made available as
though that command were the previous input line. This allows history
substitutions, escaped with a backslash in the definition, to be replaced
with actual command line arguments when the alias is used. If no history
substitution is called for, the arguments remain unchanged.
.sp
.LP
Aliases can be nested. That is, an alias definition can contain the name of
another alias. Nested aliases are expanded before any history substitutions
is applied. This is useful in pipelines such as
.sp
.in +2
.nf
\fBalias lm 'ls -l \e!* | more'\fR
.fi
.in -2
.sp

.sp
.LP
which when called, pipes the output of
.BR ls (1)
through
.BR more (1).
.sp
.LP
Except for the first word, the name of the alias can not appear in its
definition, nor in any alias referred to by its definition. Such loops are
detected, and cause an error message.
.SS "I/O Redirection"
.sp
.LP
The following metacharacters indicate that the subsequent word is the name
of a file to which the command's standard input, standard output, or
standard error is redirected; this word is variable, command, and filename
expanded separately from the rest of the command.
.sp
.ne 2
.mk
.na
.B <
.ad
.RS 15n
.rt
Redirect the standard input.
.RE

.sp
.ne 2
.mk
.na
\fB<\|<\fI\|word\fR
.ad
.RS 15n
.rt
Read the standard input, up to a line that is identical with \fIword\fR,
and place the resulting lines in a temporary file. Unless
.I word
is
escaped or quoted, variable and command substitutions are performed on these
lines. Then, the pipeline is invoked with the temporary file as its standard
input.
.I word
is not subjected to variable, filename, or command
substitution, and each line is compared to it before any substitutions are
performed by the shell.
.RE

.sp
.ne 2
.mk
.na
.B "> >!" >& >&!
.ad
.RS 15n
.rt
Redirect the standard output to a file. If the file does not exist, it is
created. If it does exist, it is overwritten; its previous contents are
lost.
.sp
When set, the variable
.B noclobber
prevents destruction of existing
files. It also prevents redirection to terminals and
.BR /dev/null ,
unless
one of the
.B !
forms is used. The
.B &
forms redirect both standard
output and the standard error (diagnostic output) to the file.
.RE

.sp
.ne 2
.mk
.na
\fB>\|>\fR \fB>\|>&\fR \fB>\|>!\fR \fB>\|>&!\fR
.ad
.RS 27n
.rt
Append the standard output. Like
.BR > ,
but places output at the end of
the file rather than overwriting it. If
.B noclobber
is set, it is an
error for the file not to exist, unless one of the
.B !
forms is used.
The
.B &
forms append both the standard error and standard output to the
file.
.RE

.SS "Variable Substitution"
.sp
.LP
The C shell maintains a set of variables, each of which is composed of a
\fIname\fR and a
.IR value .
A variable name consists of up to 128 letters
and digits, and starts with a letter. An underscore (\fB_\fR) is considered
a letter). A variable's value is a space-separated list of zero or more
words. If the shell supports a variable name upto 128 characters the
variable
.B SUNW_VARLEN
is defined. If a variable name of up to 128
characters is not supported, then an older version of the shell is being
used, and the shell variable name length has a maximum length of 20.
.sp
.LP
To refer to a variable's value, precede its name with a `\fB$\fR'. Certain
references (described below) can be used to select specific words from the
value, or to display other information about the variable. Braces can be
used to insulate the reference from other characters in an input-line
word.
.sp
.LP
Variable substitution takes place after the input line is analyzed, aliases
are resolved, and I/O redirections are applied. Exceptions to this are
variable references in I/O redirections (substituted at the time the
redirection is made), and backquoted strings (see Command Substitution).
.sp
.LP
Variable substitution can be suppressed by preceding the
.B $
with a
\fB\e\fR, except within double-quotes where it always occurs. Variable
substitution is suppressed inside of single-quotes. A
.B $
is escaped if
followed by a space character, tab or newline.
.sp
.LP
Variables can be created, displayed, or destroyed using the
.B set
and
\fBunset\fR commands. Some variables are maintained or used by the shell.
For instance, the
.B argv
variable contains an image of the shell's
argument list. Of the variables used by the shell, a number are toggles; the
shell does not care what their value is, only whether they are set or not.
.sp
.LP
.RB "Numerical values can be operated on as numbers (as with the" " @"
built-in command). With numeric operations, an empty value is considered to
be zero. The second and subsequent words of multiword values are ignored.
For instance, when the
.B verbose
variable is set to any value (including
an empty value), command input is echoed on the terminal.
.sp
.LP
Command and filename substitution is subsequently applied to the words that
result from the variable substitution, except when suppressed by
double-quotes, when
.B noglob
is set (suppressing filename substitution),
or when the reference is quoted with the
.B :q
modifier. Within
double-quotes, a reference is expanded to form (a portion of) a quoted
string; multiword values are expanded to a string with embedded space
characters. When the
.B :q
modifier is applied to the reference, it is
expanded to a list of space-separated words, each of which is quoted to
prevent subsequent command or filename substitutions.
.sp
.LP
Except as noted below, it is an error to refer to a variable that is not
set.
.sp
.ne 2
.mk
.na
\fB$\fIvar\fR
.ad
.br
.na
\fB${\fIvar\fB}\fR
.ad
.RS 17n
.rt
These are replaced by words from the value of
.IR var ,
each separated by
a space character. If
.I var
is an environment variable, its value is
returned (but `\fB:\fR' modifiers and the other forms given below are not
available).
.RE

.sp
.ne 2
.mk
.na
\fB$\fIvar\fB[\fIindex\fB]\fR
.ad
.br
.na
\fB${\fIvar\fB[\fIindex\fB]}\fR
.ad
.RS 17n
.rt
These select only the indicated words from the value of
.IR var .
Variable
substitution is applied to
.IR index \|,
which can consist of (or result
in) a either single number, two numbers separated by a `\fB\(mi\fR\&', or an
asterisk. Words are indexed starting from 1; a `\fB*\fR' selects all words.
If the first number of a range is omitted (as with \fB$argv[\(mi2]\fR), it
defaults to 1. If the last number of a range is omitted (as with
\fB$argv[1\(mi]\fR), it defaults to \fB$#\fIvar\fR (the word count). It
is not an error for a range to be empty if the second argument is omitted
(or within range).
.RE

.sp
.ne 2
.mk
.na
\fB$#\fIname\fR
.ad
.br
.na
\fB${#\fIname\fB}\fR
.ad
.RS 17n
.rt
These give the number of words in the variable.
.RE

.sp
.ne 2
.mk
.na
.B $0
.ad
.RS 17n
.rt
This substitutes the name of the file from which command input is being
read except for setuid shell scripts. An error occurs if the name is not
known.
.RE

.sp
.ne 2
.mk
.na
\fB$\fIn\fR
.ad
.br
.na
\fB${\fIn\fB}\fR
.ad
.RS 17n
.rt
Equivalent to \fB$argv[\fIn\fB]\fI\&.\fR
.RE

.sp
.ne 2
.mk
.na
.B $*
.ad
.RS 17n
.rt
Equivalent to \fB$argv[*]\fR.
.RE

.sp
.LP
The modifiers
.BR :e ,
.BR :h ,
.BR :q ,
.BR :r ,
.BR :t ,
and
\fB:x\fR can be applied (see
.BR "History Substitution" ),
as can
.BR :gh ,
.BR :gt ,
and
.BR :gr .
If \fB{\|}\fR (braces) are used, then
the modifiers must appear within the braces. The current implementation
allows only one such modifier per expansion.
.sp
.LP
The following references can not be modified with
.B :
modifiers.
.sp
.ne 2
.mk
.na
\fB$?\fIvar\fR
.ad
.br
.na
\fB${?\fIvar\fB}\fR
.ad
.RS 11n
.rt
Substitutes the string 1 if
.I var
is set or 0 if it is not set.
.RE

.sp
.ne 2
.mk
.na
.B $?0
.ad
.RS 11n
.rt
Substitutes 1 if the current input filename is known or 0 if it is not.
.RE

.sp
.ne 2
.mk
.na
.B $$
.ad
.RS 11n
.rt
Substitutes the process number of the (parent) shell.
.RE

.sp
.ne 2
.mk
.na
.B $<
.ad
.RS 11n
.rt
Substitutes a line from the standard input, with no further interpretation
thereafter. It can be used to read from the keyboard in a C shell script.
.RE

.SS "Command and Filename Substitutions"
.sp
.LP
Command and filename substitutions are applied selectively to the arguments
of built-in commands. Portions of expressions that are not evaluated are not
expanded. For non-built-in commands, filename expansion of the command name
is done separately from that of the argument list; expansion occurs in a
subshell, after I/O redirection is performed.
.SS "Command Substitution"
.sp
.LP
A command enclosed by backquotes (\|\fB`\fR\|.\|.\|.\|\fB`\fR\|) is
performed by a subshell. Its standard output is broken into separate words
at each space character, tab and newline; null words are discarded. This
text replaces the backquoted string on the current command line. Within
double-quotes, only newline characters force new words; space and tab
characters are preserved. However, a final newline is ignored. It is
therefore possible for a command substitution to yield a partial word.
.SS "Filename Substitution"
.sp
.LP
Unquoted words containing any of the characters \fB*\fR, \fB?\fR, \fB[\fR
or
.BR { ,
or that begin with ~, are expanded (also known as
.IR globbing )
to an alphabetically sorted list of filenames, as follows:
.sp
.ne 2
.mk
.na
.B *
.ad
.RS 24n
.rt
Match any (zero or more) characters.
.RE

.sp
.ne 2
.mk
.na
.B ?
.ad
.RS 24n
.rt
Match any single character.
.RE

.sp
.ne 2
.mk
.na
\fB[\fR.\|.\|.\fB]\fR
.ad
.RS 24n
.rt
Match any single character in the enclosed list(s) or range(s). A list is a
string of characters. A range is two characters separated by a dash
(\fB\(mi\fR), and includes all the characters in between in the \fBASCII\fR
collating sequence (see \fBascii\fR(5)).
.RE

.sp
.ne 2
.mk
.na
\fB{\fIstr\fB,\fR \fIstr\fB,\fR .\|.\|. \fB}\fR
.ad
.RS 24n
.rt
Expand to each string (or filename-matching pattern) in the comma-separated
list. Unlike the pattern-matching expressions above, the expansion of this
construct is not sorted. For instance, \fB{b,a}\fR expands to `\fBb\fR'
`\fBa\fR', (not `\fBa\fR' `\fBb\fR'). As special cases, the characters
\fB{\fR and
.BR } ,
along with the string \fB{\|}\fR, are passed
undisturbed.
.RE

.sp
.ne 2
.mk
.na
\fB~[\fIuser\fR]\fR
.ad
.RS 24n
.rt
Your home directory, as indicated by the value of the variable \fBhome\fR,
or that of
.IR user ,
as indicated by the password entry for
.IR user .
.RE

.sp
.LP
Only the patterns \fB*\fR, \fB?\fR and \fB[\fR.\|.\|.\fB]\fR imply pattern
matching; an error results if no filename matches a pattern that contains
them. The `\fB\&.\fR' (dot character), when it is the first character in a
filename or pathname component, must be matched explicitly. The \fB/\fR
(slash) must also be matched explicitly.
.SS "Expressions and Operators"
.sp
.LP
A number of C shell built-in commands accept expressions, in which the
operators are similar to those of C and have the same precedence. These
expressions typically appear in the
.BR @ ,
.BR exit ,
\fBif\fR, \fBset\fR
and
.B while
commands, and are often used to regulate the flow of control
for executing commands. Components of an expression are separated by white
space.
.sp
.LP
Null or missing values are considered
.BR 0 .
The result of all
expressions is a string, which can represent decimal numbers.
.sp
.LP
The following C shell operators are grouped in order of precedence:
.sp
.ne 2
.mk
.na
\fB(\|\fR.\|.\|.\|\fB\|)\fR
.ad
.RS 19n
.rt
grouping
.RE

.sp
.ne 2
.mk
.na
\fB>\fB~\fR
.ad
.RS 19n
.rt
one's complement
.RE

.sp
.ne 2
.mk
.na
.B !
.ad
.RS 19n
.rt
logical negation
.RE

.sp
.ne 2
.mk
.na
.B * / %
.ad
.RS 19n
.rt
multiplication, division, remainder. These are right associative, which can
lead to unexpected results. Combinations should be grouped explicitly with
parentheses.
.RE

.sp
.ne 2
.mk
.na
\fB+ \(mi\fR
.ad
.RS 19n
.rt
addition, subtraction (also right associative)
.RE

.sp
.ne 2
.mk
.na
.B << >>
.ad
.RS 19n
.rt
bitwise shift left, bitwise shift right
.RE

.sp
.ne 2
.mk
.na
.B < > <= >=
.ad
.RS 19n
.rt
less than, greater than, less than or equal to, greater than or equal to
.RE

.sp
.ne 2
.mk
.na
\fB=\|= != =~ !~\fR
.ad
.RS 19n
.rt
equal to, not equal to, filename-substitution pattern match (described
below), filename-substitution pattern mismatch
.RE

.sp
.ne 2
.mk
.na
.B &
.ad
.RS 19n
.rt
bitwise AND
.RE

.sp
.ne 2
.mk
.na
.B ^
.ad
.RS 19n
.rt
bitwise XOR (exclusive or)
.RE

.sp
.ne 2
.mk
.na
.B |
.ad
.RS 19n
.rt
bitwise inclusive OR
.RE

.sp
.ne 2
.mk
.na
.B &&
.ad
.RS 19n
.rt
logical AND
.RE

.sp
.ne 2
.mk
.na
\fB|\|\||\fR
.ad
.RS 19n
.rt
logical OR
.RE

.sp
.LP
The operators:
.BR == ,
.BR != ,
.BR =~ ,
and
.B !~
compare their
.RB "arguments as strings; other operators use numbers. The operators" " =~"
and
.B !~
each check whether or not a string to the left matches a
filename substitution pattern on the right. This reduces the need for
\fBswitch\fR statements when pattern-matching between strings is all that is
required.
.sp
.LP
Also available are file inquiries:
.sp
.ne 2
.mk
.na
\fB-r\fIfilename\fR
.ad
.RS 15n
.rt
Return true, or 1 if the user has read access. Otherwise it returns false,
or 0.
.RE

.sp
.ne 2
.mk
.na
\fB-w\fIfilename\fR
.ad
.RS 15n
.rt
True if the user has write access.
.RE

.sp
.ne 2
.mk
.na
\fB-x\fIfilename\fR
.ad
.RS 15n
.rt
True if the user has execute permission (or search permission on a
directory).
.RE

.sp
.ne 2
.mk
.na
\fB-e\fIfilename\fR
.ad
.RS 15n
.rt
True if \fIfilename\fR exists.
.RE

.sp
.ne 2
.mk
.na
\fB-o\fIfilename\fR
.ad
.RS 15n
.rt
True if the user owns \fIfilename\fR.
.RE

.sp
.ne 2
.mk
.na
\fB-z\fR \fIfilename\fR
.ad
.RS 15n
.rt
True if \fIfilename\fR is of zero length (empty).
.RE

.sp
.ne 2
.mk
.na
\fB-f\fIfilename\fR
.ad
.RS 15n
.rt
True if \fIfilename\fR is a plain file.
.RE

.sp
.ne 2
.mk
.na
\fB-d\fIfilename\fR
.ad
.RS 15n
.rt
True if \fIfilename\fR is a directory.
.RE

.sp
.LP
If \fIfilename\fR does not exist or is inaccessible, then all inquiries
return false.
.sp
.LP
An inquiry as to the success of a command is also available:
.sp
.ne 2
.mk
.na
.BI "{ " command " }"
.ad
.RS 14n
.rt
If
.I command
runs successfully, the expression evaluates to true, 1.
Otherwise, it evaluates to false, 0.
.B Note:
.RI Conversely, " command"
itself typically returns 0 when it runs successfully, or some other value if
it encounters a problem. If you want to get at the status directly, use the
value of the
.B status
variable rather than this expression.
.RE

.SS "Control Flow"
.sp
.LP
The shell contains a number of commands to regulate the flow of control in
scripts and within limits, from the terminal. These commands operate by
forcing the shell either to reread input (to
.IR loop ),
or to skip input
under certain conditions  (to
.IR branch ).
.sp
.LP
Each occurrence of a \fBforeach\fR,
.BR switch ,
.BR while ,
\fBif\fR.\|.\|.\fBthen\fR and \fBelse\fR built-in command must appear as the
first word on its own input line.
.sp
.LP
If the shell's input is not seekable and a loop is being read, that input
is buffered. The shell performs seeks within the internal buffer to
accomplish the rereading implied by the loop. (To the extent that this
allows, backward
.B goto
commands succeeds on nonseekable inputs.)
.SS "Command Execution"
.sp
.LP
If the command is a C shell built-in command, the shell executes it
directly. Otherwise, the shell searches for a file by that name with execute
access. If the command name contains a
.BR / ,
the shell takes it as a
pathname, and searches for it. If the command name does not contain a
.BR / ,
the shell attempts to resolve it to a pathname, searching each
directory in the
.B path
variable for the command. To speed the search,
the shell uses its hash table (see the
.B rehash
built-in command) to
eliminate directories that have no applicable files. This hashing can be
disabled with the
.B -c
or
.BR -t ,
.RB "options, or the" " unhash"
built-in command.
.sp
.LP
As a special case, if there is no
.B /
in the name of the script and
there is an alias for the word
.BR shell ,
the expansion of the
.BR shell
alias is prepended (without modification) to the command line. The system
attempts to execute the first word of this special (late-occurring) alias,
which should be a full pathname. Remaining words of the alias's definition,
along with the text of the input line, are treated as arguments.
.sp
.LP
When a pathname is found that has proper execute permissions, the shell
forks a new process and passes it, along with its arguments, to the kernel
using the
.BR execve (\|)
system call (see
.BR exec (2)).
The kernel then
attempts to overlay the new process with the desired program. If the file is
an executable binary (in
.BR a.out (4)
format) the kernel succeeds and
begins executing the new process. If the file is a text file and the first
line begins with
.BR #! ,
the next word is taken to be the pathname of a
shell (or command) to interpret that script. Subsequent words on the first
line are taken as options for that shell. The kernel invokes (overlays) the
indicated shell, using the name of the script as an argument.
.sp
.LP
If neither of the above conditions holds, the kernel cannot overlay the
file and the
.BR execve (\|)
call fails (see
.BR exec (2)).
The C shell
then attempts to execute the file by spawning a new shell, as follows:
.RS +4
.TP
.ie t \(bu
.el o
If the first character of the file is a
.BR # ,
a C shell is invoked.
.RE
.RS +4
.TP
.ie t \(bu
.el o
Otherwise, a Bourne shell is invoked.
.RE
.SS "Signal Handling"
.sp
.LP
The shell normally ignores
.B QUIT
signals. Background jobs are immune
to signals generated from the keyboard, including hangups
.RB ( HUP ).
Other
signals have the values that the C shell inherited from its environment. The
shell's handling of interrupt and terminate signals within scripts can be
controlled by the
.B onintr
built-in command. Login shells catch the
\fBTERM\fR signal. Otherwise, this signal is passed on to child processes.
In no case are interrupts allowed when a login shell is reading the
\fB\&.logout\fR file.
.SS "Job Control"
.sp
.LP
The shell associates a numbered
.I job
with each command sequence to
keep track of those commands that are running in the background or have been
stopped with
.B TSTP
signals (typically Control-z). When a command or
command sequence (semicolon separated list) is started in the background
using the
.B &
metacharacter, the shell displays a line with the job
number in brackets and a list of associated process numbers:
.sp
.in +2
.nf
[1] 1234
.fi
.in -2
.sp

.sp
.LP
To see the current list of jobs, use the
.B jobs
built-in command. The
job most recently stopped (or put into the background if none are stopped)
is referred to as the
.I current
job and is indicated with a `\fB+\fR'.
The previous job is indicated with a `\fB\(mi\fR\&'. When the current job is
terminated or moved to the foreground, this job takes its place (becomes the
new current job).
.sp
.LP
To manipulate jobs, refer to the
.BR bg ,
\fBfg\fR, \fBkill\fR,
.BR stop ,
and
.B %
built-in commands.
.sp
.LP
A reference to a job begins with a `\fB%\fR'. By itself, the percent-sign
refers to the current job.
.sp
.ne 2
.mk
.na
.B "% %+" %%
.ad
.RS 12n
.rt
The current job.
.RE

.sp
.ne 2
.mk
.na
\fB%\(mi\fR
.ad
.RS 12n
.rt
The previous job.
.RE

.sp
.ne 2
.mk
.na
\fB%\fIj\fR
.ad
.RS 12n
.rt
Refer to job \fIj\fR as in: `\fBkill -9\fR \fB%\fIj\fR'. \fIj\fR
can be a job number, or a string that uniquely specifies the command line by
which it was started; `\fBfg %vi\fR' might bring a stopped
.B vi
job to
the foreground, for instance.
.RE

.sp
.ne 2
.mk
.na
\fB%?\fIstring\fR
.ad
.RS 12n
.rt
Specify the job for which the command line uniquely contains
.IR string .
.RE

.sp
.LP
A job running in the background stops when it attempts to read from the
terminal. Background jobs can normally produce output, but this can be
suppressed using the `\fBstty tostop\fR' command.
.SS "Status Reporting"
.sp
.LP
While running interactively, the shell tracks the status of each job and
reports whenever the job finishes or becomes blocked. It normally displays a
message to this effect as it issues a prompt, in order to avoid disturbing
the appearance of your input. When set, the \fBnotify\fR variable indicates
that the shell is to report status changes immediately. By default, the
\fBnotify\fR command marks the current process; after starting a background
job, type \fBnotify\fR to mark it.
.SS "Commands"
.sp
.LP
Built-in commands are executed within the C shell. If a built-in command
occurs as any component of a pipeline except the last, it is executed in a
subshell.
.sp
.ne 2
.mk
.na
.B :
.ad
.RS 26n
.rt
Null command. This command is interpreted, but performs no action.
.RE

.sp
.ne 2
.mk
.na
\fBalias\fR [ \fIname\fR [ \fIdef\fR ] ]\fR
.ad
.RS 26n
.rt
Assign \fIdef\fR to the alias
.IR name .
\fIdef\fR is a list of words that
can contain escaped history-substitution metasyntax.
.I name
is not
allowed to be
.B alias
or
.BR unalias .
If \fIdef\fR is omitted, the
current definition for the alias
.I name
is displayed. If both \fIname\fR
and \fIdef\fR are omitted, all aliases are displayed with their
definitions.
.RE

.sp
.ne 2
.mk
.na
\fBbg\fR [ \fB%\fIjob .\|.\|.\fR ]\fR
.ad
.RS 26n
.rt
Run the current or specified jobs in the background.
.RE

.sp
.ne 2
.mk
.na
.B break
.ad
.RS 26n
.rt
Resume execution after the
.B end
of the nearest enclosing \fBforeach\fR
or
.B while
loop. The remaining commands on the current line are
executed. This allows multilevel breaks to be written as a list of
\fBbreak\fR commands, all on one line.
.RE

.sp
.ne 2
.mk
.na
.B breaksw
.ad
.RS 26n
.rt
Break from a
.BR switch ,
resuming after the
.BR endsw .
.RE

.sp
.ne 2
.mk
.na
\fBcase\fR \fIlabel\fB:\fR
.ad
.RS 26n
.rt
A label in a
.B switch
statement.
.RE

.sp
.ne 2
.mk
.na
\fBcd\fR [\fIdir\fR ]\fR
.ad
.br
.na
\fBchdir\fR [\fIdir\fR ]\fR
.ad
.RS 26n
.rt
Change the shell's working directory to directory
.IR dir .
If no argument
is given, change to the home directory of the user. If
.I dir
is a
relative pathname not found in the current directory, check for it in those
directories listed in the
.B cdpath
variable. If
.I dir
is the name of
a shell variable whose value starts with a
.BR / ,
change to the directory
named by that value.
.RE

.sp
.ne 2
.mk
.na
.B continue
.ad
.RS 26n
.rt
Continue execution of the next iteration of the nearest enclosing
\fBwhile\fR or \fBforeach\fR loop.
.RE

.sp
.ne 2
.mk
.na
\fBdefault:\fR
.ad
.RS 26n
.rt
Labels the default case in a
.B switch
statement. The default should
come after all
.B case
labels. Any remaining commands on the command line
are first executed.
.RE

.sp
.ne 2
.mk
.na
\fBdirs\fR [\fB-l\fR]\fR
.ad
.RS 26n
.rt
Print the directory stack, most recent to the left. The first directory
shown is the current directory. With the
.B -l
argument, produce an
unabbreviated printout; use of the ~ notation is suppressed.
.RE

.sp
.ne 2
.mk
.na
\fBecho\fR [\fB-n\fR] \fIlist\fR
.ad
.RS 26n
.rt
The words in
.I list
are written to the shell's standard output,
separated by space characters. The output is terminated with a newline
unless the
.B -n
option is used.
.BR csh ,
by default, invokes its
built-in
.BR echo ,
if
.B echo
is called without the full pathname of a
Unix command, regardless of the configuration of your
.B PATH
(see
.BR echo (1)).
.RE

.sp
.ne 2
.mk
.na
\fBeval\fR \fIargument\fB\|.\|.\|.\fR
.ad
.RS 26n
.rt
Reads the arguments as input to the shell and executes the resulting
command(s). This is usually used to execute commands generated as the result
of command or variable substitution. See \fBtset\fR(1B) for an example of
how to use
.BR eval .
.RE

.sp
.ne 2
.mk
.na
\fBexec\fR \fIcommand\fR
.ad
.RS 26n
.rt
Execute
.I command
in place of the current shell, which terminates.
.RE

.sp
.ne 2
.mk
.na
\fBexit\fR [\fB(\fIexpr\fB)\fR]\fR
.ad
.RS 26n
.rt
The calling shell or shell script exits, either with the value of the
status variable or with the value specified by the expression
.IR expr .
.RE

.sp
.ne 2
.mk
.na
\fBfg\fR [\fB%\fIjob\fR ]\fR
.ad
.RS 26n
.rt
Bring the current or specified
.I job
into the foreground.
.RE

.sp
.ne 2
.mk
.na
\fBforeach\fR \fIvar\fB(\fIwordlist\fB)\fR
.ad
.br
.na
\fB\&.\|.\|.\fR
.ad
.br
.na
.B end
.ad
.RS 26n
.rt
The variable
.I var
is successively set to each member of
.IR wordlist .
The sequence of commands between this command and the
matching
.B end
is executed for each new value of
.IR var .
Both
\fBforeach\fR and \fBend\fR must appear alone on separate lines.
.sp
The built-in command
.B continue
can be used to terminate the execution
of the current iteration of the loop and the built-in command \fBbreak\fR
can be used to terminate execution of the \fBforeach\fR command. When this
command is read from the terminal, the loop is read once prompting with
\fB?\fR before any statements in the loop are executed.
.RE

.sp
.ne 2
.mk
.na
\fBglob\fR \fIwordlist\fR
.ad
.sp .6
.RS 4n
Perform filename expansion on
.IR wordlist .
Like
.BR echo ,
but no
\fB\e\fR escapes are recognized. Words are delimited by \fINULL\fR
characters in the output.
.RE

.sp
.ne 2
.mk
.na
\fBgoto\fIlabel\fR
.ad
.sp .6
.RS 4n
The specified
.I label
is a filename and a command expanded to yield a
label. The shell rewinds its input as much as possible and searches for a
line of the form \fIlabel\fB:\fR possibly preceded by space or tab
characters. Execution continues after the indicated line. It is an error to
jump to a label that occurs between a
.B while
or \fBfor\fR built-in
command and its corresponding
.BR end .
.RE

.sp
.ne 2
.mk
.na
.B hashstat
.ad
.sp .6
.RS 4n
Print a statistics line indicating how effective the internal hash table
for the
.I path
variable has been at locating commands (and avoiding
\fBexec\fRs). An \fBexec\fR is attempted for each component of the
\fIpath\fR where the hash function indicates a possible hit and in each
component that does not begin with a `\fB/\fR'. These statistics only
reflect the effectiveness of the
.I path
.RI "variable, not the" " cdpath"
variable.
.RE

.sp
.ne 2
.mk
.na
\fBhistory\fR [\fB-hr\fR] [\fIn\fR]\fR
.ad
.sp .6
.RS 4n
Display the history list; if
.I n
.RI "is given, display only the" " n"
most recent events.
.sp
.ne 2
.mk
.na
.B -r
.ad
.RS 6n
.rt
Reverse the order of printout to be most recent first rather than oldest
first.
.RE

.sp
.ne 2
.mk
.na
.B -h
.ad
.RS 6n
.rt
Display the history list without leading numbers. This is used to produce
files suitable for sourcing using the
.B -h
option to
.IR source .
.RE

.RE

.sp
.ne 2
.mk
.na
\fBif (\fIexpr\fR \fB)\fIcommand\fR
.ad
.sp .6
.RS 4n
If the specified expression evaluates to true, the single \fIcommand\fR
with arguments is executed. Variable substitution on
.I command
happens
early, at the same time it does for the rest of the \fBif\fR command.
\fIcommand\fR must be a simple command, not a pipeline, a command list, or a
parenthesized command list.
.B Note:
I/O redirection occurs even if
\fIexpr\fR is false, when \fIcommand\fR is \fInot\fR executed (this is a
bug).
.RE

.sp
.ne 2
.mk
.na
\fBif (\fBexpr\fB) then\fR
.ad
.br
.na
\fB\|\|\|.\|.\|.\fR
.ad
.br
.na
\fBelse if (\fIexpr2\fB) then\fR
.ad
.br
.na
\fB\|\|\|.\|.\|.\fR
.ad
.br
.na
.B else
.ad
.br
.na
\fB\|\|\|.\|.\|.\fR
.ad
.br
.na
\fBendif\fR
.ad
.sp .6
.RS 4n
If
.I expr
is true, commands up to the first
.B else
are executed.
Otherwise, if
.I expr2
is true, the commands between the \fBelse if\fR
and the second
.B else
are executed. Otherwise, commands between the
\fBelse\fR and the \fBendif\fR are executed. Any number of \fBelse if\fR
pairs are allowed, but only one
.BR else .
Only one \fBendif\fR is needed,
but it is required. The words
.B else
and \fBendif\fR must be the first
nonwhite characters on a line. The \fBif\fR must appear alone on its input
line or after an
.BR else .
.RE

.sp
.ne 2
.mk
.na
\fBjobs\fR [\fB-l\fR]\fR
.ad
.sp .6
.RS 4n
List the active jobs under job control.
.sp
.ne 2
.mk
.na
.B -l
.ad
.RS 6n
.rt
List process \fBID\fRs, in addition to the normal information.
.RE

.RE

.sp
.ne 2
.mk
.na
\fBkill\fR [\fIsig\fR ] [ \fIpid\fR ] [ \fB%\fIjob\fR ]
\&.\|.\|.\fR
.ad
.br
.na
.B kill -l
.ad
.sp .6
.RS 4n
Send the
.B TERM
(terminate) signal, by default, or the signal
specified, to the specified process ID, the
.I job
indicated, or the
current
.IR job .
Signals are either given by number or by name. There is
no default. Typing
.B kill
does not send a signal to the current job. If
the signal being sent is
.B TERM
(terminate) or
.B HUP
(hangup), then
the job or process is sent a
.B CONT
(continue) signal as well.
.sp
.ne 2
.mk
.na
.B -l
.ad
.RS 6n
.rt
List the signal names that can be sent.
.RE

.RE

.sp
.ne 2
.mk
.na
\fBlimit\fR [\fB-h\fR] [\fIresource\fR [\fImax-use\fR ] ]\fR
.ad
.sp .6
.RS 4n
Limit the consumption by the current process or any process it spawns, each
not to exceed
.I max-use
on the specified
.IR resource .
The string
\fBunlimited\fR requests that the current limit, if any, be removed. If
\fImax-use\fR is omitted, print the current limit. If \fIresource\fR is
omitted, display all limits. Run the \fBsysdef\fR(1M) command to display
maximum limits for certain resources in your system (although it does not
report stack size). The values reported are in hexadecimal, but can be
translated into decimal numbers using the
.BR bc (1)
command.
.sp
.ne 2
.mk
.na
.B -h
.ad
.RS 6n
.rt
Use hard limits instead of the current limits. Hard limits impose a ceiling
on the values of the current limits. Only the privileged user can raise the
hard limits.
.RE

\fIresource\fR is one of:
.sp
.ne 2
.mk
.na
.B cputime
.ad
.RS 23n
.rt
Maximum
.B CPU
seconds per process.
.RE

.sp
.ne 2
.mk
.na
\fBfilesize\fR
.ad
.RS 23n
.rt
Largest single file allowed. Limited to the size of the filesystem. (See
\fBdf\fR(1M)).
.RE

.sp
.ne 2
.mk
.na
.BR datasize " (heapsize)"
.ad
.RS 23n
.rt
Maximum data size (including stack) for the process. This is the size of
your virtual memory See
.BR swap (1M).
.RE

.sp
.ne 2
.mk
.na
.B stacksize
.ad
.RS 23n
.rt
Maximum stack size for the process. The default stack size is 2^64 bytes.
You can use
.BR limit (1)
to change this default within a shell.
.RE

.sp
.ne 2
.mk
.na
.B coredumpsize
.ad
.RS 23n
.rt
Maximum size of a core dump (file). This limited to the size of the
filesystem.
.RE

.sp
.ne 2
.mk
.na
.B descriptors
.ad
.RS 23n
.rt
Maximum number of file descriptors. Run \fBsysdef()\fR.
.RE

.sp
.ne 2
.mk
.na
.B memorysize
.ad
.RS 23n
.rt
Maximum size of virtual memory.
.RE

\fImax-use\fR is a number, with an optional scaling factor, as follows:
.sp
.ne 2
.mk
.na
\fIn\fBh\fR
.ad
.RS 9n
.rt
Hours (for \fBcputime\fR).
.RE

.sp
.ne 2
.mk
.na
\fIn\fBk\fR
.ad
.RS 9n
.rt
\fIn\fR kilobytes. This is the default for all but \fBcputime\fR.
.RE

.sp
.ne 2
.mk
.na
\fIn\fBm\fR
.ad
.RS 9n
.rt
\fIn\fR megabytes or minutes (for \fBcputime\fR).
.RE

.sp
.ne 2
.mk
.na
\fImm\fB:\fIss\fR
.ad
.RS 9n
.rt
Minutes and seconds (for \fBcputime\fR).
.RE

Example of limit: To limit the size of a core file dump to \fB0\fR
Megabytes, type the following:
.sp
.in +2
.nf
\fBlimit coredumpsize 0M\fR
.fi
.in -2
.sp

.RE

.sp
.ne 2
.mk
.na
\fBlogin\fR [\fIusername\fR\|| \fB-p\fR ]\fR
.ad
.sp .6
.RS 4n
Terminate a login shell and invoke
.BR login (1).
The \fB\&.logout\fR file
is not processed. If
.I username
is omitted,
.B login
prompts for the
name of a user.
.sp
.ne 2
.mk
.na
.B -p
.ad
.RS 6n
.rt
Preserve the current environment (variables).
.RE

.RE

.sp
.ne 2
.mk
.na
.B logout
.ad
.sp .6
.RS 4n
Terminate a login shell.
.RE

.sp
.ne 2
.mk
.na
\fBnice\fR [\fB+\fIn\fR \||\fB-\fIn\fR ] [\fIcommand\fR ]\fR
.ad
.sp .6
.RS 4n
Increment the process priority value for the shell or for
.I command
by
.IR n .
The higher the priority value, the lower the priority of a process,
and the slower it runs. When given,
.I command
is always run in a
subshell, and the restrictions placed on commands in simple \fBif\fR
commands apply. If
.I command
is omitted,
.B nice
increments the value
for the current shell. If no increment is specified,
.B nice
sets the
process priority value to 4. The range of process priority values is from
\(mi20 to 20. Values of \fIn\fR outside this range set the value to the
lower, or to the higher boundary, respectively.
.sp
.ne 2
.mk
.na
\fB+\fIn\fR
.ad
.RS 6n
.rt
Increment the process priority value by
.IR n .
.RE

.sp
.ne 2
.mk
.na
\fB-\fIn\fR
.ad
.RS 6n
.rt
Decrement by
.IR n .
This argument can be used only by the privileged
user.
.RE

.RE

.sp
.ne 2
.mk
.na
\fBnohup\fR [\fIcommand\fR ]\fR
.ad
.sp .6
.RS 4n
Run
.I command
with
.BR HUP "s ignored. With no arguments, ignore"
\fBHUP\fRs throughout the remainder of a script. When given, \fIcommand\fR
is always run in a subshell, and the restrictions placed on commands in
simple \fBif\fR statements apply. All processes detached with
.B &
are
effectively
.BR nohup 'd.
.RE

.sp
.ne 2
.mk
.na
\fBnotify\fR [\fB%\fIjob\fR] .\|.\|.\fR
.ad
.sp .6
.RS 4n
Notify the user asynchronously when the status of the current job or
specified jobs changes.
.RE

.sp
.ne 2
.mk
.na
\fBonintr\fR [\fB\(mi\fR| \fIlabel\fR]\fR
.ad
.sp .6
.RS 4n
Control the action of the shell on interrupts. With no arguments,
\fBonintr\fR restores the default action of the shell on interrupts. (The
shell terminates shell scripts and returns to the terminal command input
level). With the \fB\(mi\fR argument, the shell ignores all interrupts. With
a
.I label
argument, the shell executes a
.B goto
\fIlabel\fR when an
interrupt is received or a child process terminates because it was
interrupted.
.RE

.sp
.ne 2
.mk
.na
\fBpopd\fR [\fB+\fIn\fR ]\fR
.ad
.sp .6
.RS 4n
Pop the directory stack and
.B cd
to the new top directory. The elements
of the directory stack are numbered from 0 starting at the top.
.sp
.ne 2
.mk
.na
\fB+\fIn\fR
.ad
.RS 6n
.rt
Discard the
.IR n "'th entry in the stack."
.RE

.RE

.sp
.ne 2
.mk
.na
\fBpushd\fR [\fB+\fIn\fR |\fIdir\fR]\fR
.ad
.sp .6
.RS 4n
Push a directory onto the directory stack. With no arguments, exchange the
top two elements.
.sp
.ne 2
.mk
.na
\fB+\fIn\fR
.ad
.RS 7n
.rt
Rotate the \fIn\fR'th entry to the top of the stack and
.B cd
to it.
.RE

.sp
.ne 2
.mk
.na
.I dir
.ad
.RS 7n
.rt
Push the current working directory onto the stack and change to
.IR dir .
.RE

.RE

.sp
.ne 2
.mk
.na
.B rehash
.ad
.sp .6
.RS 4n
Recompute the internal hash table of the contents of directories listed in
the
.I path
variable to account for new commands added. Recompute the
internal hash table of the contents of directories listed in the
\fIcdpath\fR variable to account for new directories added.
.RE

.sp
.ne 2
.mk
.na
\fBrepeat\fR \fIcount command\fR
.ad
.sp .6
.RS 4n
Repeat
.I "command count"
times.
.I command
is subject to the same
restrictions as with the one-line \fBif\fR statement.
.RE

.sp
.ne 2
.mk
.na
\fBset\fR [\fIvar\fR [\fB=\fR \fIvalue\fR ] ]\fR
.ad
.br
.na
\fBset\fR \fIvar\fB[\fIn\fB] =\fR \fIword\fR
.ad
.sp .6
.RS 4n
With no arguments,
.B set
displays the values of all shell variables.
.RI "Multiword values are displayed as a parenthesized list. With the" " var"
argument alone,
.B set
assigns an empty (null) value to the variable
.IR var .
With arguments of the form
.I var
\fB=\fR \fIvalue\fR
\fBset\fR assigns \fIvalue\fR to
.IR var ,
where
.I value
is one of:
.sp
.ne 2
.mk
.na
.I word
.ad
.RS 14n
.rt
A single word (or quoted string).
.RE

.sp
.ne 2
.mk
.na
\fB(\fIwordlist\fB)\fR
.ad
.RS 14n
.rt
A space-separated list of words enclosed in parentheses.
.RE

Values are command and filename expanded before being assigned. The form
\fBset\fIvar\fB[\fIn\fB] =\fR \fIword\fR replaces the \fIn\fR'th
word in a multiword value with
.IR word .
.RE

.sp
.ne 2
.mk
.na
\fBsetenv\fR [\fIVAR\fR [\fIword\fR ] ]\fR
.ad
.sp .6
.RS 4n
With no arguments,
.B setenv
displays all environment variables. With
the
.I VAR
argument,
.B setenv
sets the environment variable
\fIVAR\fR to have an empty (null) value. (By convention,
environment variables are normally given upper-case names.) With both
\fIVAR\fR and \fIword\fR arguments, \fBsetenv\fR sets the environment
variable
.B NAME
to the value
.IR word ,
which must be either a single
word or a quoted string. The most commonly used environment variables,
.BR USER ,
.BR TERM ,
and
.BR PATH ,
are automatically imported to and
exported from the
.B csh
variables
.BR user ,
.BR term ,
and
.BR path .
There is no need to use
.B setenv
for these. In addition, the
shell sets the
.B PWD
environment variable from the
.B csh
variable
\fBcwd\fR whenever the latter changes.
.sp
The environment variables
.BR LC_CTYPE ,
.BR LC_MESSAGES ,
.BR LC_TIME ,
.BR LC_COLLATE ,
.BR LC_NUMERIC ,
and
.B LC_MONETARY
take immediate
effect when changed within the C shell.
.sp
If any of the
.B LC_*
variables (\fBLC_CTYPE\fR, \fBLC_MESSAGES\fR,
.BR LC_TIME ,
.BR LC_COLLATE ,
.BR LC_NUMERIC ,
and
.BR LC_MONETARY )
(see
.BR environ (5))
are not set in the environment, the operational
behavior of
.B csh
for each corresponding locale category is determined
by the value of the
.B LANG
environment variable. If
.B LC_ALL
is set,
its contents are used to override both the
.B LANG
and the other
\fBLC_*\fR variables. If none of the above variables is set in the
environment, the "C" (U.S. style) locale determines how \fBcsh\fR behaves.
.sp
.ne 2
.mk
.na
.B LC_CTYPE
.ad
.RS 15n
.rt
Determines how
.B csh
handles characters. When
.B LC_CTYPE
is set to
a valid value,
.B csh
can display and handle text and filenames
containing valid characters for that locale.
.RE

.sp
.ne 2
.mk
.na
.B LC_MESSAGES
.ad
.RS 15n
.rt
Determines how diagnostic and informative messages are presented. This
includes the language and style of the messages and the correct form of
affirmative and negative responses. In the "C" locale, the messages are
presented in the default form found in the program itself (in most cases,
U.S./English).
.RE

.sp
.ne 2
.mk
.na
.B LC_NUMERIC
.ad
.RS 15n
.rt
Determines the value of the radix character, decimal point, (\fB\&.\fR) in
the "C" locale) and thousand separator, empty string (\fB""\fR) in the "C"
locale).
.RE

.RE

.sp
.ne 2
.mk
.na
\fBshift\fR [\fIvariable\fR ]\fR
.ad
.sp .6
.RS 4n
The components of
.BR argv ,
or
.IR variable ,
if supplied, are shifted
to the left, discarding the first component. It is an error for the variable
not to be set or to have a null value.
.RE

.sp
.ne 2
.mk
.na
\fBsource\fR [\fB-h\fR] \fIname\fR
.ad
.sp .6
.RS 4n
Reads commands from
.IR name .
\fBsource\fR commands can be nested, but if
they are nested too deeply the shell can run out of file descriptors. An
error in a sourced file at any level terminates all nested
.BR source
commands. 
.sp
.ne 2
.mk
.na
.B -h
.ad
.RS 6n
.rt
Place commands from the file
.I name
on the history list without
executing them.
.RE

.RE

.sp
.ne 2
.mk
.na
\fBstop\fR \fB%\fIjobid .\|.\|.\fR
.ad
.sp .6
.RS 4n
Stop the current or specified background job.
.RE

.sp
.ne 2
.mk
.na
\fBstop\fR \fIpid .\|.\|.\fR
.ad
.sp .6
.RS 4n
Stop the specified process,
.IR pid .
(see \fBps\fR(1)).
.RE

.sp
.ne 2
.mk
.na
.B suspend
.ad
.sp .6
.RS 4n
Stop the shell in its tracks, much as if it had been sent a stop signal
with
.BR ^Z .
This is most often used to stop shells started by
.BR su .
.RE

.sp
.ne 2
.mk
.na
\fBswitch (\fIstring\fB)\fR
.ad
.br
.na
\fBcase\fR \fIlabel\fB:\fR
.ad
.br
.na
\fB\|\|\|.\|.\|.\fR
.ad
.br
.na
.B breaksw
.ad
.br
.na
\fB\|\|\|.\|.\|.\fR
.ad
.br
.na
\fBdefault:\fR
.ad
.br
.na
\fB\|\|\|.\|.\|.\fR
.ad
.br
.na
.B breaksw
.ad
.br
.na
.B endsw
.ad
.sp .6
.RS 4n
Each
.I label
is successively matched, against the specified
.IR string ,
which is first command and filename expanded. The file
metacharacters \fB*\fR, \fB?\fR and \fB[\fR.\|.\|.\fB]\fR can be used in the
case labels, which are variable expanded. If none of the labels match before
a "default" label is found, execution begins after the default label. Each
\fBcase\fR statement and the \fBdefault\fR statement must appear at the
beginning of a line. The command
.B breaksw
continues execution after the
.BR endsw .
Otherwise control falls through subsequent
.B case
and
\fBdefault\fR statements as with C. If no label matches and there is no
default, execution continues after the \fBendsw\fR.
.RE

.sp
.ne 2
.mk
.na
\fBtime\fR [\fIcommand\fR ]\fR
.ad
.sp .6
.RS 4n
With no argument, print a summary of time used by this C shell and its
children. With an optional
.IR command ,
execute
.I command
and print a
summary of the time it uses. As of this writing, the
.B time
built-in
command does NOT compute the last 6 fields of output, rendering the output
to erroneously report the value
.B 0
for these fields.
.sp
.in +2
.nf
example %\fBtime ls\fR \fB-R\fR
        9.0u 11.0s 3:32 10% 0+0k 0+0io 0pf+0w
.fi
.in -2
.sp

(See the \fBEnvironment Variables and Predefined Shell Variables\fR
sub-section on the
.B time
variable.)
.RE

.sp
.ne 2
.mk
.na
\fBumask\fR [\fIvalue\fR ]\fR
.ad
.sp .6
.RS 4n
Display the file creation mask. With
.IR value ,
set the file creation
mask. With
.I value
given in octal, the user can turn off any bits, but
cannot turn on bits to allow new permissions. Common values include 077,
restricting all permissions from everyone else; 002, giving complete access
to the group, and read (and directory search) access to others; or 022,
giving read (and directory search) but not write permission to the group and
others.
.RE

.sp
.ne 2
.mk
.na
\fBunalias\fR \fIpattern\fR
.ad
.sp .6
.RS 4n
Discard aliases that match (filename substitution)
.IR pattern .
All
aliases are removed by `\fBunalias *\fR'.
.RE

.sp
.ne 2
.mk
.na
.B unhash
.ad
.sp .6
.RS 4n
Disable the internal hash tables for the
.I path
and
.IR cdpath
variables.
.RE

.sp
.ne 2
.mk
.na
\fBunlimit\fR [\fB-h\fR] [\fIresource\fR ]\fR
.ad
.sp .6
.RS 4n
Remove a limitation on
.IR resource .
If no
.I resource
is specified,
then all resource limitations are removed. See the description of the
\fBlimit\fR command for the list of resource names.
.sp
.ne 2
.mk
.na
.B -h
.ad
.RS 6n
.rt
Remove corresponding hard limits. Only the privileged user can do this.
.RE

.RE

.sp
.ne 2
.mk
.na
\fBunset\fR \fIpattern\fR
.ad
.sp .6
.RS 4n
Remove variables whose names match (filename substitution) \fIpattern\fR.
All variables are removed by `\fBunset *\fR'; this has noticeably
distasteful side effects.
.RE

.sp
.ne 2
.mk
.na
\fBunsetenv\fR \fIvariable\fR
.ad
.sp .6
.RS 4n
Remove
.I variable
from the environment. As with
.BR unset ,
pattern
matching is not performed.
.RE

.sp
.ne 2
.mk
.na
.B wait
.ad
.sp .6
.RS 4n
Wait for background jobs to finish (or for an interrupt) before
prompting.
.RE

.sp
.ne 2
.mk
.na
\fBwhile (\fIexpr\fB)\fR
.ad
.br
.na
\fB\|\|\|.\|.\|.\fR
.ad
.br
.na
.B end
.ad
.sp .6
.RS 4n
While
.I expr
is true (evaluates to nonzero), repeat commands between
the
.B while
and the matching
.B end
statement.
.B break
and
\fBcontinue\fR can be used to terminate or continue the loop prematurely.
The
.B while
and
.B end
must appear alone on their input lines. If the
shell's input is a terminal, it prompts for commands with a question-mark
until the
.B end
command is entered and then performs the commands in the
loop.
.RE

.sp
.ne 2
.mk
.na
\fB%\fR [\fIjob\fR ] [\fB&\fR]\fR
.ad
.sp .6
.RS 4n
Bring the current or indicated
.I job
to the foreground. With the
ampersand, continue running
.I job
in the background.
.RE

.sp
.ne 2
.mk
.na
\fB@\fR [\fIvar\fR \fB=\fIexpr\fR]\fR
.ad
.br
.na
\fB@\fR [\fIvar\fB[\fIn\fB]\fB=\fIexpr\fR]\fR
.ad
.sp .6
.RS 4n
With no arguments, display the values for all shell variables. With
arguments, set the variable
.IR var ,
or the
.IR n "'th word in the value"
of
.IR var ,
to the value that
.I expr
evaluates to. (If
\fB[\fIn\fB]\fR is supplied, both \fIvar\fR and its \fIn\fR'th
component must already exist.)
.sp
If the expression contains the characters
.BR > ,
.BR < ,
.BR & ,
or
.BR | ,
then at least this part of
.I expr
must be placed within
parentheses.
.sp
The operators
.BR *= ,
.BR += ,
and so forth, are available as in C. The
space separating the name from the assignment operator is optional. Spaces
are, however, mandatory in separating components of
.I expr
that would
otherwise be single words.
.sp
Special postfix operators, \fB+\|+\fR and \fB\(mi\|\(mi\fR, increment or
decrement
.IR name ,
respectively.
.RE

.SS "Environment Variables and Predefined Shell Variables"
.sp
.LP
Unlike the Bourne shell, the C shell maintains a distinction between
environment variables, which are automatically exported to processes it
invokes, and shell variables, which are not. Both types of variables are
treated similarly under variable substitution. The shell sets the variables
.BR argv ,
.BR cwd ,
.BR home ,
.BR path ,
.BR prompt ,
.BR shell ,
and
.B status
upon initialization. The shell copies the environment
variable
.B USER
into the shell variable
.BR user ,
\fBTERM\fR into
.BR term ,
and
.B HOME
into
.BR home ,
and copies each back into the
respective environment variable whenever the shell variables are reset.
\fBPATH\fR and \fBpath\fR are similarly handled. You need only set
\fBpath\fR once in the \fB\&.cshrc\fR or \fB\&.login\fR file. The
environment variable
.B PWD
is set from
.B cwd
whenever the latter
changes. The following shell variables have predefined meanings:
.sp
.ne 2
.mk
.na
.B argv
.ad
.RS 13n
.rt
Argument list. Contains the list of command line arguments supplied to the
current invocation of the shell. This variable determines the value of the
positional parameters
.BR $1 ,
.BR $2 ,
and so on.
.RE

.sp
.ne 2
.mk
.na
.B cdpath
.ad
.RS 13n
.rt
Contains a list of directories to be searched by the
.BR cd ,
.BR chdir ,
and
.B popd
commands, if the directory argument each accepts is not a
subdirectory of the current directory.
.RE

.sp
.ne 2
.mk
.na
.B cwd
.ad
.RS 13n
.rt
The full pathname of the current directory.
.RE

.sp
.ne 2
.mk
.na
.B echo
.ad
.RS 13n
.rt
Echo commands (after substitutions) just before execution.
.RE

.sp
.ne 2
.mk
.na
\fBfignore\fR
.ad
.RS 13n
.rt
A list of filename suffixes to ignore when attempting filename completion.
Typically the single word `\fB\&.o\fR'.
.RE

.sp
.ne 2
.mk
.na
\fBfilec\fR
.ad
.RS 13n
.rt
Enable filename completion, in which case the Control-d character \fBEOT\fR
and the
.B ESC
character have special significance when typed in at the
end of a terminal input line:
.sp
.ne 2
.mk
.na
.B EOT
.ad
.RS 7n
.rt
Print a list of all filenames that start with the preceding string.
.RE

.sp
.ne 2
.mk
.na
.B ESC
.ad
.RS 7n
.rt
Replace the preceding string with the longest unambiguous extension.
.RE

.RE

.sp
.ne 2
.mk
.na
.B hardpaths
.ad
.RS 13n
.rt
If set, pathnames in the directory stack are resolved to contain no
symbolic-link components.
.RE

.sp
.ne 2
.mk
.na
.B histchars
.ad
.RS 13n
.rt
A two-character string. The first character replaces
.B !
as the
history-substitution character. The second replaces the carat (\fB^\fR) for
quick substitutions.
.RE

.sp
.ne 2
.mk
.na
.B history
.ad
.RS 13n
.rt
The number of lines saved in the history list. A very large number can use
up all of the C shell's memory. If not set, the C shell saves only the most
recent command.
.RE

.sp
.ne 2
.mk
.na
.B home
.ad
.RS 13n
.rt
The user's home directory. The filename expansion of ~ refers to the value
of this variable.
.RE

.sp
.ne 2
.mk
.na
\fBignoreeof\fR
.ad
.RS 13n
.rt
If set, the shell ignores
.B EOF
from terminals. This protects against
accidentally killing a C shell by typing a Control-d.
.RE

.sp
.ne 2
.mk
.na
.B mail
.ad
.RS 13n
.rt
A list of files where the C shell checks for mail. If the first word of the
value is a number, it specifies a mail checking interval in seconds (default
5 minutes).
.RE

.sp
.ne 2
.mk
.na
.B nobeep
.ad
.RS 13n
.rt
Suppress the bell during command completion when asking the C shell to
extend an ambiguous filename.
.RE

.sp
.ne 2
.mk
.na
.B noclobber
.ad
.RS 13n
.rt
Restrict output redirection so that existing files are not destroyed by
accident.
.B >
redirections can only be made to new files. \fB>>\fR
redirections can only be made to existing files.
.RE

.sp
.ne 2
.mk
.na
.B noglob
.ad
.RS 13n
.rt
Inhibit filename substitution. This is most useful in shell scripts once
filenames (if any) are obtained and no further expansion is desired.
.RE

.sp
.ne 2
.mk
.na
.B nonomatch
.ad
.RS 13n
.rt
Return the filename substitution pattern, rather than an error, if the
pattern is not matched. Malformed patterns still result in errors.
.RE

.sp
.ne 2
.mk
.na
\fBnotify\fR
.ad
.RS 13n
.rt
If set, the shell notifies you immediately as jobs are completed, rather
than waiting until just before issuing a prompt.
.RE

.sp
.ne 2
.mk
.na
.B path
.ad
.RS 13n
.rt
The list of directories in which to search for commands.
.B path
is
initialized from the environment variable
.BR PATH ,
which the C shell
updates whenever
.B path
changes. A null word ('') specifies the current
directory. The default is typically
.BR "(/usr/bin .)" .
One can override
this initial search path upon
.B csh
start-up by setting it in
\fB\&.cshrc\fR or \fB\&.login\fR (for login shells only). If \fBpath\fR
becomes unset, only full pathnames execute. An interactive C shell normally
hashes the contents of the directories listed after reading \fB\&.cshrc\fR,
and whenever
.B path
is reset. If new commands are added, use the
\fBrehash\fR command to update the table.
.RE

.sp
.ne 2
.mk
.na
.B prompt
.ad
.RS 13n
.rt
The string an interactive C shell prompts with. Noninteractive shells leave
the
.B prompt
variable unset. Aliases and other commands in the
\fB\&.cshrc\fR file that are only useful interactively, can be placed after
the following test: `\fBif ($?prompt == 0) exit\fR', to reduce startup time
for noninteractive shells. A
.B !
in the
.B prompt
string is replaced
by the current event number. The default prompt is \fIhostname\fB%\fR for
mere mortals, or \fIhostname\fB#\fR for the privileged user.
.sp
The setting of
.B $prompt
has three meanings:
.sp
.ne 2
.mk
.na
\fB$prompt\fR not set\fR
.ad
.RS 25n
.rt
non-interactive shell, test \fB$?prompt\fR.
.RE

.sp
.ne 2
.mk
.na
\fB$prompt\fR set but \fB== ""\fR
.ad
.RS 25n
.rt
\fB\&.cshrc\fR called by the
.BR which (1)
command.
.RE

.sp
.ne 2
.mk
.na
\fB$prompt\fR set and \fB!= ""\fR
.ad
.RS 25n
.rt
normal interactive shell.
.RE

.RE

.sp
.ne 2
.mk
.na
.B savehist
.ad
.RS 13n
.rt
The number of lines from the history list that are saved in ~/.history when
the user logs out. Large values for
.B savehist
slow down the C shell
during startup.
.RE

.sp
.ne 2
.mk
.na
.B shell
.ad
.RS 13n
.rt
The file in which the C shell resides. This is used in forking shells to
interpret files that have execute bits set, but that are not executable by
the system.
.RE

.sp
.ne 2
.mk
.na
.B status
.ad
.RS 13n
.rt
The status returned by the most recent command. If that command terminated
abnormally, 0200 is added to the status. Built-in commands that fail return
exit status 1; all other built-in commands set status to 0.
.RE

.sp
.ne 2
.mk
.na
.B time
.ad
.RS 13n
.rt
Control automatic timing of commands. Can be supplied with one or two
values. The first is the reporting threshold in
.B CPU
seconds. The
second is a string of tags and text indicating which resources to report on.
A tag is a percent sign (\fB%\fR) followed by a single upper-case letter
(unrecognized tags print as text):
.sp
.ne 2
.mk
.na
.B %D
.ad
.RS 6n
.rt
Average amount of unshared data space used in Kilobytes.
.RE

.sp
.ne 2
.mk
.na
.B %E
.ad
.RS 6n
.rt
Elapsed (wallclock) time for the command.
.RE

.sp
.ne 2
.mk
.na
.B %F
.ad
.RS 6n
.rt
Page faults.
.RE

.sp
.ne 2
.mk
.na
.B %I
.ad
.RS 6n
.rt
Number of block input operations.
.RE

.sp
.ne 2
.mk
.na
.B %K
.ad
.RS 6n
.rt
Average amount of unshared stack space used in Kilobytes.
.RE

.sp
.ne 2
.mk
.na
.B %M
.ad
.RS 6n
.rt
Maximum real memory used during execution of the process.
.RE

.sp
.ne 2
.mk
.na
.B %O
.ad
.RS 6n
.rt
Number of block output operations.
.RE

.sp
.ne 2
.mk
.na
.B %P
.ad
.RS 6n
.rt
Total CPU time \(em U (user) plus S (system) \(em as a percentage of E
(elapsed) time.
.RE

.sp
.ne 2
.mk
.na
.B %S
.ad
.RS 6n
.rt
Number of seconds of CPU time consumed by the kernel on behalf of the
user's process.
.RE

.sp
.ne 2
.mk
.na
.B %U
.ad
.RS 6n
.rt
Number of seconds of
.B CPU
time devoted to the user's process.
.RE

.sp
.ne 2
.mk
.na
.B %W
.ad
.RS 6n
.rt
Number of swaps.
.RE

.sp
.ne 2
.mk
.na
.B %X
.ad
.RS 6n
.rt
Average amount of shared memory used in Kilobytes.
.RE

The default summary display outputs from the
.BR %U ,
.BR %S ,
.BR %E ,
.BR %P ,
.BR %X ,
.BR %D ,
.BR %I ,
.BR %O ,
.BR %F ,
and
.BR %W
tags, in that order.
.RE

.sp
.ne 2
.mk
.na
.B verbose
.ad
.RS 13n
.rt
Display each command after history substitution takes place.
.RE

.SS "Large File Behavior"
.sp
.LP
See
.BR largefile (5)
for the description of the behavior of
.BR csh
when encountering files greater than or equal to 2 Gbyte (2^31 bytes).
.SH FILES
.sp
.ne 2
.mk
.na
.B ~/.cshrc
.ad
.RS 15n
.rt
Read at beginning of execution by each shell.
.RE

.sp
.ne 2
.mk
.na
.B ~/.login
.ad
.RS 15n
.rt
Read by login shells after \fB\&.cshrc\fR at login.
.RE

.sp
.ne 2
.mk
.na
.B ~/.logout
.ad
.RS 15n
.rt
Read by login shells at logout.
.RE

.sp
.ne 2
.mk
.na
.B ~/.history
.ad
.RS 15n
.rt
Saved history for use at next login.
.RE

.sp
.ne 2
.mk
.na
.B /usr/bin/sh
.ad
.RS 15n
.rt
The Bourne shell, for shell scripts not starting with a `\fB#\fR'.
.RE

.sp
.ne 2
.mk
.na
.B /tmp/sh*
.ad
.RS 15n
.rt
Temporary file for `\fB<<\fR\&'.
.RE

.sp
.ne 2
.mk
.na
.B /etc/passwd
.ad
.RS 15n
.rt
Source of home directories for `~\fIname\fR'.
.RE

.SH ATTRIBUTES
.sp
.LP
See
.BR attributes (5)
for descriptions of the following attributes:
.sp

.sp
.TS
tab() box;
cw(2.75i) |cw(2.75i)
lw(2.75i) |lw(2.75i)
.
ATTRIBUTE TYPEATTRIBUTE VALUE
_
AvailabilitySUNWcsu
_
CSIEnabled
.TE

.SH SEE ALSO
.sp
.LP
.BR bc (1),
.BR echo (1),
.BR limit (1),
.BR login (1),
.BR ls (1),
.BR more (1),
\fBpfcsh\fR(1), \fBpfexec\fR(1),
.BR ps (1),
.BR sh (1),
.BR shell_builtins (1),
.BR tset (1B),
.BR which (1),
\fBdf\fR(1M),
.BR swap (1M),
\fBsysdef\fR(1M),
.BR access (2),
.BR exec (2),
\fBfork\fR(2), \fBpipe\fR(2),
.BR a.out (4),
.BR ascii (5),
.BR attributes (5),
.BR environ (5),
\fBlargefile\fR(5),
.BR termio (7I)
.SH DIAGNOSTICS
.sp
.ne 2
.mk
.na
.B You have stopped jobs.
.ad
.RS 26n
.rt
You attempted to exit the C shell with stopped jobs under job control. An
immediate second attempt to exit succeeds, terminating the stopped jobs.
.RE

.SH WARNINGS
.sp
.LP
The use of
.B setuid
shell scripts is
.I strongly
discouraged.
.SH NOTES
.sp
.LP
Words can be no longer than 1024 bytes. The system limits argument lists to
1,048,576 bytes. However, the maximum number of arguments to a command for
which filename expansion applies is 1706. Command substitutions can expand
to no more characters than are allowed in the argument list. To detect
looping, the shell restricts the number of
.B alias
substitutions on a
single line to 20.
.sp
.LP
When a command is restarted from a stop, the shell prints the directory it
started in if this is different from the current directory; this can be
misleading (that is, wrong) as the job might have changed directories
internally.
.sp
.LP
Shell built-in functions are not stoppable/restartable. Command sequences
of the form
.I "a b"
\fIc\fR are also not handled gracefully when
stopping is attempted. If you suspend
.IR b ,
the shell never executes
.IR c .
This is especially noticeable if the expansion results from an
alias. It can be avoided by placing the sequence in parentheses to force it
into a subshell.
.sp
.LP
Commands within loops, prompted for by
.BR ? ,
are not placed in the
\fIhistory\fR list.
.sp
.LP
Control structures should be parsed rather than being recognized as
built-in commands. This would allow control commands to be placed anywhere,
to be combined with
.BR | ,
and to be used with
.B &
and
.BR ;
metasyntax.
.sp
.LP
It should be possible to use the
.B :
modifiers on the output of command
substitutions. There are two problems with
.B :
modifier usage on
variable substitutions: not all of the modifiers are available, and only one
modifier per substitution is allowed.
.sp
.LP
The
.B g
(global) flag in history substitutions applies only to the
first match in each word, rather than all matches in all words. The common
text editors consistently do the latter when given the
.B g
flag in a
substitution command.
.sp
.LP
Quoting conventions are confusing. Overriding the escape character to force
variable substitutions within double quotes is counterintuitive and
inconsistent with the Bourne shell.
.sp
.LP
Symbolic links can fool the shell. Setting the
.B hardpaths
variable
alleviates this.
.sp
.LP
It is up to the user to manually remove all duplicate pathnames accrued
from using built-in commands as
.sp
.in +2
.nf
set path = \fIpathnames\fR
.fi
.in -2
.sp

.sp
.LP
or
.sp
.in +2
.nf
setenv PATH = \fIpathnames\fR
.fi
.in -2
.sp

.sp
.LP
more than once. These often occur because a shell script or a
\fB\&.cshrc\fR file does something like
.sp
.in +2
.nf
`set path=(/usr/local /usr/hosts $path)'
.fi
.in -2
.sp

.sp
.LP
to ensure that the named directories are in the pathname list.
.sp
.LP
The only way to direct the standard output and standard error separately is
by invoking a subshell, as follows:
.sp
.in +2
.nf
\fIcommand\fR > \fIoutfile\fR ) >& \fIerrorfile\fR
.fi
.in -2
.sp

.sp
.LP
Although robust enough for general use, adventures into the esoteric
periphery of the C shell can reveal unexpected quirks.
.sp
.LP
If you start
.B csh
as a login shell and you do not have a
\fB\&.login\fR in your home directory, then the \fBcsh\fR reads in the
.BR /etc/.login .
.sp
.LP
When the shell executes a shell script that attempts to execute a
non-existent command interpreter, the shell returns an erroneous diagnostic
message that the shell script file does not exist.
.SH BUGS
.sp
.LP
As of this writing, the
.B time
built-in command does
.B not
compute
the last 6 fields of output, rendering the output to erroneously report the
value
.B 0
for these fields:
.sp
.in +2
.nf
example %\fBtime ls -R\fR
        9.0u 11.0s 3:32 10% 0+0k 0+0io 0pf+0w
.fi
.in -2
.sp

