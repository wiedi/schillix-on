'\" te
.\" Copyright (c) 2007, Sun Microsystems, Inc. All Rights Reserved.
.\" Copyright (c) 2012-2013, J. Schilling
.\" Copyright (c) 2013, Andreas Roehler
.\" Copyright 1989 AT&T
.\" Portions Copyright (c) 1992, X/Open Company Limited All Rights Reserved
.\"
.\" Sun Microsystems, Inc. gratefully acknowledges The Open Group for
.\" permission to reproduce portions of its copyrighted documentation.
.\" Original documentation from The Open Group can be obtained online
.\" at http://www.opengroup.org/bookstore/.
.\"
.\" The Institute of Electrical and Electronics Engineers and The Open Group,
.\" have given us permission to reprint portions of their documentation.
.\"
.\" In the following statement, the phrase "this text" refers to portions
.\" of the system documentation.
.\"
.\" Portions of this text are reprinted and reproduced in electronic form in
.\" the Sun OS Reference Manual, from IEEE Std 1003.1, 2004 Edition, Standard
.\" for Information Technology -- Portable Operating System Interface (POSIX),
.\" The Open Group Base Specifications Issue 6, Copyright (C) 2001-2004 by the
.\" Institute of Electrical and Electronics Engineers, Inc and The Open Group.
.\" In the event of any discrepancy between these versions and the original
.\" IEEE and The Open Group Standard, the original IEEE and The Open Group
.\" Standard is the referee document.
.\"
.\" The original Standard can be obtained online at
.\" http://www.opengroup.org/unix/online.html.
.\"
.\" This notice shall appear on any product containing this material.
.\"
.\" CDDL HEADER START
.\"
.\" The contents of this file are subject to the terms of the
.\" Common Development and Distribution License ("CDDL"), version 1.0.
.\" You may only use this file in accordance with the terms of version
.\" 1.0 of the CDDL.
.\"
.\" A full copy of the text of the CDDL should have accompanied this
.\" source.  A copy of the CDDL is also available via the Internet at
.\" http://www.opensource.org/licenses/cddl1.txt
.\"
.\" When distributing Covered Code, include this CDDL HEADER in each
.\" file and include the License file at usr/src/OPENSOLARIS.LICENSE.
.\" If applicable, add the following below this CDDL HEADER, with the
.\" fields enclosed by brackets "[]" replaced with your own identifying
.\" information: Portions Copyright [yyyy] [name of copyright owner]
.\"
.\" CDDL HEADER END
.TH ksh 1 "29 Mar 2007" "SunOS 5.11" "User Commands"
.SH NAME
ksh, rksh \- KornShell, a standard/restricted command and programming
language
.SH SYNOPSIS
.LP
.nf
\fB/usr/bin/ksh\fR [\(+- abCefhikmnoprstuvx] [\(+- o \fIoption\fR].\|.\|.
     [\fIarg\fR].\|.\|.
.fi

.LP
.nf
\fB/usr/bin/ksh\fR \fB-c\fR [\(+- abCefhikmnoprstuvx]
     [\(+- o \fIoption\fR].\|.\|. \fIcommand_string\fR
     [\fIcommand_name\fR [\fIarg\fR.\|.\|.]]
.fi

.LP
.nf
\fB/usr/xpg4/bin/sh\fR [\(+- abCefhikmnoprstuvx]
     [\(+- o \fIoption\fR].\|.\|. [\fIarg\fR].\|.\|.
.fi

.LP
.nf
\fB/usr/xpg4/bin/sh\fR \fB-c\fR [\(+- abCefhikmnoprstuvx]
     [\(+- o \fIoption\fR].\|.\|. \fIcommand_string\fR
     [\fIcommand_name\fR [\fIarg\fR.\|.\|.]]
.fi

.LP
.nf
\fB/usr/bin/rksh\fR [\(+- abCefhikmnoprstuvx] [\(+- o \fIoption\fR].\|.\|.
     [\fIarg\fR].\|.\|.
.fi

.LP
.nf
\fB/usr/bin/rksh\fR \fB-c\fR [\(+- abCefhikmnoprstuvx]
     [\(+- o \fIoption\fR].\|.\|. \fIcommand_string\fR
     [\fIcommand_name\fR [\fIarg\fR.\|.\|.]]
.fi

.SH DESCRIPTION
.sp
.LP
The
.B /usr/xpg4/bin/sh
utility is a standards compliant shell. This
utility provides all the functionality of
.BR /usr/bin/ksh ,
except in
cases where differences in behavior exist. See
.B "Arithmetic Expansions"
section for details.
.sp
.LP
.B /usr/bin/ksh
is a command and programming language that executes
commands read from a terminal or a file.
.B rksh
is a restricted version
of the command interpreter
.BR ksh ;
it is used to set up login names and
execution environments whose capabilities are more controlled than those of
the standard shell. See the
.B Invocation
section for the meaning of
arguments to the shell.
.SS "Definitions"
.sp
.LP
A
.I metacharacter
is one of the following characters:
.sp
.LP
.BI "; & (   )   |   <   >" "      NEWLINE   SPACE   TAB"
.sp
.LP
A
.I blank
is a
.I TAB
or a
.IR SPACE .
An
.I identifier
is a
sequence of letters, digits, or underscores starting with a letter or
underscore. Identifiers are used as names for
.I functions
and
.IR variables .
A
.I word
is a sequence of
.I characters
separated by
one or more non-quoted
.IR metacharacters .
.sp
.LP
A
.I command
is a sequence of characters in the syntax of the shell
language. The shell reads each command and carries out the desired action
.RI "either directly or by invoking separate utilities. A" " special-command"
is a command that is carried out by the shell without creating a separate
process. Except for documented side effects, most special commands can be
implemented as separate utilities.
.SS "Commands"
.sp
.LP
A
.I simple-command
is a sequence of blank-separated words which can be
preceded by a variable assignment list. See
.BR Environment .
The first
word specifies the name of the command to be executed. Except as specified,
the remaining words are passed as arguments to the invoked command. The
command name is passed as argument 0 (see
.BR exec (2)).
The
.I value
of
a simple-command is its exit status if it terminates normally. If it
terminates abnormally due to receipt of a signal, the
.I value
is the
signal number plus 128. See
.BR signal.h (3HEAD)
for a list of signal
values. Obviously, normal exit status values 129 to 255 cannot be
distinguished from abnormal exit caused by receiving signal numbers 1 to
127.
.sp
.LP
A
.I pipeline
is a sequence of one or more
.I commands
separated by
.BR | .
The standard output of each command but the last is connected by a
.BR pipe (2)
to the standard input of the next command. Each command is run
as a separate process; the shell waits for the last command to terminate.
The exit status of a pipeline is the exit status of the last command.
.sp
.LP
A
.I list
is a sequence of one or more
.IR pipeline "s separated by"
.BR ; ,
.BR & ,
.BR && ,
or
.BR |\|| ,
and optionally terminated by
.BR ; ,
.BR & ,
or
.BR |& .
Of these five symbols,
.BR ; ,
.BR & ,
and
.B |&
have equal precedence, which is lower than that of
.B &&
and
.BR |\|| .
The symbols
.B &&
and
.B
|\|| \c
also have equal precedence.
A semicolon
.RB ( ; )
causes sequential execution of the preceding pipeline;
an ampersand
.RB ( & )
causes asynchronous execution of the preceding
pipeline (that is, the shell does
.I not
wait for that pipeline to
finish). The symbol
.B |&
causes asynchronous execution of the preceding
command or pipeline with a two-way pipe established to the parent shell.
.sp
.LP
The standard input and output of the spawned command can be written to and
read from by the parent shell using the
.B -p
option of the special
commands
.B read
and
.B print
described in
.BR "Special Commands" .
The
symbol
\fB&&\fR(\|\fB|\||\fR) causes the
.I list
following it to be
executed only if the preceding pipeline returns
.B 0
(or a non-zero)
value. An arbitrary number of new-lines can appear in a
.IR list ,
instead
of a semicolon, to delimit a command.
.sp
.LP
A
.I command
is either a
.I simple-command
or one of the following.
Unless otherwise stated, the value returned by a command is that of the last
simple-command executed in the command.
.sp
.ne 2
.mk
.na
\fBfor\fR \fIidentifier\fR [ \fBin\fR
.I word
\&.\|.\|. ] \fB; do\fR
.IB list " ; done"
.ad
.sp .6
.RS 4n
Each time a \fBfor\fR command is executed,
.I identifier
is set to the
next
.I word
taken from the
.B in
\fIword\fR list. If \fBin\fR
\fIword\fR .\|.\|. is omitted, then the
.B for
command executes the \fBdo\fR
\fIlist\fR once for each positional parameter that is set. See \fBParameter Substitution\fR. Execution ends when there are no more words in the list.
.RE

.sp
.ne 2
.mk
.na
\fBselect\fR \fIidentifier\fR [ \fBin\fR
.I word
\&.\|.\|. ] \fB; do\fR
.IB list " ; done"
.ad
.sp .6
.RS 4n
A
.B select
command prints to standard error (file descriptor 2), the
set of
.IR word s,
each preceded by a number. If \fBin\fR \fIword\fR .\|.\|. is
omitted, then the positional parameters are used instead. See \fBParameter Substitution\fR. The \fBPS3\fR prompt is printed and a line is read from the
standard input. If this line consists of the number of one of the listed
\fIword\fRs, then the value of the variable
.I identifier
is set to the
\fIword\fR corresponding to this number. If this line is empty the selection
list is printed again. Otherwise the value of the variable
.I identifier
is set to
.BR NULL .
(See
.B "Blank Interpretation"
about
.BR NULL ).
The
contents of the line read from standard input is saved in the shell variable
.BR REPLY .
The
.I list
is executed for each selection until a
\fBbreak\fR or \fBEOF\fR is encountered. If the
.B REPLY
variable is set
to
.B NULL
by the execution of
.IR list ,
then the selection list is
printed before displaying the
.B PS3
prompt for the next selection.
.RE

.sp
.ne 2
.mk
.na
\fBcase\fR \fIword\fR \fBin\fR [ \fIpattern\fR [ |
.I pattern
]
\fB)\fR \fIlist\fR
.B ;;
] .\|.\|. \fBesac\fR
.ad
.sp .6
.RS 4n
A
.B case
command executes the
.I list
associated with the first
\fIpattern\fR that matches
.IR word .
The form of the patterns is the same
as that used for file-name generation. See
.BR "File Name Generation" .
.RE

.sp
.ne 2
.mk
.na
\fBif\fR \fIlist\fR \fB; then\fR \fIlist\fR
.B ;
[ \fBelif\fR
\fIlist\fR \fB; then\fR \fIlist\fR \fB;\fR .\|.\|. ] [
.B else
\fIlist\fR
\fB;\fR ] \fBfi\fR
.ad
.sp .6
.RS 4n
The
.I list
following
.B if
is executed and, if it returns an exit
status of
.BR 0 ,
the
.I list
following the first
.B then
is
executed. Otherwise, the
.I list
following
.B elif
is executed and, if
its value is
.BR 0 ,
the
.I list
following the next
.B then
is
executed. Failing that, the
.B else
\fIlist\fR is executed. If no
.B else
.I list
or
.B then
\fIlist\fR is executed, then the
\fBif\fR command returns
.B 0
exit status.
.RE

.sp
.ne 2
.mk
.na
.B while
.I list
.B "; do"
.I list
.B ; done
.ad
.br
.na
.B until
.I list
.B "; do"
.I list
.B ; done
.ad
.sp .6
.RS 4n
A
.B while
command repeatedly executes the
.B while
\fIlist\fR and,
if the exit status of the last command in the list is
.BR 0 ,
executes the
.B do
.IR list ;
otherwise the loop terminates. If no commands in the
.B do
.I list
are executed, then the
.B while
command returns
\fB0\fR exit status. \fBuntil\fR can be used in place of
.B while
to
negate the loop termination test.
.RE

.sp
.ne 2
.mk
.na
\fB(\fIlist\fB)\fR
.ad
.sp .6
.RS 4n
Execute
.I list
in a separate environment. If two adjacent open
parentheses are needed for nesting, a space must be inserted to avoid
arithmetic evaluation.
.RE

.sp
.ne 2
.mk
.na
\fB{\fIlist\fB}\fR
.ad
.sp .6
.RS 4n
\fIlist\fR is simply executed. Unlike the metacharacters
.B (
and
.BR ) ,
\fB{\fR and
.B }
are \fIreserved word\fRs and must occur at the
beginning of a line or after a
.B ;
in order to be recognized.
.RE

.sp
.ne 2
.mk
.na
\fB[[\fIexpression\fB]]\fR
.ad
.sp .6
.RS 4n
Evaluates
.I expression
and returns
.B 0
exit status when
\fIexpression\fR is true. See
.B Conditional Expressions
for a
description of
.IR expression .
.RE

.sp
.ne 2
.mk
.na
\fBfunction\fR \fIidentifier\fR \fB{\fR
.I list
\fB;}\fR
.ad
.br
.na
.IB identifier "( ) {"
\fIlist\fR \fB;}\fR
.ad
.sp .6
.RS 4n
Define a function which is referenced by
.IR identifier .
The body of the
function is the
.I list
of commands between
.BR { " and"
.BR } .
See
.BR Functions .
.RE

.sp
.ne 2
.mk
.na
.BI time " pipeline"
.ad
.sp .6
.RS 4n
The
.I pipeline
is executed and the elapsed time as well as the user and
system time are printed to standard error.
.RE

.sp
.LP
The following reserved words are only recognized as the first word of a
command and when not quoted:
.sp
.in +2
.nf
!          if       then     else    elif    fi      case
esac       for      while    until   do      done    {   }
function   select   time     [[  ]]
.fi
.in -2
.sp

.SS "Comments"
.sp
.LP
A word beginning with
.B #
causes that word and all the following
characters up to a new-line to be ignored.
.SS "Aliasing"
.sp
.LP
The first word of each command is replaced by the text of an alias if an
alias for this word has been defined. An alias name consists of any number
of characters excluding metacharacters, quoting characters, file expansion
characters, parameter and command substitution characters, and
.BR = .
The
replacement string can contain any valid shell script including the
metacharacters listed above. The first word of each command in the replaced
text, other than any that are in the process of being replaced, is tested
for aliases. If the last character of the alias value is a
.I blank
then
the word following the alias is also be checked for alias substitution.
Aliases can be used to redefine special builtin commands but cannot be used
to redefine the reserved words listed above. Aliases can be created, listed,
and exported with the
.B alias
command and can be removed with the
\fBunalias\fR command. Exported aliases remain in effect for scripts invoked
by name, but must be reinitialized for separate invocations of the shell.
See
.BR Invocation .
To prevent infinite loops in recursive aliasing, if
the shell is not currently processing an alias of the same name, the word is
replaced by the value of the alias; otherwise, it is not be replaced.
.sp
.LP
Aliasing is performed when scripts are read, not while they are executed.
Therefore, for an alias to take effect, the
.B alias
definition command
has to be executed before the command which references the alias is read.
.sp
.LP
Aliases are frequently used as a short hand for full path names. An option
to the aliasing facility allows the value of the alias to be automatically
set to the full pathname of the corresponding command. These aliases are
called
.I tracked
aliases. The value of a
.I tracked
alias is defined
the first time the corresponding command is looked up and becomes undefined
each time the
.B PATH
variable is reset. These aliases remain
\fItracked\fR so that the next subsequent reference redefines the value.
Several tracked aliases are compiled into the shell. The
.B -h
option of
the
.B set
command makes each referenced command name into a tracked
alias.
.sp
.LP
The following
.I "exported aliases"
are compiled into (and built-in to)
the shell but can be unset or redefined:
.sp
.in +2
.nf
\fBautoload='typeset \(mifu'
functions='typeset \(mif'
history='fc \(mil'
integer='typeset \(mii'
nohup='nohup '
r='fc \(mie \(mi'\fR
.fi
.in -2
.sp

.sp
.LP
An example concerning trailing blank characters and reserved words follows.
If the user types:
.sp
.in +2
.nf
$ \fBalias foo="/bin/ls "\fR
$ \fBalias while="/"\fR
.fi
.in -2
.sp

.sp
.LP
the effect of executing:
.sp
.in +2
.nf
$ \fBwhile true\fR
> \fBdo\fR
> \fBecho "Hello, World"\fR
> \fBdone\fR
.fi
.in -2
.sp

.sp
.LP
is a never-ending sequence of
.B "Hello, World"
strings to the screen.
However, if the user types:
.sp
.in +2
.nf
$ \fBfoo while\fR
.fi
.in -2
.sp

.sp
.LP
the result is an
.B ls
listing of
.BR / .
Since the alias substitution
for
.B foo
ends in a space character, the next word is checked for alias
substitution. The next word,
.BR while ,
has also been aliased, so it is
substituted as well. Since it is not in the proper position as a command
word, it is not recognized as a reserved word.
.sp
.LP
If the user types:
.sp
.in +2
.nf
$ \fBfoo; while\fR
.fi
.in -2
.sp

.sp
.LP
\fBwhile\fR retains its normal reserved-word properties.
.SS "Tilde Substitution"
.sp
.LP
After alias substitution is performed, each word is checked to see if it
begins with an unquoted
.BR ~ .
If it does, then the word up to a
.B /
is checked to see if it matches a user name. If a match is found, the
\fB~\fR and the matched login name are replaced by the login directory of
the matched user. This is called a
.I tilde
substitution. If no match is
found, the original text is left unchanged. A
.B ~
by itself, or in front
of a
.BR / ,
is replaced by
.BR $HOME .
A
.B ~
followed by a
.B +
or
\fB\(mi\fR is replaced by
.B $PWD
and
.BR $OLDPWD ,
respectively.
.sp
.LP
In addition,
.I tilde
substitution is attempted when the value of a
\fIvariable assignment\fR begins with a \fB~\fR.
.SS "Tilde Expansion"
.sp
.LP
A
.I tilde-prefix
consists of an unquoted tilde character at the
beginning of a word, followed by all of the characters preceding the first
unquoted slash in the word, or all the characters in the word if there is no
slash. In an assignment, multiple tilde-prefixes can be used: at the
beginning of the word (that is, following the equal sign of the assignment),
following any unquoted colon or both. A tilde-prefix in an assignment is
terminated by the first unquoted colon or slash. If none of the characters
in the tilde-prefix are quoted, the characters in the tilde-prefix following
the tilde are treated as a possible login name from the user database.
.sp
.LP
A portable login name cannot contain characters outside the set given in
the description of the
.B LOGNAME
environment variable. If the login name
is null (that is, the tilde-prefix contains only the tilde), the
tilde-prefix is replaced by the value of the variable
.BR HOME .
If
\fBHOME\fR is unset, the results are unspecified. Otherwise, the
tilde-prefix is replaced by a pathname of the home directory associated with
the login name obtained using the
.B getpwnam
function. If the system
does not recognize the login name, the results are undefined.
.sp
.LP
Tilde expansion generally occurs only at the beginning of words, but an
exception based on historical practice has been included:
.sp
.in +2
.nf
PATH=/posix/bin:~dgk/bin
.fi
.in -2

.sp
.LP
is eligible for tilde expansion because tilde follows a colon and none of
the relevant characters is quoted. Consideration was given to prohibiting
this behavior because any of the following are reasonable substitutes:
.sp
.in +2
.nf
PATH=$(printf %s ~karels/bin : ~bostic/bin)
for Dir in ~maart/bin ~srb/bin .
do
     PATH=${PATH:+$PATH:}$Dir
done
.fi
.in -2

.sp
.LP
With the first command, explicit colons are used for each directory. In all
cases, the shell performs tilde expansion on each directory because all are
separate words to the shell.
.sp
.LP
Expressions in operands such as:
.sp
.in +2
.nf
make -k mumble LIBDIR=~chet/lib
.fi
.in -2

.sp
.LP
do not qualify as shell variable assignments and tilde expansion is not
performed (unless the command does so itself, which
.B make
does not).
.sp
.LP
The special sequence
.B $~
has been designated for future
implementations to evaluate as a means of forcing tilde expansion in any
word.
.sp
.LP
Because of the requirement that the word not be quoted, the following are
not equivalent; only the last causes tilde expansion:
.sp
.in +2
.nf
\fB\e~hlj/   ~h\elj/   ~"hlj"/   ~hlj\e/   ~hlj/\fR
.fi
.in -2
.sp

.sp
.LP
The results of giving tilde with an unknown login name are undefined
because the KornShell
.B ~+
and \fB~\(mi\fR constructs make use of this
condition, but, in general it is an error to give an incorrect login name
with tilde. The results of having
.B HOME
unset are unspecified because
some historical shells treat this as an error.
.SS "Command Substitution"
.sp
.LP
The standard output from a
.I command
enclosed in parenthesis preceded
by a dollar sign (that is, \fB$(\fIcommand\fB)\fR) or a pair of grave
accents
.RB ( `` )
can be used as part or all of a word. Trailing new-lines
are removed. In the second (archaic) form, the string between the quotes is
processed for special quoting characters before the command is executed. See
.BR Quoting .
The command substitution
.B $(cat
.IB file )
can be
replaced by the equivalent but faster \fB$(<\fIfile\fB)\fR. Command
substitution of most special commands that do not perform input/output
redirection are carried out without creating a separate process.
.sp
.LP
Command substitution allows the output of a command to be substituted in
place of the command name itself. Command substitution occurs when the
command is enclosed as follows:
.sp
.in +2
.nf
$(\fIcommand\fR)
.fi
.in -2
.sp

.sp
.LP
or (backquoted version):
.sp
.in +2
.nf
`\fIcommand\fB`\fR
.fi
.in -2
.sp

.sp
.LP
The shell expands the command substitution by executing
.I command
in a
subshell environment and replacing the command substitution (the text of
\fIcommand\fR plus the enclosing
.B $()
or backquotes) with the standard
output of the command, removing sequences of one or more newline characters
at the end of the substitution. Embedded newline characters before the end
of the output is not be removed; however, they can be treated as field
delimiters and eliminated during field splitting, depending on the value of
\fBIFS\fR and quoting that is in effect.
.sp
.LP
Within the backquoted style of command substitution, backslash shall retain
its literal meaning, except when followed by:
.sp
.in +2
.nf
\fB$     `     \e\fR
.fi
.in -2
.sp

.sp
.LP
(dollar-sign, backquote, backslash). The search for the matching backquote
is satisfied by the first backquote found without a preceding backslash.
During this search, if a non-escaped backquote is encountered within a shell
comment, a here-document, an embedded command substitution of the
.RI $( command )
form, or a quoted string, undefined results occur. A
single- or double-quoted string that begins, but does not end, within the
`\fB\&.\|.\|.\fR` sequence produces undefined results.
.sp
.LP
With the $(\fIcommand\fR) form, all characters following the open
parenthesis to the matching closing parenthesis constitute the
.IR command .
Any valid shell script can be used for
.IR command ,
except:
.RS +4
.TP
.ie t \(bu
.el o
A script consisting solely of redirections produces unspecified results.
.RE
.RS +4
.TP
.ie t \(bu
.el o
See the restriction on single subshells.
.RE
.sp
.LP
The results of command substitution are not field splitting and pathname
expansion processed for further tilde expansion, parameter expansion,
command substitution or arithmetic expansion. If a command substitution
occurs inside double-quotes, it is not be performed on the results of the
substitution.
.sp
.LP
Command substitution can be nested. To specify nesting within the
backquoted version, the application must precede the inner backquotes with
backslashes; for example:
.sp
.in +2
.nf
`\e`\fIcommand\fB\e``\fR
.fi
.in -2
.sp

.sp
.LP
The
.B $()
form of command substitution solves a problem of inconsistent
behavior when using backquotes. For example:
.sp

.sp
.TS
tab() box;
cw(2.75i) cw(2.75i)
lw(2.75i) lw(2.75i)
.
CommandOutput
_
echo '\e$x'\e$x
echo `echo '\e$x'`$x
echo $(echo '\e$x')\e$x
.TE

.sp
.LP
Additionally, the backquoted syntax has historical restrictions on the
contents of the embedded command. While the new
.B $()
form can process
any kind of valid embedded script, the backquoted form cannot handle some
valid scripts that include backquotes. For example, these otherwise valid
embedded scripts do not work in the left column, but do work on the right:
.sp

.sp
.TS
tab() box;
lw(2.75i) lw(2.75i)
lw(2.75i) lw(2.75i)
.
echo `echo $(
cat <<eofcat <<eof
a here-doc with `a here-doc with )
eofeof
`)
echo `echo $(
echo abc # a comment with `echo abc # a comment with )
`)
echo `echo $(
echo '`'echo ')'
`)
.TE

.sp
.LP
Because of these inconsistent behaviors, the backquoted variety of command
substitution is not recommended for new applications that nest command
substitutions or attempt to embed complex scripts.
.sp
.LP
If the command substitution consists of a single subshell, such as:
.sp
.in +2
.nf
$( (\fIcommand\fR) )
.fi
.in -2
.sp

.sp
.LP
a portable application must separate the
.B $(
and
.B (
into two
tokens (that is, separate them with white space). This is required to avoid
any ambiguities with arithmetic expansion.
.SS "Arithmetic Expansion"
.sp
.LP
An arithmetic expression enclosed in double parentheses preceded by a
dollar sign ( \fB$((\fIarithmetic-expression\fB))\fR ) is replaced by
the value of the arithmetic expression within the double parenthesis.
Arithmetic expansion provides a mechanism for evaluating an arithmetic
expression and substituting its value. The format for arithmetic expansion
is as follows:
.sp
.in +2
.nf
$((\fIexpression\fR))
.fi
.in -2
.sp

.sp
.LP
The expression is treated as if it were in double-quotes, except that a
double-quote inside the expression is not treated specially. The shell
expands all tokens in the expression for parameter expansion, command
substitution and quote removal.
.sp
.LP
Next, the shell treats this as an arithmetic expression and substitute the
value of the expression. The arithmetic expression is processed according to
the rules of the ISO C with the following exceptions:
.RS +4
.TP
.ie t \(bu
.el o
Only integer arithmetic is required.
.RE
.RS +4
.TP
.ie t \(bu
.el o
The
.B sizeof()
operator and the prefix and postfix
.B ++
and
\fB\(mi\|\(mi\fR operators are not required.
.RE
.RS +4
.TP
.ie t \(bu
.el o
Selection, iteration, and jump statements are not supported.
.RE
.RS +4
.TP
.ie t \(bu
.el o
\fB/usr/bin/ksh\fR and
.B /usr/bin/rksh
treat prefix 0 through 9 as
decimal constants. See the following examples:
.sp

.sp
.TS
tab();
cw(1.83i) cw(1.83i) cw(1.83i)
lw(1.83i) lw(1.83i) lw(1.83i)
.
CommandResult in /bin/kshResult in /usr/xpg4/bin/sh
\fBecho $((010+10))\fR2018
\fBecho $((019+10))\fR29error
\fB[ 10 \(emle $((011)) ]\fRtruefalse
.TE

.RE
.sp
.LP
As an extension, the shell can recognize arithmetic expressions beyond
those listed. If the expression is invalid, the expansion fails and the
shell writes a message to standard error indicating the failure.
.sp
.LP
A simple example using arithmetic expansion:
.sp
.in +2
.nf
# repeat a command 100 times
x=100
while [ $x \(migt 0 ]
do
     command
     x=$(($x\(mi1))
done
.fi
.in -2

.SS "Process Substitution"
.sp
.LP
This feature is available in SunOS and only on versions of the UNIX
operating system that support the
.B /dev/fd
directory for naming open
files. Each command argument of the form \fB<(\fIlist\fB)\fR or
\fB>(\fIlist\fB)\fR runs process
.I list
asynchronously connected
to some file in
.BR /dev/fd .
The name of this file becomes the argument to
the command. If the form with
.B >
is selected, then writing on this file
provides input for
.IR list .
If
.B <
is used, then the file passed as
an argument contains the output of the
.I list
process. For example:
.sp
.in +2
.nf
paste <(cut -f1 \fIfile1\fR) <(cut -f3 \fIfile2\fR) | tee >(\fIprocess1\fR) >(\fIprocess2\fR)
.fi
.in -2
.sp

.sp
.LP
\fBcut\fRs fields 1 and 3 from the files
.I file1
and \fIfile2\fR,
respectively,
.BR paste s
the results together, and sends it to the
processes
.I process1
and
.IR process2 ,
as well as putting it onto the
standard output. The file, which is passed as an argument to the command, is
a UNIX
.BR pipe (2)
so programs that expect to
.BR lseek (2)
on the file
does not work.
.SS "Parameter Substitution"
.sp
.LP
A
.I parameter
is an
.IR identifier ,
one or more digits, or any of the
characters
.BR * ,
.BR @ ,
.BR # ,
.BR ? ,
.BR \(mi ,
.BR $ ,
and
.BR ! .
A
.I variable
(a
.I parameter
denoted by an
.IR identifier )
has a
.I value
and zero or more
.IR attributes .
\fIvariable\fRs can be
assigned
.IR value s
and \fIattribute\fRs by using the \fBtypeset\fR
special command. The attributes supported by the shell are described later
with the
.B typeset
special command. Exported variables pass values and
attributes to the environment.
.sp
.LP
The shell supports a one-dimensional array facility. An element of an array
variable is referenced by a
.IR subscript .
A
.I subscript
is denoted by
a
.BR [ ,
followed by an
.IR "arithmetic expression" ,
followed by a
.BR ] .
See
.BR "Arithmetic Evaluation" .
To assign values to an array, use
.B "set -A"
.I "name value"
\fB\&.\|.\|.\fR. The
.I value
of all
subscripts must be in the range of 0 through 4095. Arrays need not be
declared. Any reference to a variable with a valid subscript is legal and an
array is created if necessary. Referencing an array without a subscript is
equivalent to referencing the element
.BR 0 .
If an array
.I identifier
with subscript
.B *
or
.B @
is used, then the value for each of the
elements is substituted (separated by a field separator character).
.sp
.LP
The
.I value
of a
.I variable
can be assigned by writing:
.sp
.in +2
.nf
\fIname\fR=\fIvalue\fR [ \fIname\fR=\fIvalue\fR ] .\|.\|.
.fi
.in -2
.sp

.sp
.LP
If the integer attribute,
.BR -i ,
is set for
.IR name ,
the
.IR value
is subject to arithmetic evaluation.
.sp
.LP
Positional parameters, parameters denoted by a number, can be assigned
values with the
.B set
special command. Parameter
.B $0
is set from
argument zero when the shell is invoked. If
.I parameter
is one or more
digits then it is a positional parameter. A positional parameter of more
than one digit must be enclosed in braces.
.SS "Parameter Expansion"
.sp
.LP
The format for parameter expansion is as follows:
.sp
.in +2
.nf
${\fIexpression\fR}
.fi
.in -2
.sp

.sp
.LP
where
.I expression
consists of all characters until the matching
.BR } .
Any
.B }
escaped by a backslash or within a quoted string, and
characters in embedded arithmetic expansions, command substitutions and
variable expansions, are not examined in determining the matching
.BR } .
.sp
.LP
The simplest form for parameter expansion is:
.sp
.in +2
.nf
${\fIparameter\fR}
.fi
.in -2
.sp

.sp
.LP
The value, if any, of
.I parameter
is substituted.
.sp
.LP
The parameter name or symbol can be enclosed in braces, which are optional
except for positional parameters with more than one digit or when
\fIparameter\fR is followed by a character that could be interpreted as part
of the name. The matching closing brace are determined by counting brace
levels, skipping over enclosed quoted strings and command substitutions.
.sp
.LP
If the parameter name or symbol is not enclosed in braces, the expansion
uses the longest valid name whether or not the symbol represented by that
name exists. When the shell is scanning its input to determine the
boundaries of a name, it is not bound by its knowledge of what names are
already defined. For example, if
.B F
is a defined shell variable, the
command:
.sp
.in +2
.nf
\fBecho $Fred\fR
.fi
.in -2
.sp

.sp
.LP
does not echo the value of
.B $F
followed by
.BR red ;
it selects the
longest possible valid name,
.BR Fred ,
which in this case might be
unset.
.sp
.LP
If a parameter expansion occurs inside double-quotes:
.RS +4
.TP
.ie t \(bu
.el o
Pathname expansion is not be performed on the results of the expansion.
.RE
.RS +4
.TP
.ie t \(bu
.el o
Field splitting is not performed on the results of the expansion, with the
exception of
.BR @ .
.RE
.sp
.LP
In addition, a parameter expansion can be modified by using one of the
following formats. In each case that a value of
.I word
is needed (based
on the state of
.IR parameter ),
\fIword\fR is subjected to tilde
expansion, parameter expansion, command substitution and arithmetic
expansion. If
.I word
.RB "is not needed, it is not expanded. The" " }"
character that delimits the following parameter expansion modifications is
determined as described previously in this section and in
.BR dquote .
(For
.RB "example, " ${foo-bar}xyz} " would result in the expansion of " foo 
followed by the string
.BR xyz} " if "
.B foo
is set, else the string
.BR barxyz} ).
.sp
.ne 2
.mk
.na
\fB${\fIparameter\fR:\(mi\fIword\fB}\fR
.ad
.RS 25n
.rt
\fBUse Default Values.\fR If
.I parameter
is unset or null, the
expansion of
.I word
is substituted. Otherwise, the value of
\fIparameter\fR is substituted.
.RE

.sp
.ne 2
.mk
.na
\fB${\fIparameter\fR:=\fIword\fB}\fR
.ad
.RS 25n
.rt
\fBAssign Default Values.\fR If
.I parameter
is unset or null, the
expansion of
.I word
is assigned to
.IR parameter .
In all cases, the
final value of
.I parameter
is substituted. Only variables, not
positional parameters or special parameters, can be assigned in this way.
.RE

.sp
.ne 2
.mk
.na
\fB${\fIparameter\fR:?[\fIword\fR]\fB}\fR
.ad
.RS 25n
.rt
\fBIndicate Error if Null or Unset.\fR If
.I parameter
is unset or null,
the expansion of
.I word
(or a message indicating it is unset if
\fIword\fR is omitted) is written to standard error and the shell exits with
a non-zero exit status. Otherwise, the value of
.I parameter
is
substituted. An interactive shell need not exit.
.RE

.sp
.ne 2
.mk
.na
\fB${\fIparameter\fR:+[\fIword\fR]\fB}\fR
.ad
.RS 25n
.rt
\fBUse Alternative Value.\fR If
.I parameter
is unset or \fBnull\fR,
\fBnull\fR is substituted. Otherwise, the expansion of
.I word
is
substituted.
.RE

.sp
.LP
In the parameter expansions shown previously, use of the colon in the
format results in a test for a parameter that is unset or
.BR null .
Omission of the colon results in a test for a parameter that is only unset.
The following two tables summarize the effect of the colon:
.sp

.ne 16
.TS
tab();
cw(1.83i) |cw(1.83i) |cw(1.83i)
lw(1.83i) |lw(1.83i) |lw(1.83i)
.
parameter set and not nullparameter set and null
_
\fB${\fIparameter\fB:-\fIword\fB}\fRsubstitute \fIparameter\fRsubstitute \fIword\fR
_
\fB${\fIparameter\fB\(mi\fIword\fB}\fRsubstitute \fIparameter\fRsubstitute null
_
\fB${\fIparameter\fB:=\fIword\fB}\fRsubstitute \fIparameter\fRassign \fIword\fR
_
\fB${\fIparameter\fB=\fIword\fB}\fRsubstitute \fIparameter\fRsubstitute \fIparameter\fR
_
\fB${\fIparameter\fB:?\fIword\fB}\fRsubstitute \fIparameter\fRerror, exit
_
\fB${\fIparameter\fB?\fIword\fB}\fRsubstitute \fIparameter\fRsubstitute null
_
\fB${\fIparameter\fB:+\fIword\fB}\fRsubstitute \fIword\fRsubstitute null
_
\fB${\fIparameter\fB+\fIword\fB}\fRsubstitute \fIword\fRsubstitute \fIword\fR
.TE

.sp

.ne 16
.TS
tab();
cw(2.75i) |cw(2.75i)
lw(2.75i) |lw(2.75i)
.
parameter unset
_
\fB${\fIparameter\fB:-\fIword\fB}\fRsubstitute \fIword\fR
_
\fB${\fIparameter\fB\(mi\fIword\fB}\fRsubstitute \fIword\fR
_
\fB${\fIparameter\fB:=\fIword\fB}\fRassign \fIword\fR
_
\fB${\fIparameter\fB=\fIword\fB}\fRassign null
_
\fB${\fIparameter\fB:?\fIword\fB}\fRerror, exit
_
\fB${\fIparameter\fB?\fIword\fB}\fRerror,exit
_
\fB${\fIparameter\fB:+\fIword\fB}\fRsubstitute null
_
\fB${\fIparameter\fB+\fIword\fB}\fRsubstitute null
.TE

.sp
.LP
In all cases shown with "substitute", the expression is replaced with the
value shown. In all cases shown with "assign", \fIparameter\fR is assigned
that value, which also replaces the expression.
.sp
.ne 2
.mk
.na
\fB${#\fIparameter\fB}\fR
.ad
.RS 17n
.rt
.BR "String Length" .
The length in characters of the value of
.IR parameter .
If
.I parameter
is
.B *
or
.BR @ ,
then all the
positional parameters, starting with
.BR $1 ,
are substituted (separated by
a field separator character).
.RE

.sp
.LP
The following four varieties of parameter expansion provide for substring
processing. In each case, pattern matching notation  (see
.BR patmat ),
rather than regular expression notation, is used to evaluate the patterns.
If
.I parameter
is
.B *
or
.BR @ ,
then all the positional
parameters, starting with
.BR $1 ,
are substituted (separated by a field
separator character). Enclosing the full parameter expansion string in
double-quotes does not cause the following four varieties of pattern
characters to be quoted, whereas quoting characters within the braces has
this effect.
.sp
.ne 2
.mk
.na
\fB${\fIparameter\fR%\fIword\fB}\fR
.ad
.RS 22n
.rt
\fBRemove Smallest Suffix Pattern.\fR The
.I word
is expanded to produce
a pattern. The parameter expansion then results in
.IR parameter ,
with the
smallest portion of the suffix matched by the
.I pattern
deleted.
.RE

.sp
.ne 2
.mk
.na
\fB${\fIparameter\fR%%\fIword\fB}\fR
.ad
.RS 22n
.rt
\fBRemove Largest Suffix Pattern.\fR The
.I word
is expanded to produce
a pattern. The parameter expansion then results in
.IR parameter ,
with the
largest portion of the suffix matched by the
.I pattern
deleted.
.RE

.sp
.ne 2
.mk
.na
\fB${\fIparameter\fR#\fIword\fB}\fR
.ad
.RS 22n
.rt
\fBRemove Smallest Prefix Pattern.\fR The
.I word
is expanded to produce
a pattern. The parameter expansion then results in
.IR parameter ,
with the
smallest portion of the prefix matched by the
.I pattern
deleted.
.RE

.sp
.ne 2
.mk
.na
\fB${\fIparameter\fR##\fIword\fB}\fR
.ad
.RS 22n
.rt
\fBRemove Largest Prefix Pattern.\fR The
.I word
is expanded to produce
a pattern. The parameter expansion then results in
.IR parameter ,
with the
largest portion of the prefix matched by the
.I pattern
deleted.
.RE

.sp
.LP
.BR Examples :
.sp
.LP
${\fIparameter\fR:\(mi\fIword\fR}
.sp
.LP
In this example,
.B ls
is executed only if
.B x
is
.B null
or
unset. (The
.B $(ls)
command substitution notation is explained in
\fBCommand Substitution\fR above.)
.sp
.in +2
.nf
${x:-$(ls)}
.fi
.in -2

.sp
.LP
.RI ${ parameter := word }
.sp
.in +2
.nf
unset X
echo ${X:=abc}
abc
.fi
.in -2

.sp
.LP
.RI ${ parameter :? word }
.sp
.in +2
.nf
unset posix
echo ${posix:?}
sh: posix: parameter null or not set
.fi
.in -2

.sp
.LP
.RI ${ parameter :+ word }
.sp
.in +2
.nf
set a b c
echo ${3:+posix}
posix
.fi
.in -2

.sp
.LP
${#\fIparameter\fR}
.sp
.in +2
.nf
HOME=/usr/posix
echo ${#HOME}
10
.fi
.in -2

.sp
.LP
.RI ${ parameter % word }
.sp
.in +2
.nf
x=file.c
echo ${x%.c}.o
file.o
.fi
.in -2

.sp
.LP
.RI ${ parameter %% word }
.sp
.in +2
.nf
x=posix/src/std
echo ${x%%/*}
posix
.fi
.in -2

.sp
.LP
.RI ${ parameter # word }
.sp
.in +2
.nf
x=$HOME/src/cmd
echo ${x#$HOME}
/src/cmd
.fi
.in -2

.sp
.LP
.RI ${ parameter ## word }
.sp
.in +2
.nf
x=/one/two/three
echo ${x##*/}
three
.fi
.in -2

.SS "Parameters Set by Shell"
.sp
.LP
The following parameters are automatically set by the shell:
.sp
.ne 2
.mk
.na
.B #
.ad
.RS 11n
.rt
The number of positional parameters in decimal.
.RE

.sp
.ne 2
.mk
.na
\fB\(mi\fR
.ad
.RS 11n
.rt
Flags supplied to the shell on invocation or by the
.B set
command.
.RE

.sp
.ne 2
.mk
.na
.B ?
.ad
.RS 11n
.rt
The decimal value returned by the last executed command.
.RE

.sp
.ne 2
.mk
.na
.B $
.ad
.RS 11n
.rt
The process number of this shell.
.RE

.sp
.ne 2
.mk
.na
.B _
.ad
.RS 11n
.rt
Initially, the value of
.B _
is an absolute pathname of the shell or
script being executed as passed in the
.IR environment .
Subsequently it is
assigned the last argument of the previous command. This parameter is not
set for commands which are asynchronous. This parameter is also used to hold
the name of the matching
.B MAIL
file when checking for mail.
.RE

.sp
.ne 2
.mk
.na
.B !
.ad
.RS 11n
.rt
The process number of the last background command invoked.
.RE

.sp
.ne 2
.mk
.na
.B ERRNO
.ad
.RS 11n
.rt
The value of
.B errno
as set by the most recently failed system call.
This value is system dependent and is intended for debugging purposes.
.RE

.sp
.ne 2
.mk
.na
.B LINENO
.ad
.RS 11n
.rt
The line number of the current line within the script or function being
executed.
.RE

.sp
.ne 2
.mk
.na
.B OLDPWD
.ad
.RS 11n
.rt
The previous working directory set by the
.B cd
command.
.RE

.sp
.ne 2
.mk
.na
.B OPTARG
.ad
.RS 11n
.rt
The value of the last option argument processed by the
.BR getopts
special command.
.RE

.sp
.ne 2
.mk
.na
.B OPTIND
.ad
.RS 11n
.rt
The index of the last option argument processed by the
.BR getopts
special command.
.RE

.sp
.ne 2
.mk
.na
.B PPID
.ad
.RS 11n
.rt
The process number of the parent of the shell.
.RE

.sp
.ne 2
.mk
.na
.B PWD
.ad
.RS 11n
.rt
The present working directory set by the
.B cd
command.
.RE

.sp
.ne 2
.mk
.na
.B RANDOM
.ad
.RS 11n
.rt
Each time this variable is referenced, a random integer, uniformly
distributed between 0 and 32767, is generated. The sequence of random
numbers can be initialized by assigning a numeric value to
.BR RANDOM .
.RE

.sp
.ne 2
.mk
.na
.B REPLY
.ad
.RS 11n
.rt
This variable is set by the
.B select
statement and by the
.BR read
special command when no arguments are supplied.
.RE

.sp
.ne 2
.mk
.na
.B SECONDS
.ad
.RS 11n
.rt
Each time this variable is referenced, the number of seconds since shell
invocation is returned. If this variable is assigned a value, then the value
returned upon reference is the value that was assigned plus the number of
seconds since the assignment.
.RE

.SS "Variables Used by Shell"
.sp
.LP
The following variables are used by the shell:
.sp
.ne 2
.mk
.na
.B CDPATH
.ad
.RS 15n
.rt
The search path for the
.B cd
command.
.RE

.sp
.ne 2
.mk
.na
.B COLUMNS
.ad
.RS 15n
.rt
If this variable is set, the value is used to define the width of the edit
window for the shell edit modes and for printing
.B select
lists.
.RE

.sp
.ne 2
.mk
.na
.B EDITOR
.ad
.RS 15n
.rt
If the value of this variable ends in
.BR emacs ,
.BR gmacs ,
or
.BR vi
and the
.B VISUAL
variable is not set, then the corresponding option is
turned on. See the
.B set
special command.
.RE

.sp
.ne 2
.mk
.na
.B ENV
.ad
.RS 15n
.rt
This variable, when and only when an interactive shell is invoked, is
subjected to parameter expansion by the shell and the resulting value is
used as a pathname of a file containing shell commands to execute in the
current environment. The file need not be executable. If the expanded value
of
.B ENV
is not an absolute pathname, the results are unspecified.
\fBENV\fR is ignored if the user's real and effective user \fBID\fRs or real
and effective group
.BR ID s
are different.
.sp
This variable can be used to set aliases and other items local to the
invocation of a shell. The file referred to by
.B ENV
differs from
\fB$HOME/.profile\fR in that \fB\&.profile\fR is typically executed at
session startup, whereas the
.B ENV
file is executed at the beginning of
each shell invocation. The
.B ENV
value is interpreted in a manner
similar to a dot script, in that the commands are executed in the current
environment and the file needs to be readable, but not executable. However,
unlike dot scripts, no
.B PATH
searching is performed. This is used as a
guard against Trojan Horse security breaches.
.RE

.sp
.ne 2
.mk
.na
.B FCEDIT
.ad
.RS 15n
.rt
The default editor name for the
.B fc
command.
.RE

.sp
.ne 2
.mk
.na
.B FPATH
.ad
.RS 15n
.rt
The search path for function definitions. By default, the
.B FPATH
directories are searched after the
.B PATH
variable. If an executable
file is found, then it is read and executed in the current environment.
\fBFPATH\fR is searched before
.B PATH
when a function with the \fB-u\fR
attribute is referenced. The preset alias
.B autoload
causes a function
with the
.B -u
attribute to be created.
.RE

.sp
.ne 2
.mk
.na
.B HISTFILE
.ad
.RS 15n
.rt
If this variable is set when the shell is invoked, then the value is the
pathname of the file that is used to store the command history. See
.BR "Command re-entry" .
.RE

.sp
.ne 2
.mk
.na
.B HISTSIZE
.ad
.RS 15n
.rt
If this variable is set when the shell is invoked, then the number of
previously entered commands that are accessible by this shell is greater
than or equal to this number. The default is
.BR 128 .
.RE

.sp
.ne 2
.mk
.na
.B HOME
.ad
.RS 15n
.rt
The default argument (home directory) for the
.B cd
command.
.RE

.sp
.ne 2
.mk
.na
.B IFS
.ad
.RS 15n
.rt
Internal field separators, normally
.BR space ,
.BR tab ,
and
\fBnew-line\fR that are used to separate command words which result from
command or parameter substitution and for separating words with the special
command
.BR read .
The first character of the
.B IFS
variable is used to
separate arguments for the
.B $*
substitution. See
.BR Quoting .
.RE

.sp
.ne 2
.mk
.na
.B LANG
.ad
.RS 15n
.rt
Provide a default value for the internationalization variables that are
unset or null. If any of the internationalization variables contains an
invalid setting, the utility behaves as if none of the variables had been
defined.
.RE

.sp
.ne 2
.mk
.na
.B LC_ALL
.ad
.RS 15n
.rt
This variable provides a default value for the
.B LC_*
variables.
.RE

.sp
.ne 2
.mk
.na
.B LC_COLLATE
.ad
.RS 15n
.rt
This variable determines the behavior of range expressions, equivalence
classes and multi-byte character collating elements within pattern
matching.
.RE

.sp
.ne 2
.mk
.na
.B LC_CTYPE
.ad
.RS 15n
.rt
Determines how the shell handles characters. When
.B LC_CTYPE
is set to
a valid value, the shell can display and handle text and filenames
containing valid characters for that locale. If
.B LC_CTYPE
(see
.BR environ (5))
is not set in the environment, the operational behavior of
the shell is determined by the value of the
.B LANG
environment variable.
If
.B LC_ALL
is set, its contents are used to override both the
\fBLANG\fR and the other
.B LC_*
variables.
.RE

.sp
.ne 2
.mk
.na
.B LC_MESSAGES
.ad
.RS 15n
.rt
This variable determines the language in which messages should be
written.
.RE

.sp
.ne 2
.mk
.na
.B LINENO
.ad
.RS 15n
.rt
This variable is set by the shell to a decimal number representing the
current sequential line number (numbered starting with 1) within a script or
function before it executes each command. If the user unsets or resets
.BR LINENO ,
the variable can lose its special meaning for the life of the
shell. If the shell is not currently executing a script or function, the
value of
.B LINENO
is unspecified.
.RE

.sp
.ne 2
.mk
.na
.B LINES
.ad
.RS 15n
.rt
If this variable is set, the value is used to determine the column length
for printing
.B select
lists. Select lists print vertically until about
two-thirds of
.B LINES
lines are filled.
.RE

.sp
.ne 2
.mk
.na
.B MAIL
.ad
.RS 15n
.rt
If this variable is set to the name of a mail file
.I and
the
\fBMAILPATH\fR variable is not set, then the shell informs the user of
arrival of mail in the specified file.
.RE

.sp
.ne 2
.mk
.na
.B MAILCHECK
.ad
.RS 15n
.rt
This variable specifies how often (in seconds) the shell checks for changes
in the modification time of any of the files specified by the
.BR MAILPATH
or
.B MAIL
variables. The default value is
.B 600
seconds. When the
time has elapsed the shell checks before issuing the next prompt.
.RE

.sp
.ne 2
.mk
.na
.B MAILPATH
.ad
.RS 15n
.rt
A colon
.RB ( : )
separated list of file names. If this variable is set,
then the shell informs the user of any modifications to the specified files
that have occurred within the last
.B MAILCHECK
seconds. Each file name
can be followed by a
.B ?
and a message that is printed. The message
undergoes parameter substitution with the variable
.B $_
defined as the
name of the file that has changed. The default message is \fByou have mail in $_\fR.
.RE

.sp
.ne 2
.mk
.na
.B NLSPATH
.ad
.RS 15n
.rt
Determine the location of message catalogues for the processing of
.BR LC_MESSAGES .
.RE

.sp
.ne 2
.mk
.na
.B PATH
.ad
.RS 15n
.rt
The search path for commands. See
.BR Execution .
The user cannot change
\fBPATH\fR if executing under
.B rksh
(except in \fB\&.profile\fR).
.RE

.sp
.ne 2
.mk
.na
.B PPID
.ad
.RS 15n
.rt
This variable is set by the shell to the decimal process ID of the process
that invoked the shell. In a subshell,
.B PPID
is set to the same value
as that of the parent of the current shell. For example,
.B "echo $PPID"
and
.B "(echo $PPID)"
would produce the same value.
.RE

.sp
.ne 2
.mk
.na
.B PS1
.ad
.RS 15n
.rt
The value of this variable is expanded for parameter substitution to define
the primary prompt string which by default is ``\fB$ \|\fR''. The character
\fB!\fR in the primary prompt string is replaced by the \fIcommand\fR
number. See
.BR "Command Re-entry" .
Two successive occurrences of
.BR !
produces a single
.B !
when the prompt string is printed.
.RE

.sp
.ne 2
.mk
.na
.B PS2
.ad
.RS 15n
.rt
Secondary prompt string, by default ``\fB> \|\fR''.
.RE

.sp
.ne 2
.mk
.na
.B PS3
.ad
.RS 15n
.rt
Selection prompt string used within a
.B select
loop, by default ``\fB#?\|\fR''.
.RE

.sp
.ne 2
.mk
.na
.B PS4
.ad
.RS 15n
.rt
The value of this variable is expanded for parameter substitution and
precedes each line of an execution trace. If omitted, the execution trace
prompt is ``\fB+ \|\fR''.
.RE

.sp
.ne 2
.mk
.na
.B PWD
.ad
.RS 15n
.rt
Set by the shell to be an absolute pathname of the current working
directory, containing no components of type symbolic link, no components
that are dot, and no components that are dot-dot when the shell is
initialized. If an application sets or unsets the value of
.BR PWD ,
the
behaviors of the
.B cd
and
.B pwd
utilities are unspecified
.RE

.sp
.ne 2
.mk
.na
.B SHELL
.ad
.RS 15n
.rt
The pathname of the
.I shell
is kept in the environment. At invocation,
if the basename of this variable is
.BR rsh ,
.BR rksh ,
or
.BR krsh ,
then the shell becomes restricted.
.RE

.sp
.ne 2
.mk
.na
.B TMOUT
.ad
.RS 15n
.rt
If set to a value greater than zero, the shell terminates if a command is
not entered within the prescribed number of seconds after issuing the
\fBPS1\fR prompt. The shell can be compiled with a maximum bound for this
value which cannot be exceeded.
.RE

.sp
.ne 2
.mk
.na
.B VISUAL
.ad
.RS 15n
.rt
If the value of this variable ends in
.BR emacs ,
.BR gmacs ,
or
.BR vi ,
then the corresponding option is turned on. See Special Command
.BR set .
.RE

.sp
.LP
The shell gives default values to
.BR PATH ,
.BR PS1 ,
.BR PS2 ,
.BR PS3 ,
.BR PS4 ,
.BR MAILCHECK ,
.BR FCEDIT ,
.BR TMOUT ,
and
.BR IFS ,
while
.BR HOME ,
.BR SHELL ,
.BR ENV ,
and
.B MAIL
are not
set at all by the shell (although
.B "HOME is"
set by
.BR login (1)).
On some systems
.B MAIL
and
.B SHELL
are also set by
.BR login .
.SS "Blank Interpretation"
.sp
.LP
After parameter and command substitution, the results of substitutions are
scanned for the field separator characters (those found in
.BR IFS )
and
split into distinct arguments where such characters are found. Explicit null
arguments ( \fB""\fR ) or (\fB\&''\fR) are retained. Implicit null arguments
(those resulting from
.I parameters
that have no values) are removed.
.SS "File Name Generation"
.sp
.LP
Following substitution, each command
.I word
is scanned for the
characters
.BR * ,
\fB?\fR, and \fB[\fR unless the \fB-f\fR option has been
.BR set .
If one of these characters appears, the word is regarded as a
.IR pattern .
The word is replaced with lexicographically sorted file names
that match the pattern. If no file name is found that matches the pattern,
the word is left unchanged. When a
.I pattern
is used for file name
generation, the character period (\fB\&.\fR) at the start of a file name or
immediately following a
.BR / ,
as well as the character
.B /
itself,
must be matched explicitly. A file name beginning with a period is not
matched with a pattern with the period inside parentheses. That is, \fBls \&.@(r*)\fR would locate a file named \fB\&.restore\fR, but \fBls @(.r*)\fR
would not. In other instances of pattern matching, the
.B /
and \fB\&.\fR
are not treated specially.
.sp
.ne 2
.mk
.na
.B *
.ad
.RS 9n
.rt
Matches any string, including the null string.
.RE

.sp
.ne 2
.mk
.na
.B ?
.ad
.RS 9n
.rt
Matches any single character.
.RE

.sp
.ne 2
.mk
.na
\fB[\fR.\|.\|.\fB]\fR
.ad
.RS 9n
.rt
Matches any one of the enclosed characters. A pair of characters separated
by
.B \(mi
matches any character lexically between the pair, inclusive.
If the first character following the opening "[" is a "! ", then any
character not enclosed is matched. A
.B \(mi
can be included in the
character set by putting it as the first or last character.
.RE

.sp
.LP
A
.I pattern-list
is a list of one or more patterns separated from each
other with a
.BR | .
Composite patterns can be formed with one or more of
the following:
.sp
.ne 2
.mk
.na
\fB?(\fIpattern-list\fB)\fR
.ad
.RS 19n
.rt
Optionally matches any one of the given patterns.
.RE

.sp
.ne 2
.mk
.na
\fB*(\fIpattern-list\fB)\fR
.ad
.RS 19n
.rt
Matches zero or more occurrences of the given patterns.
.RE

.sp
.ne 2
.mk
.na
\fB+(\fIpattern-list\fB)\fR
.ad
.RS 19n
.rt
Matches one or more occurrences of the given patterns.
.RE

.sp
.ne 2
.mk
.na
\fB@(\fIpattern-list\fB)\fR
.ad
.RS 19n
.rt
Matches exactly one of the given patterns.
.RE

.sp
.ne 2
.mk
.na
\fB!(\fIpattern-list\fB)\fR
.ad
.RS 19n
.rt
Matches anything, except one of the given patterns.
.RE

.SS "Quoting"
.sp
.LP
Each of the
.I metacharacters
listed above (see
.BR Definitions )
has a
special meaning to the shell and causes termination of a word unless quoted.
A character can be
.I quoted
(that is, made to stand for itself) by
preceding it with a \fB\e\|\fR\&. The pair \fB\e\|NEWLINE\fR is removed. All
characters enclosed between a pair of single quote marks (\fB\&' '\fR) are
quoted. A single quote cannot appear within single quotes. Inside double
quote marks (\fB""\fR), parameter and command substitution occur and
\fB\e\fR quotes the characters \fB\e\|\fR, \fB`\fR, \fB"\fR, and \fB$\fR.
The meaning of
.B $*
and
.B $@
is identical when not quoted or when
used as a parameter assignment value or as a file name. However, when used
as a command argument,
.B $*
is equivalent to
\fB``$1\fId\fB\|$2\fId\fB\&.\|.\|.'',\fR where
.I d
is the first
character of the
.B IFS
variable, whereas
.B $@
is equivalent to
\fB$1 $2\fR .\|.\|.. Inside grave quote marks
.RB ( `` ),
\fB\e\fR
quotes the characters \fB\e\fR, \fB\&'\fR, and
.BR $ .
If the grave quotes
occur within double quotes, then \fB\e\fR also quotes the character
\fB"\fR.
.sp
.LP
The special meaning of reserved words or aliases can be removed by quoting
any character of the reserved word. The recognition of function names or
special command names listed cannot be altered by quoting them.
.SS "Arithmetic Evaluation"
.sp
.LP
An ability to perform integer arithmetic is provided with the special
command
.BR let .
Evaluations are performed using
.I long
arithmetic.
Constants are of the form [ \fIbase\fB#\fR ] \fIn\fR where
.I base
is
a decimal number between two and thirty-six representing the arithmetic base
and
.I n
is a number in that base. If
.I base
is omitted then base 10
is used.
.sp
.LP
An arithmetic expression uses the same syntax, precedence, and
associativity of expression as the C language. All the integral operators,
other than
.BR ++ ,
.BR -; ,
.BR ?: ,
and
.B ,
are supported.
Variables can be referenced by name within an arithmetic expression without
using the parameter substitution syntax. When a variable is referenced, its
value is evaluated as an arithmetic expression.
.sp
.LP
An internal integer representation of a
.I variable
can be specified
with the
.B -i
option of the
.B typeset
special command. Arithmetic
evaluation is performed on the value of each assignment to a variable with
the
.B -i
attribute. If you do not specify an arithmetic base, the first
assignment to the variable determines the arithmetic base. This base is used
when parameter substitution occurs.
.sp
.LP
Since many of the arithmetic operators require quoting, an alternative form
of the
.B let
command is provided. For any command which begins with a
.BR (( ,
all the characters until a matching
.B ))
are treated as a
quoted expression. More precisely, \fB((\fR.\|.\|.\fB))\fR is equivalent to
\fBlet "\fR\|.\|.\|.\fB"\fR.
.SS "Prompting"
.sp
.LP
When used interactively, the shell prompts with the parameter expanded
value of
.B PS1
before reading a command. If at any time a new-line is
typed and further input is needed to complete a command, then the secondary
prompt (that is, the value of
.BR PS2 )
is issued.
.SS "Conditional Expressions"
.sp
.LP
A
.IR "conditional expression" " is used with the "
.B [[
compound command
to test attributes of files and to compare strings. Word splitting and file
name generation are not performed on the words between
.B [[
and
.BR ]] .
Each expression can be constructed from one or more of the
following unary or binary expressions:
.sp
.ne 2
.mk
.na
.BI -a " file"
.ad
.RS 21n
.rt
True, if
.I file
exists.
.RE

.sp
.ne 2
.mk
.na
.BI -b " file"
.ad
.RS 21n
.rt
True, if
.I file
exists and is a block special file.
.RE

.sp
.ne 2
.mk
.na
.BI -c " file"
.ad
.RS 21n
.rt
True, if
.I file
exists and is a character special file.
.RE

.sp
.ne 2
.mk
.na
.BI -d " file"
.ad
.RS 21n
.rt
True, if
.I file
exists and is a directory.
.RE

.sp
.ne 2
.mk
.na
.BI -e " file"
.ad
.RS 21n
.rt
True, if
.I file
exists.
.RE

.sp
.ne 2
.mk
.na
.BI -f " file"
.ad
.RS 21n
.rt
True, if
.I file
exists and is an ordinary file.
.RE

.sp
.ne 2
.mk
.na
.BI -g " file"
.ad
.RS 21n
.rt
True, if
.I file
exists and has its setgid bit set.
.RE

.sp
.ne 2
.mk
.na
.BI -h " file"
.ad
.RS 21n
.rt
True, if
.I file
exists and is a symbolic link.
.RE

.sp
.ne 2
.mk
.na
.BI -k " file"
.ad
.RS 21n
.rt
True, if
.I file
exists and has its sticky bit set.
.RE

.sp
.ne 2
.mk
.na
.BI -n " string"
.ad
.RS 21n
.rt
True, if length of
.I string
is non-zero.
.RE

.sp
.ne 2
.mk
.na
.BI -o " option"
.ad
.RS 21n
.rt
True, if option named
.I option
is on.
.RE

.sp
.ne 2
.mk
.na
.BI -p " file"
.ad
.RS 21n
.rt
True, if
.I file
exists and is a fifo special file or a pipe.
.RE

.sp
.ne 2
.mk
.na
.BI -r " file"
.ad
.RS 21n
.rt
True, if
.I file
exists and is readable by current process.
.RE

.sp
.ne 2
.mk
.na
.BI -s " file"
.ad
.RS 21n
.rt
True, if
.I file
exists and has size greater than zero.
.RE

.sp
.ne 2
.mk
.na
.BI -t " fildes"
.ad
.RS 21n
.rt
True, if file descriptor number
.I fildes
is open and associated with a
terminal device.
.RE

.sp
.ne 2
.mk
.na
.BI -u " file"
.ad
.RS 21n
.rt
True, if
.I file
exists and has its setuid bit set.
.RE

.sp
.ne 2
.mk
.na
.BI -w " file"
.ad
.RS 21n
.rt
True, if
.I file
exists and is writable by current process.
.RE

.sp
.ne 2
.mk
.na
.BI -x " file"
.ad
.RS 21n
.rt
True, if
.I file
exists and is executable by current process. If
\fIfile\fR exists and is a directory, then the current process has
permission to search in the directory.
.RE

.sp
.ne 2
.mk
.na
.BI -z " string"
.ad
.RS 21n
.rt
True, if length of
.I string
is zero.
.RE

.sp
.ne 2
.mk
.na
.BI -L " file"
.ad
.RS 21n
.rt
True, if
.I file
exists and is a symbolic link.
.RE

.sp
.ne 2
.mk
.na
.BI -O " file"
.ad
.RS 21n
.rt
True, if
.I file
exists and is owned by the effective user id of this
process.
.RE

.sp
.ne 2
.mk
.na
.BI -G " file"
.ad
.RS 21n
.rt
True, if
.I file
exists and its group matches the effective group id of
this process.
.RE

.sp
.ne 2
.mk
.na
.BI -S " file"
.ad
.RS 21n
.rt
True, if
.I file
exists and is a socket.
.RE

.sp
.ne 2
.mk
.na
\fIfile1\fR
.B -nt
\fIfile2\fR
.ad
.RS 21n
.rt
.RI "True, if " file1 " exists and is newer than " file2 .
.RE

.sp
.ne 2
.mk
.na
\fIfile1\fR
.B -ot
\fIfile2\fR
.ad
.RS 21n
.rt
.RI "True, if " file1 " exists and is older than " file2 .
.RE

.sp
.ne 2
.mk
.na
\fIfile1\fR
.B -ef
\fIfile2\fR
.ad
.RS 21n
.rt
True, if
.IR file1 " and "
.I file2
exist and refer to the same file.
.RE

.sp
.ne 2
.mk
.na
.I string
.ad
.RS 21n
.rt
True if the string
.I string
is not the null string.
.RE

.sp
.ne 2
.mk
.na
.I string
.B =
.I pattern
.ad
.RS 21n
.rt
True, if
.I string
matches
.IR pattern .
.RE

.sp
.ne 2
.mk
.na
.I string
.B !=
.I pattern
.ad
.RS 21n
.rt
True, if
.I string
does not match
.IR pattern .
.RE

.sp
.ne 2
.mk
.na
.I string1
.B <
.I string2
.ad
.RS 21n
.rt
True, if
.I string1
comes before
.I string2
based on strings
interpreted as appropriate to the locale setting for category
.BR LC_COLLATE .
.RE

.sp
.ne 2
.mk
.na
.I string1
.B >
.I string2
.ad
.RS 21n
.rt
True, if
.I string1
comes after
.I string2
based on strings
interpreted as appropriate to the locale setting for category
.BR LC_COLLATE .
.RE

.sp
.ne 2
.mk
.na
.I exp1
.B -eq
.I exp2
.ad
.RS 21n
.rt
True, if
.I exp1
is equal to
.IR exp2 .
.RE

.sp
.ne 2
.mk
.na
.I exp1
.B -ne
.I exp2
.ad
.RS 21n
.rt
True, if
.I exp1
is not equal to
.IR exp2 .
.RE

.sp
.ne 2
.mk
.na
.I exp1
.B -lt
.I exp2
.ad
.RS 21n
.rt
True, if
.I exp1
is less than
.IR exp2 .
.RE

.sp
.ne 2
.mk
.na
.I exp1
.B -gt
.I exp2
.ad
.RS 21n
.rt
True, if
.I exp1
is greater than
.IR exp2 .
.RE

.sp
.ne 2
.mk
.na
.I exp1
.B -le
.I exp2
.ad
.RS 21n
.rt
True, if
.I exp1
is less than or equal to
.IR exp2 .
.RE

.sp
.ne 2
.mk
.na
.I exp1
.B -ge
.I exp2
.ad
.RS 21n
.rt
True, if
.I exp1
is greater than or equal to
.IR exp2 .
.RE

.sp
.LP
In each of the above expressions, if
.I file
is of the form
\fB/dev/fd/\fIn\fR, where
.I n
is an integer, then the test is applied
to the open file whose descriptor number is
.IR n .
.sp
.LP
A compound expression can be constructed from these primitives by using any
of the following, listed in decreasing order of precedence.
.sp
.ne 2
.mk
.na
\fB(\fIexpression\fB)\fR
.ad
.RS 30n
.rt
True, if
.I expression
is true. Used to group expressions.
.RE

.sp
.ne 2
.mk
.na
.BI ! " expression"
.ad
.RS 30n
.rt
True if
.I expression
is false.
.RE

.sp
.ne 2
.mk
.na
.I expression1
.B &&
.I expression2
.ad
.RS 30n
.rt
True, if
.I expression1
and
.I expression2
are both true.
.RE

.sp
.ne 2
.mk
.na
.I expression1
.B ||
.I expression2
.ad
.RS 30n
.rt
True, if either
.I expression1
or
.I expression2
is true.
.RE

.SS "Input/Output"
.sp
.LP
Before a command is executed, its input and output can be redirected using
a special notation interpreted by the shell. The following can appear
anywhere in a simple-command or can precede or follow a
.I command
and
are
.I not
passed on to the invoked command. Command and parameter
substitution occur before
.I word
or
.I digit
is used except as noted.
File name generation occurs only if the pattern matches a single file, and
blank interpretation is not performed.
.sp
.ne 2
.mk
.na
.BI < word
.ad
.RS 14n
.rt
Use file
.I word
as standard input (file descriptor 0).
.RE

.sp
.ne 2
.mk
.na
.BI > word
.ad
.RS 14n
.rt
Use file
.I word
as standard output (file descriptor 1). If the file
does not exist then it is created. If the file exists, and the
\fB-noclobber\fR option is on, this causes an error; otherwise, it is
truncated to zero length.
.RE

.sp
.ne 2
.mk
.na
.BI >| word
.ad
.RS 14n
.rt
Sames as
.BR > ,
except that it overrides the
.B -noclobber
option.
.RE

.sp
.ne 2
.mk
.na
.BI >> word
.ad
.RS 14n
.rt
Use file
.I word
as standard output. If the file exists, output is
appended to it (by first seeking to the
.BR EOF ).
Otherwise, the file is
created.
.RE

.sp
.ne 2
.mk
.na
.BI <> word
.ad
.RS 14n
.rt
Open file
.I word
for reading and writing as standard input.
.RE

.sp
.ne 2
.mk
.na
\fB<< [-\fB]\fIword\fR
.ad
.RS 14n
.rt
The shell input is read up to a line that is the same as
.IR word ,
or to
an
.BR EOF .
No parameter substitution, command substitution, or file name
generation is performed on
.IR word .
The resulting document, called a
.IR here-document ,
becomes the standard input. If any character of
\fIword\fR is quoted, no interpretation is placed upon the characters of the
document. Otherwise, parameter and command substitution occur,
\fB\e\fINEWLINE\fR is ignored, and \fB\e\fR must be used to quote the
characters \fB\e\|\fR,
.BR $ ,
.BR ` ,
and the first character of
.IR word .
If
.B \(mi
is appended to
.BR << ,
then all leading tabs are
stripped from
.I word
and from the document.
.RE

.sp
.ne 2
.mk
.na
.BI <& digit
.ad
.RS 14n
.rt
The standard input is duplicated from file descriptor
.I digit
(see
.BR dup (2)).
Similarly for the standard output using
.BR >&\fIdigit .
.RE

.sp
.ne 2
.mk
.na
\fB<&\(mi\fR
.ad
.RS 14n
.rt
The standard input is closed. Similarly for the standard output using
.BR >&\(mi .
.RE

.sp
.ne 2
.mk
.na
.B <&p
.ad
.RS 14n
.rt
The input from the co-process is moved to standard input.
.RE

.sp
.ne 2
.mk
.na
.B >&p
.ad
.RS 14n
.rt
The output to the co-process is moved to standard output.
.RE

.sp
.LP
If one of the above is preceded by a digit, then the file descriptor number
referred to is that specified by the digit (instead of the default 0 or 1).
For example:
.sp
.in +2
.nf
\&.\|.\|. 2>&1
.fi
.in -2
.sp

.sp
.LP
means file descriptor 2 is to be opened for writing as a duplicate of file
descriptor 1.
.sp
.LP
The order in which redirections are specified is significant. The shell
evaluates each redirection in terms of the
.RI ( "file descriptor" ,
.IR file )
association at the time of evaluation. For example:
.sp
.in +2
.nf
\&.\|.\|. 1>\fIfname\fR 2>&1
.fi
.in -2
.sp

.sp
.LP
first associates file descriptor 1 with file
.IR fname .
It then
associates file descriptor 2 with the file associated with file descriptor 1
(that is,
.IR fname ).
If the order of redirections were reversed, file
descriptor 2 would be associated with the terminal (assuming file descriptor
1 had been) and then file descriptor 1 would be associated with file
.IR fname .
.sp
.LP
If a command is followed by
.B &
and job control is not active, then the
default standard input for the command is the empty file
.BR /dev/null .
Otherwise, the environment for the execution of a command contains the file
descriptors of the invoking shell as modified by input/output
specifications.
.SS "Environment"
.sp
.LP
The
.I environment
(see
.BR environ (5))
is a list of name-value pairs
that is passed to an executed program in the same way as a normal argument
list. The names must be
.I identifiers
and the values are character
strings. The shell interacts with the environment in several ways. On
invocation, the shell scans the environment and creates a variable for each
name found, giving it the corresponding value and marking it
.IR export .
Executed commands inherit the environment. If the user modifies the values
of these variables or creates new ones, using the
.B export
or
\fBtypeset -x\fR commands, they become part of the environment. The
environment seen by any executed command is thus composed of any name-value
pairs originally inherited by the shell, whose values can be modified by the
current shell, plus any additions which must be noted in
.B export
or
\fBtypeset -x\fR commands.
.sp
.LP
The environment for any
.I simple-command
or
.I function
can be
augmented by prefixing it with one or more variable assignments. A variable
assignment argument is a word of the form
.IR identifier=value .
Thus:
.sp
.in +2
.nf
\fBTERM=450 \fIcmd args\fR
.fi
.in -2
.sp

.sp
.LP
and
.sp
.in +2
.nf
\fB(export TERM; TERM=450; \fIcmd args)\fR
.fi
.in -2
.sp

.sp
.LP
are equivalent (as far as the above execution of
.I cmd
is concerned,
except for special commands listed that are preceded with an asterisk).
.sp
.LP
If the
.B -k
flag is set,
.I all
variable assignment arguments are
placed in the environment, even if they occur after the command name. The
following first prints
.B "a=b c"
and then
.BR c :
.sp
.in +2
.nf
echo a=b c
set \(mik echo
a=b c
.fi
.in -2
.sp

.sp
.LP
This feature is intended for use with scripts written for early versions of
the shell and its use in new scripts is strongly discouraged. It is likely
to disappear someday.
.SS "Functions"
.sp
.LP
The
.B function
reserved word, described in the
.B Commands
section
above, is used to define shell functions. Shell functions are read in and
stored internally. Alias names are resolved when the function is read.
Functions are executed like commands with the arguments passed as positional
parameters. See
.BR Execution .
.sp
.LP
Functions execute in the same process as the caller and share all files and
present working directory with the caller. Traps caught by the caller are
reset to their default action inside the function. A trap condition that is
not caught or ignored by the function causes the function to terminate and
the condition to be passed on to the caller.
.sp
.LP
A trap on
.B EXIT
set inside a function is executed after the function
completes in the environment of the caller. This is true only for
non-POSIX-style functions, that is, functions declared as
.sp
.in +2
.nf
function func
.fi
.in -2

.sp
.LP
as opposed to POSIX-style functions, declared as
.sp
.in +2
.nf
func()
.fi
.in -2

.sp
.LP
Ordinarily, variables are shared between the calling program and the
function. However, the
.B typeset
special command used within a function
defines local variables whose scope includes the current function and all
functions it calls.
.sp
.LP
The special command
.B return
is used to return from function calls.
Errors within functions return control to the caller.
.sp
.LP
The names of all functions can be listed with
.BR typeset-f .
\fBtypeset -f\fR lists all function names as well as the text of all
functions.
.BR "typeset -f" " "
.I function-names
lists the text of the
named functions only. Functions can be undefined with the
.B -f
option of
the
.B unset
special command.
.sp
.LP
Ordinarily, functions are
.B unset
when the shell executes a shell
script. The
.BR -xf " option of the "
.B typeset
command allows a function
to be exported to scripts that are executed without a separate invocation of
the shell. Functions that need to be defined across separate invocations of
the shell should be specified in the
.B ENV
file with the
.B -xf
option of
.BR typeset .
.SS "Function Definition Command"
.sp
.LP
A function is a user-defined name that is used as a simple command to call
a compound command with new positional parameters. A function is defined
with a
.IR "function definition command" .
.sp
.LP
The format of a function definition command is as follows:
.sp
.in +2
.nf
\fBfname()\fR \fIcompound-command\fR[\fIio-redirect\fR .\|.\|.]
.fi
.in -2
.sp

.sp
.LP
The function is named
.BR fname ;
it must be a name. An implementation can
allow other characters in a function name as an extension. The
implementation maintains separate name spaces for functions and variables.
.sp
.LP
The
.B ()
in the function definition command consists of two operators.
Therefore, intermixing blank characters with the
.BR fname ,
.BR ( ,
and
\fB)\fR is allowed, but unnecessary.
.sp
.LP
The argument
.I compound-command
represents a compound command.
.sp
.LP
When the function is declared, none of the expansions in
.B wordexp
is
performed on the text in
.I compound-command
or
.IR io-redirect ;
all
expansions is performed as normal each time the function is called.
Similarly, the optional
.I io-redirect
redirections and any variable
assignments within
.I compound-command
is performed during the execution
of the function itself, not the function definition.
.sp
.LP
When a function is executed, it has the syntax-error and
variable-assignment properties described for the special built-in
utilities.
.sp
.LP
The
.I compound-command
is executed whenever the function name is
specified as the name of a simple command The operands to the command
temporarily becomes the positional parameters during the execution of the
.IR compound-command ;
the special parameter
.B #
is also changed to
reflect the number of operands. The special parameter
.B 0
is unchanged.
When the function completes, the values of the positional parameters and the
special parameter
.B #
is restored to the values they had before the
function was executed. If the special built-in
.B return
is executed in
the
.IR compound-command ,
the function completes and execution resumes
with the next command after the function call.
.sp
.LP
An example of how a function definition can be used wherever a simple
command is allowed:
.sp
.in +2
.nf
\fB# If variable i is equal to "yes",
# define function foo to be ls \(mil
#
[ "$i" = yes ] && foo() {
      ls \(mil
}\fR
.fi
.in -2
.sp

.sp
.LP
The exit status of a function definition is
.B 0
if the function was
declared successfully; otherwise, it is greater than zero. The exit status
of a function invocation is the exit status of the last command executed by
the function.
.SS "Jobs"
.sp
.LP
If the
.B monitor
option of the
.B set
command is turned on, an
interactive shell associates a
.B job
with each pipeline. It keeps a
table of current jobs, printed by the
.B jobs
command, and assigns them
small integer numbers. When a job is started asynchronously with
.BR & ,
the shell prints a line which looks like:
.sp
.in +2
.nf
[1] 1234
.fi
.in -2
.sp

.sp
.LP
indicating that the
.BR job ,
which was started asynchronously, was job
number
.B 1
and had one (top-level) process, whose process id was
.BR 1234 .
.sp
.LP
If you are running a job and wish to do something else you can press the
key
.B ^Z
(Control-Z) which sends a
.B STOP
signal to the current job.
The shell normally indicates that the job has been
.BR `Stopped' ,
and
print another prompt. You can then manipulate the state of this job, putting
it in the background with the
.B bg
command, or run some other commands
and then eventually bring the job back into the foreground with the
foreground command
.BR fg .
A
.B ^Z
takes effect immediately and is like
an interrupt in that pending output and unread input are discarded when it
is typed.
.sp
.LP
A job being run in the background stops if it tries to read from the
terminal. Background jobs are normally allowed to produce output, but this
can be disabled by giving the command \fB"stty tostop"\fR\&. If you set this
tty option, then background jobs stop when they try to produce output as
they do when they try to read input.
.sp
.LP
There are several ways to refer to
.BR job "s in the shell. A"
.B job
can
be referred to by the process id of any process of the
.B job
or by one
of the following:
.sp
.ne 2
.mk
.na
.BI % number
.ad
.RS 12n
.rt
The job with the given number.
.RE

.sp
.ne 2
.mk
.na
.BI % string
.ad
.RS 12n
.rt
Any job whose command line begins with
.IR string .
.RE

.sp
.ne 2
.mk
.na
.BI %? string
.ad
.RS 12n
.rt
Any job whose command line contains
.IR string .
.RE

.sp
.ne 2
.mk
.na
.B %%
.ad
.RS 12n
.rt
Current job.
.RE

.sp
.ne 2
.mk
.na
.B %+
.ad
.RS 12n
.rt
Equivalent to
.BR %% .
.RE

.sp
.ne 2
.mk
.na
\fB%\(mi\fR
.ad
.RS 12n
.rt
Previous job.
.RE

.sp
.LP
The shell learns immediately whenever a process changes state. It normally
informs you whenever a job becomes blocked so that no further progress is
possible, but only just before it prints a prompt. This is done so that it
does not otherwise disturb your work.
.sp
.LP
When the monitor mode is on, each background job that completes triggers
any trap set for
.BR CHLD .
.sp
.LP
When you try to leave the shell while jobs are running or stopped, you are
warned with the message,
.B "`You have stopped(running) jobs.'"
You can use
the
.B jobs
command to see what they are. If you do this or immediately
try to exit again, the shell does not warn you a second time, and the
stopped jobs is terminated. If you have jobs running for which the
\fBnohup\fR command was invoked and attempt to logout, you are warned with
the message:
.sp
.LP
.B You have jobs running.
.sp
.LP
You need to logout a second time to actually logout. However, your
background jobs continue to run.
.SS "Signals"
.sp
.LP
The
.B INT
and
.B QUIT
signals for an invoked command are ignored if
the command is followed by
.B &
and the
.B -monitor
option is not
active. Otherwise, signals have the values inherited by the shell from its
parent. See the
.B trap
special command section.
.SS "Execution"
.sp
.LP
Each time a command is executed, the above substitutions are carried out.
If the command name matches one of the
.B "Special Commands"
listed, it is
executed within the current shell process. Next, the command name is checked
to see if it matches one of the user defined functions. If it does, the
positional parameters are saved and then reset to the arguments of the
\fBfunction\fR call. When the
.B function
completes or issues a
.BR return ,
the positional parameter list is restored and any trap set on
\fBEXIT\fR within the function is executed. The value of a
.B function
is
the value of the last command executed. A function is also executed in the
current shell process. If a command name is not a
.B "special command"
or a
user defined
.BR function ,
a process is created and an attempt is made to
execute the command using
.BR exec (2).
.sp
.LP
The shell variable
.B PATH
defines the search path for the directory
containing the command. Alternative directory names are separated by a colon
(\fB:\fR). The default path is
.B /bin:/usr/bin:
(specifying \fB/bin\fR,
.BR /usr/bin ,
and the current directory in that order). The current
directory can be specified by two or more adjacent colons, or by a colon at
the beginning or end of the path list. If the command name contains a
\fB/\fR then the search path is not used. Otherwise, each directory in the
path is searched for an executable file. If the file has execute permission
but is not a directory or an
.B a.out
file, it is assumed to be a file
containing shell commands. A sub-shell is spawned to read it. All
non-exported aliases, functions, and variables are removed in this case. A
parenthesized command is executed in a sub-shell without removing
non-exported quantities.
.SS "Command Re-entry"
.sp
.LP
The text of the last
.B HISTSIZE
(default 128) commands entered from a
terminal device is saved in a
.B history
file. The file
\fB$HOME/.sh_history\fR is used if the
.B HISTFILE
variable is not set or
if the file it names is not writable. A shell can access the commands of all
\fIinteractive\fR shells which use the same named
.BR HISTFILE .
The
special command
.B fc
is used to list or edit a portion of this file. The
portion of the file to be edited or listed can be selected by number or by
giving the first character or characters of the command. A single command or
range of commands can be specified. If you do not specify an editor program
as an argument to
.B fc
then the value of the variable
.B FCEDIT
is
used. If
.B FCEDIT
is not defined, then
.B /bin/ed
is used. The edited
command(s) is printed and re-executed upon leaving the editor. The editor
name
.B \(mi
is used to skip the editing phase and to re-execute the
command. In this case a substitution parameter of the form
\fIold\fB=\fInew\fR can be used to modify the command before
execution. For example, if
.B r
is aliased to \fB\&'fc\fR \fB-e\fR
\fB-\&'\fR then typing \fB\&'r bad=good c'\fR re-executes the
most recent command which starts with the letter
.BR c ,
replacing the
first occurrence of the string
.B bad
with the string
.BR good .
.SS "In-line Editing Option"
.sp
.LP
Normally, each command line entered from a terminal device is simply typed
followed by a new-line (RETURN or LINEFEED). If either the
.BR emacs ,
.BR gmacs ,
or
.B vi
option is active, the user can edit the command
line. To be in either of these edit modes
.B set
the corresponding
option. An editing option is automatically selected each time the
\fBVISUAL\fR or
.B EDITOR
variable is assigned a value ending in either
of these option names.
.sp
.LP
The editing features require that the user's terminal accept
.B RETURN
as carriage return without line feed and that a space must overwrite the
current character on the screen.
.sp
.LP
The editing modes implement a concept where the user is looking through a
window at the current line. The window width is the value of
.B COLUMNS
if it is defined, otherwise 80. If the window width is too small to display
the prompt and leave at least 8 columns to enter input, the prompt is
truncated from the left. If the line is longer than the window width minus
two, a mark is displayed at the end of the window to notify the user. As the
cursor moves and reaches the window boundaries the window are centered about
the cursor. The mark is a
.B >
if the line extends on the right side of
the window,
.B <
if the line extends on the left, and
.B *
if the line
extends on both sides of the window.
.sp
.LP
The search commands in each edit mode provide access to the history file.
Only strings are matched, not patterns, although a leading caret
.RB ( ^ )
in the string restricts the match to begin at the first character in the
line.
.SS "emacs Editing Mode"
.sp
.LP
This mode is entered by enabling either the
.B emacs
or
.BR gmacs
option. The only difference between these two modes is the way they handle
.BR ^T .
To edit, move the cursor to the point needing correction and then
insert or delete characters or words as needed. All the editing commands are
control characters or escape sequences. The notation for control characters
is caret (
.B ^
) followed by the character. For example,
.B ^F
is the
notation for control
.BR F .
This is entered by depressing `f' while
holding down the CTRL (control) key. The SHIFT key is
.I not
depressed.
(The notation
.B ^?
indicates the DEL (delete) key.)
.sp
.LP
The notation for escape sequences is
.B M-
followed by a character. For
example,
.B M-f
(pronounced Meta f) is entered by depressing ESC (ascii
.BR 033 )
followed by `f'. (\fBM-F\fR would be the notation for ESC
followed by SHIFT (capital) `F'.)
.sp
.LP
All edit commands operate from any place on the line (not just at the
beginning). Neither the RETURN nor the LINEFEED key is entered after edit
commands except when noted.
.sp
.ne 2
.mk
.na
.B ^F
.ad
.RS 13n
.rt
Move cursor forward (right) one character.
.RE

.sp
.ne 2
.mk
.na
.B M-f
.ad
.RS 13n
.rt
Move cursor forward one word. (The
.B emacs
editor's idea of a word is a
string of characters consisting of only letters, digits and underscores.)
.RE

.sp
.ne 2
.mk
.na
.B ^B
.ad
.RS 13n
.rt
Move cursor backward (left) one character.
.RE

.sp
.ne 2
.mk
.na
.B M-b
.ad
.RS 13n
.rt
Move cursor backward one word.
.RE

.sp
.ne 2
.mk
.na
.B ^A
.ad
.RS 13n
.rt
Move cursor to start of line.
.RE

.sp
.ne 2
.mk
.na
.B ^E
.ad
.RS 13n
.rt
Move cursor to end of line.
.RE

.sp
.ne 2
.mk
.na
.BI ^] char
.ad
.RS 13n
.rt
Move cursor forward to character
.I char
on current line.
.RE

.sp
.ne 2
.mk
.na
.BI M-^] char
.ad
.RS 13n
.rt
Move cursor backward to character
.I char
on current line.
.RE

.sp
.ne 2
.mk
.na
.B ^X^X
.ad
.RS 13n
.rt
Interchange the cursor and mark.
.RE

.sp
.ne 2
.mk
.na
.I erase
.ad
.RS 13n
.rt
(User defined erase character as defined by the
.BR stty (1)
command,
usually
.B ^H
or
.BR # .)
Delete previous character.
.RE

.sp
.ne 2
.mk
.na
.B ^D
.ad
.RS 13n
.rt
Delete current character.
.RE

.sp
.ne 2
.mk
.na
.B M-d
.ad
.RS 13n
.rt
Delete current word.
.RE

.sp
.ne 2
.mk
.na
.B M-^H
.ad
.RS 13n
.rt
(Meta-backspace) Delete previous word.
.RE

.sp
.ne 2
.mk
.na
.B M-h
.ad
.RS 13n
.rt
Delete previous word.
.RE

.sp
.ne 2
.mk
.na
.B M-^?
.ad
.RS 13n
.rt
(Meta-DEL) Delete previous word (if your interrupt character is
.B ^?
(DEL, the default) then this command does not work).
.RE

.sp
.ne 2
.mk
.na
.B ^T
.ad
.RS 13n
.rt
Transpose current character with next character in
.B emacs
mode.
Transpose two previous characters in
.B gmacs
mode.
.RE

.sp
.ne 2
.mk
.na
.B ^C
.ad
.RS 13n
.rt
Capitalize current character.
.RE

.sp
.ne 2
.mk
.na
.B M-c
.ad
.RS 13n
.rt
Capitalize current word.
.RE

.sp
.ne 2
.mk
.na
.B M-l
.ad
.RS 13n
.rt
Change the current word to lower case.
.RE

.sp
.ne 2
.mk
.na
.B ^K
.ad
.RS 13n
.rt
Delete from the cursor to the end of the line. If preceded by a numerical
parameter whose value is less than the current cursor position, then delete
from given position up to the cursor. If preceded by a numerical parameter
whose value is greater than the current cursor position, then delete from
cursor up to given cursor position.
.RE

.sp
.ne 2
.mk
.na
.B ^W
.ad
.RS 13n
.rt
Kill from the cursor to the mark.
.RE

.sp
.ne 2
.mk
.na
.B M-p
.ad
.RS 13n
.rt
Push the region from the cursor to the mark on the stack.
.RE

.sp
.ne 2
.mk
.na
.I kill
.ad
.RS 13n
.rt
(User defined kill character as defined by the
.BR stty (1)
command,
usually
.B ^G
or
.BR @ .)
Kill the entire current line. If two
\fIkill\fR characters are entered in succession, all kill characters from
then on cause a line feed (useful when using paper terminals).
.RE

.sp
.ne 2
.mk
.na
.B ^Y
.ad
.RS 13n
.rt
Restore last item removed from line. (Yank item back to the line.)
.RE

.sp
.ne 2
.mk
.na
.B ^L
.ad
.RS 13n
.rt
Line feed and print current line.
.RE

.sp
.ne 2
.mk
.na
.B ^@
.ad
.RS 13n
.rt
(null character) Set mark.
.RE

.sp
.ne 2
.mk
.na
.BI M- space
.ad
.RS 13n
.rt
(Meta space) Set mark.
.RE

.sp
.ne 2
.mk
.na
.B J
.ad
.RS 13n
.rt
(New line) Execute the current line.
.RE

.sp
.ne 2
.mk
.na
.B M
.ad
.RS 13n
.rt
(Return) Execute the current line.
.RE

.sp
.ne 2
.mk
.na
.I eof
.ad
.RS 13n
.rt
End-of-file character, normally
.BR ^D ,
is processed as an End-of-file
only if the current line is null.
.RE

.sp
.ne 2
.mk
.na
.B ^P
.ad
.RS 13n
.rt
Fetch previous command. Each time
.B ^P
is entered the previous command
back in time is accessed. Moves back one line when not on the first line of
a multi-line command.
.RE

.sp
.ne 2
.mk
.na
.B M-<
.ad
.RS 13n
.rt
Fetch the least recent (oldest) history line.
.RE

.sp
.ne 2
.mk
.na
.B M->
.ad
.RS 13n
.rt
Fetch the most recent (youngest) history line.
.RE

.sp
.ne 2
.mk
.na
.B ^N
.ad
.RS 13n
.rt
Fetch next command line. Each time
.B ^N
is entered the next command
line forward in time is accessed.
.RE

.sp
.ne 2
.mk
.na
.BI ^R string
.ad
.RS 13n
.rt
Reverse search history for a previous command line containing
.IR string .
If a parameter of zero is given, the search is forward.
.I string
is
terminated by a RETURN or NEW LINE. If string is preceded by a
.BR ^ ,
the
matched line must begin with
.IR string .
If
.I string
is omitted, then
the next command line containing the most recent
.I string
is accessed.
In this case a parameter of zero reverses the direction of the search.
.RE

.sp
.ne 2
.mk
.na
.B ^O
.ad
.RS 13n
.rt
Operate. Execute the current line and fetch the next line relative to
current line from the history file.
.RE

.sp
.ne 2
.mk
.na
.BI M- digits
.ad
.RS 13n
.rt
(Escape) Define numeric parameter, the digits are taken as a parameter to
the next command. The commands that accept a parameter are
.BR ^F ,
.BR ^B ,
.IR erase ,
.BR ^C ,
.BR ^D ,
.BR ^K ,
.BR ^R ,
.BR ^P ,
.BR ^N ,
.BR ^] ,
.BR M-. ,
.BR M-^] ,
.BR M-_ ,
.BR M-b ,
.BR M-c ,
.BR M-d ,
.BR M-f ,
.BR M-h ,
\fBM-l\fR and \fBM-^H\fR.
.RE

.sp
.ne 2
.mk
.na
.BI M- letter
.ad
.RS 13n
.rt
Soft-key. Your alias list is searched for an alias by the name
.BI _ letter
and if an alias of this name is defined, its value is
inserted on the input queue. The
.I letter
must not be one of the above
meta-functions.
.RE

.sp
.ne 2
.mk
.na
.BI M-[ letter
.ad
.RS 13n
.rt
Soft-key. Your alias list is searched for an alias by the name
.BI __ letter
and if an alias of this name is defined, its value is
inserted on the input queue. The can be used to program functions keys on
many terminals.
.RE

.sp
.ne 2
.mk
.na
\fBM\(mi.\fR
.ad
.RS 13n
.rt
The last word of the previous command is inserted on the line. If preceded
by a numeric parameter, the value of this parameter determines which word to
insert rather than the last word.
.RE

.sp
.ne 2
.mk
.na
\fBM\(mi_\fR
.ad
.RS 13n
.rt
Same as \fBM\(mi.\fR.
.RE

.sp
.ne 2
.mk
.na
\fBM\(mi*\fR
.ad
.RS 13n
.rt
An asterisk is appended to the end of the word and a file name expansion is
attempted.
.RE

.sp
.ne 2
.mk
.na
\fBM\(miESC\fR
.ad
.RS 13n
.rt
File name completion. Replaces the current word with the longest common
prefix of all filenames matching the current word with an asterisk appended.
If the match is unique, a
.B /
is appended if the file is a directory and
a space is appended if the file is not a directory.
.RE

.sp
.ne 2
.mk
.na
\fBM\(mi=\fR
.ad
.RS 13n
.rt
List files matching current word pattern if an asterisk were appended.
.RE

.sp
.ne 2
.mk
.na
.B ^U
.ad
.RS 13n
.rt
Multiply parameter of next command by 4.
.RE

.sp
.ne 2
.mk
.na
\fB\e\fR
.ad
.RS 13n
.rt
Escape next character. Editing characters, the user's erase, kill and
interrupt
.RB "(normally " ^? )
characters can be entered in a command line or
in a search string if preceded by a \fB\e\|\fR\&. The \fB\e\fR removes the
next character's editing features (if any).
.RE

.sp
.ne 2
.mk
.na
.B ^V
.ad
.RS 13n
.rt
Display version of the shell.
.RE

.sp
.ne 2
.mk
.na
.B M-#
.ad
.RS 13n
.rt
Insert a
.B #
at the beginning of the line and execute it. This causes a
comment to be inserted in the history file.
.RE

.SS "vi Editing Mode"
.sp
.LP
There are two typing modes. Initially, when you enter a command you are in
the
.I input
mode. To edit, enter
.I control
mode by typing
.BR ESC
.RB ( 033 )
and move the cursor to the point needing correction and then
insert or delete characters or words as needed. Most control commands accept
an optional repeat
.I count
prior to the command.
.sp
.LP
When in
.B vi
mode on most systems, canonical processing is initially
enabled and the command is echoed again if the speed is 1200 baud or greater
and it contains any control characters or less than one second has elapsed
since the prompt was printed. The ESC character terminates canonical
processing for the remainder of the command and the user can then modify the
command line. This scheme has the advantages of canonical processing with
the type-ahead echoing of raw mode.
.sp
.LP
If the option
.B viraw
is also set, the terminal always have canonical
processing disabled. This mode is implicit for systems that do not support
two alternate end of line delimiters, and can be helpful for certain
terminals.
.SS "Input Edit Commands"
.sp
.LP
By default the editor is in input mode.
.sp
.ne 2
.mk
.na
.I erase
.ad
.RS 9n
.rt
(User defined erase character as defined by the
.BR stty (1)
command,
usually
.B ^H
or
.BR # .)
Delete previous character.
.RE

.sp
.ne 2
.mk
.na
.B ^W
.ad
.RS 9n
.rt
Delete the previous blank separated word.
.RE

.sp
.ne 2
.mk
.na
.B ^D
.ad
.RS 9n
.rt
Terminate the shell.
.RE

.sp
.ne 2
.mk
.na
.B ^V
.ad
.RS 9n
.rt
Escape next character. Editing characters and the user's erase or kill
characters can be entered in a command line or in a search string if
preceded by a
.BR ^V .
The
.B ^V
removes the next character's editing
features (if any).
.RE

.sp
.ne 2
.mk
.na
\fB\e\fR
.ad
.RS 9n
.rt
Escape the next
.I erase
or
.I kill
character.
.RE

.SS "Motion Edit Commands"
.sp
.LP
The following commands move the cursor:
.sp
.ne 2
.mk
.na
\fB[\fIcount\fR]\fBl\fR
.ad
.RS 13n
.rt
Cursor forward (right) one character.
.RE

.sp
.ne 2
.mk
.na
\fB[\fIcount\fR]\fBw\fR
.ad
.RS 13n
.rt
Cursor forward one alpha-numeric word.
.RE

.sp
.ne 2
.mk
.na
\fB[\fIcount\fR]\fBW\fR
.ad
.RS 13n
.rt
Cursor to the beginning of the next word that follows a blank.
.RE

.sp
.ne 2
.mk
.na
\fB[\fIcount\fR]\fBe\fR
.ad
.RS 13n
.rt
Cursor to end of word.
.RE

.sp
.ne 2
.mk
.na
\fB[\fIcount\fR]\fBE\fR
.ad
.RS 13n
.rt
Cursor to end of the current blank delimited word.
.RE

.sp
.ne 2
.mk
.na
\fB[\fIcount\fR]\fBh\fR
.ad
.RS 13n
.rt
Cursor backward (left) one character.
.RE

.sp
.ne 2
.mk
.na
\fB[\fIcount\fR]\fBb\fR
.ad
.RS 13n
.rt
Cursor backward one word.
.RE

.sp
.ne 2
.mk
.na
\fB[\fIcount\fR]\fBB\fR
.ad
.RS 13n
.rt
Cursor to preceding blank separated word.
.RE

.sp
.ne 2
.mk
.na
\fB[\fIcount\fR]\fB|\fR
.ad
.RS 13n
.rt
Cursor to column
.IR count .
.RE

.sp
.ne 2
.mk
.na
\fB[\fIcount\fR]\fBf\fIc\fR
.ad
.RS 13n
.rt
Find the next character
.I c
in the current line.
.RE

.sp
.ne 2
.mk
.na
\fB[\fIcount\fR]\fBF\fIc\fR
.ad
.RS 13n
.rt
Find the previous character
.I c
in the current line.
.RE

.sp
.ne 2
.mk
.na
\fB[\fIcount\fR]\fBt\fIc\fR
.ad
.RS 13n
.rt
.RB "Equivalent to " f " followed by " h .
.RE

.sp
.ne 2
.mk
.na
\fB[\fIcount\fR]\fBT\fIc\fR
.ad
.RS 13n
.rt
Equivalent to
.B F
followed by
.BR l .
.RE

.sp
.ne 2
.mk
.na
\fB[\fIcount\fR]\fB;\fR
.ad
.RS 13n
.rt
Repeats
.I count
times, the last single character find command,
.BR f ,
.BR F ,
.BR t ,
or
.BR T .
.RE

.sp
.ne 2
.mk
.na
\fB[\fIcount\fR]\fB,\fR
.ad
.RS 13n
.rt
Reverses the last single character find command
.I count
times.
.RE

.sp
.ne 2
.mk
.na
.B 0
.ad
.RS 13n
.rt
Cursor to start of line.
.RE

.sp
.ne 2
.mk
.na
.B ^
.ad
.RS 13n
.rt
Cursor to first non-blank character in line.
.RE

.sp
.ne 2
.mk
.na
.B $
.ad
.RS 13n
.rt
Cursor to end of line.
.RE

.sp
.ne 2
.mk
.na
.B %
.ad
.RS 13n
.rt
Moves to balancing
.BR ( ,
\fB)\fR, \fB{\fR, \fB}\fR, \fB[\fR, or \fB]\fR.
If cursor is not on one of the above characters, the remainder of the line
is searched for the first occurrence of one of the above characters first.
.RE

.SS "Search Edit Commands"
.sp
.LP
These commands access your command history.
.sp
.ne 2
.mk
.na
\fB[\fIcount\fR]\fBk\fR
.ad
.RS 15n
.rt
Fetch previous command. Each time
.B k
is entered the previous command
back in time is accessed.
.RE

.sp
.ne 2
.mk
.na
\fB[\fIcount\fR]\fB\(mi\fR
.ad
.RS 15n
.rt
Equivalent to
.BR k .
.RE

.sp
.ne 2
.mk
.na
\fB[\fIcount\fR]\fBj\fR
.ad
.RS 15n
.rt
Fetch next command. Each time
.B j
is entered, the next command forward
in time is accessed.
.RE

.sp
.ne 2
.mk
.na
\fB[\fIcount\fR]\fB+\fR
.ad
.RS 15n
.rt
Equivalent to
.BR j .
.RE

.sp
.ne 2
.mk
.na
\fB[\fIcount\fR]\fBG\fR
.ad
.RS 15n
.rt
The command number
.I count
is fetched. The default is the least recent
history command.
.RE

.sp
.ne 2
.mk
.na
.BI / string
.ad
.RS 15n
.rt
Search backward through history for a previous command containing
.IR string .
\fIstring\fR is terminated by a RETURN or NEWLINE. If
\fIstring\fR is preceded by a
.BR ^ ,
the matched line must begin with
.IR string .
If
.I string
is
.IR NULL ,
the previous string is used.
.RE

.sp
.ne 2
.mk
.na
.BI ? string
.ad
.RS 15n
.rt
Same as
.B /
except that search is in the forward direction.
.RE

.sp
.ne 2
.mk
.na
.B n
.ad
.RS 15n
.rt
Search for next match of the last pattern to
.B /
or
.B ?
commands.
.RE

.sp
.ne 2
.mk
.na
.B N
.ad
.RS 15n
.rt
Search for next match of the last pattern to
.B /
or
.BR ? ,
but in
reverse direction. Search history for the
.I string
entered by the
previous
.B /
command.
.RE

.SS "Text Modification Edit Commands"
.sp
.LP
These commands modifies the line.
.sp
.ne 2
.mk
.na
.B a
.ad
.RS 18n
.rt
Enter input mode and enter text after the current character.
.RE

.sp
.ne 2
.mk
.na
.B A
.ad
.RS 18n
.rt
Append text to the end of the line. Equivalent to
.BR $a .
.RE

.sp
.ne 2
.mk
.na
\fB[\fIcount\fR]\fBc\fImotion\fR
.ad
.br
.na
\fBc\fR[\fIcount\fR]\fImotion\fR
.ad
.RS 18n
.rt
Delete current character through the character that
.I motion
would move
the cursor to and enter input mode. If
.I motion
is
.BR c ,
the entire
line is deleted and input mode entered.
.RE

.sp
.ne 2
.mk
.na
.B C
.ad
.RS 18n
.rt
Delete the current character through the end of line and enter input mode.
Equivalent to
.BR c$ .
.RE

.sp
.ne 2
.mk
.na
\fB[\fIcount\fR]\fBs\fR
.ad
.RS 18n
.rt
Delete
.I count
characters and enter input mode.
.RE

.sp
.ne 2
.mk
.na
.B S
.ad
.RS 18n
.rt
Equivalent to
.BR cc .
.RE

.sp
.ne 2
.mk
.na
.B D
.ad
.RS 18n
.rt
Delete the current character through the end of line. Equivalent to
.BR d$ .
.RE

.sp
.ne 2
.mk
.na
\fB[\fIcount\fR]\fBd\fImotion\fR
.ad
.br
.na
\fBd\fR[\fIcount\fR]\fImotion\fR
.ad
.RS 18n
.rt
Delete current character through the character that
.I motion
would move
to. If
.I motion
is
.BR d ,
the entire line is deleted.
.RE

.sp
.ne 2
.mk
.na
.B i
.ad
.RS 18n
.rt
Enter input mode and insert text before the current character.
.RE

.sp
.ne 2
.mk
.na
.B I
.ad
.RS 18n
.rt
Insert text before the beginning of the line. Equivalent to
.BR 0i .
.RE

.sp
.ne 2
.mk
.na
\fB[\fIcount\fR]\fBP\fR
.ad
.RS 18n
.rt
Place the previous text modification before the cursor.
.RE

.sp
.ne 2
.mk
.na
\fB[\fIcount\fR]\fBp\fR
.ad
.RS 18n
.rt
Place the previous text modification after the cursor.
.RE

.sp
.ne 2
.mk
.na
.B R
.ad
.RS 18n
.rt
Enter input mode and replace characters on the screen with characters you
type overlay fashion.
.RE

.sp
.ne 2
.mk
.na
\fB[\fIcount\fR]\fBr\fIc\fR
.ad
.RS 18n
.rt
Replace the
.I count
character(s) starting at the current cursor
position with
.IR c ,
and advance the cursor.
.RE

.sp
.ne 2
.mk
.na
\fB[\fIcount\fR]\fBx\fR
.ad
.RS 18n
.rt
Delete current character.
.RE

.sp
.ne 2
.mk
.na
\fB[\fIcount\fR]\fBX\fR
.ad
.RS 18n
.rt
Delete preceding character.
.RE

.sp
.ne 2
.mk
.na
\fB[\fIcount\fR]\fB\&.\fR
.ad
.RS 18n
.rt
Repeat the previous text modification command.
.RE

.sp
.ne 2
.mk
.na
\fB[\fIcount\fR]\fB~\fR
.ad
.RS 18n
.rt
Invert the case of the
.I count
character(s) starting at the current
cursor position and advance the cursor.
.RE

.sp
.ne 2
.mk
.na
\fB[\fIcount\fR]\fB_\fR
.ad
.RS 18n
.rt
Causes the
.I count
word of the previous command to be appended and
input mode entered. The last word is used if
.I count
is omitted.
.RE

.sp
.ne 2
.mk
.na
.B *
.ad
.RS 18n
.rt
Causes an
.B *
to be appended to the current word and file name
generation attempted. If no match is found, it rings the bell. Otherwise,
the word is replaced by the matching pattern and input mode is entered.
.RE

.sp
.ne 2
.mk
.na
\fB\e\fR
.ad
.RS 18n
.rt
Filename completion. Replaces the current word with the longest common
prefix of all filenames matching the current word with an asterisk appended.
If the match is unique, a
.B /
is appended if the file is a directory and
a space is appended if the file is not a directory.
.RE

.SS "Other Edit Commands"
.sp
.LP
Miscellaneous commands.
.sp
.ne 2
.mk
.na
\fB[\fIcount\fR]\fBy\fImotion\fR
.ad
.br
.na
\fBy\fR[\fIcount\fR]\fImotion\fR
.ad
.RS 18n
.rt
Yank current character through character that
.I motion
would move the
cursor to and puts them into the delete buffer. The text and cursor are
unchanged.
.RE

.sp
.ne 2
.mk
.na
.B Y
.ad
.RS 18n
.rt
Yanks from current position to end of line. Equivalent to
.BR y$ .
.RE

.sp
.ne 2
.mk
.na
.B u
.ad
.RS 18n
.rt
Undo the last text modifying command.
.RE

.sp
.ne 2
.mk
.na
.B U
.ad
.RS 18n
.rt
Undo all the text modifying commands performed on the line.
.RE

.sp
.ne 2
.mk
.na
\fB[\fIcount\fR]\fBv\fR
.ad
.RS 18n
.rt
Returns the command
.B "fc -e"
\fB${VISUAL:-${EDITOR:-vi}\fB}\fR
.I count
in the input buffer.
If
.I count
is omitted, then the current line is used.
.RE

.sp
.ne 2
.mk
.na
.B ^L
.ad
.RS 18n
.rt
Line feed and print current line. Has effect only in control mode.
.RE

.sp
.ne 2
.mk
.na
.B J
.ad
.RS 18n
.rt
(New line) Execute the current line, regardless of mode.
.RE

.sp
.ne 2
.mk
.na
.B M
.ad
.RS 18n
.rt
(Return) Execute the current line, regardless of mode.
.RE

.sp
.ne 2
.mk
.na
.B #
.ad
.RS 18n
.rt
If the first character of the command is a
.BR # ,
then this command
deletes this
.B #
and each
.B #
that follows a newline. Otherwise,
sends the line after inserting a
.B #
in front of each line in the
command. Useful for causing the current line to be inserted in the history
as a comment and removing comments from previous comment commands in the
history file.
.RE

.sp
.ne 2
.mk
.na
.B =
.ad
.RS 18n
.rt
List the file names that match the current word if an asterisk were
appended it.
.RE

.sp
.ne 2
.mk
.na
.BI @ letter
.ad
.RS 18n
.rt
Your alias list is searched for an alias by the name
.BI _ letter
and if an alias of this name is defined, its value is inserted on the input
queue for processing.
.RE

.SS "Special Commands"
.sp
.LP
The following
.I simple-commands
are executed in the shell process.
Input/Output redirection is permitted. Unless otherwise indicated, the
output is written on file descriptor 1 and the exit status, when there is no
syntax error, is
.BR 0 .
Commands that are preceded by one or two *
(asterisks) are treated specially in the following ways:
.RS +4
.TP
1.
Variable assignment lists preceding the command remain in effect when the
command completes.
.RE
.RS +4
.TP
2.
I/O redirections are processed after variable assignments.
.RE
.RS +4
.TP
3.
Errors cause a script that contains them to abort.
.RE
.RS +4
.TP
4.
Words, following a command preceded by ** that are in the format of a
variable assignment, are expanded with the same rules as a variable
assignment. This means that tilde substitution is performed after the
\fB=\fR sign and word splitting and file name generation are not
performed.
.RE
.sp
.ne 2
.mk
.na
\fB* :\fR [
.I arg
\&.\|.\|. ]\fR
.ad
.sp .6
.RS 4n
The command only expands parameters.
.RE

.sp
.ne 2
.mk
.na
\fB* \&.\fR \fIfile\fR [
.I arg
\&.\|.\|. ]\fR
.ad
.sp .6
.RS 4n
Read the complete
.I file
then execute the commands. The commands are
executed in the current shell environment. The search path specified by
\fBPATH\fR is used to find the directory containing
.IR file .
If any
arguments
.I arg
are given, they become the positional parameters.
Otherwise the positional parameters are unchanged. The exit status is the
exit status of the last command executed.
.RE

.sp
.ne 2
.mk
.na
\fB** alias\fR [
.B -tx
] [ \fIname\fR[ \fB=\fIvalue\fR ] ]
\&.\|.\|.\fR
.ad
.sp .6
.RS 4n
\fBalias\fR with no arguments prints the list of aliases in the form
\fIname=value\fR on standard output. An
.I alias
is defined for each name
whose
.I value
is given. A trailing space in
.I value
causes the next
word to be checked for alias substitution. The
.B -t
flag is used to set
and list tracked aliases. The value of a tracked alias is the full pathname
corresponding to the given
.IR name .
The value becomes undefined when the
value of
.B PATH
is reset but the aliases remained tracked. Without the
\fB-t\fR flag, for each
.I name
in the argument list for which no
\fIvalue\fR is given, the name and value of the alias is printed. The
\fB-x\fR flag is used to set or print \fIexported alias\fRes. An \fIexported alias\fR is defined for scripts invoked by name. The exit status is non-zero
if a
.I name
is given, but no value, and no alias has been defined for
the
.IR name .
.RE

.sp
.ne 2
.mk
.na
\fBbg\fR [ \fB%\fIjob\fR.\|.\|. ]\fR
.ad
.sp .6
.RS 4n
This command is only on systems that support job control. Puts each
specified
.I job
into the background. The current job is put in the
background if
.I job
is not specified. See
.B Jobs
section above for a
description of the format of
.IR job .
.RE

.sp
.ne 2
.mk
.na
\fB* break\fR [
.I n
]\fR
.ad
.sp .6
.RS 4n
Exit from the enclosed
.BR for ,
.BR while ,
.BR until ,
or
.BR select
loop, if any. If
.I n
is specified then
.B break
\fIn\fR levels. If
\fIn\fR is greater than the number of enclosing loops, the outermost
enclosing loop shall be exited.
.RE

.sp
.ne 2
.mk
.na
\fB* continue\fR [
.I n
]\fR
.ad
.sp .6
.RS 4n
Resume the next iteration of the enclosed
.BR for ,
.BR while ,
.BR until ,
or
.B select
loop. If
.I n
is specified then resume at
the
.IR n -th
enclosed loop. If \fIn\fR is greater than the number of
enclosing loops, the outermost enclosing loop shall be used.
.RE

.sp
.ne 2
.mk
.na
\fBcd\fR [ \fB-L\fR ] [ \fB-P\fR ] [
.I arg
]\fR
.ad
.br
.na
.BI cd " old new"
.ad
.sp .6
.RS 4n
This command can be in either of two forms. In the first form it changes
the current directory to
.IR arg .
If
.I arg
is
.B \(mi
the directory
is changed to the previous directory. The shell variable
.B HOME
is the
default
.IR arg .
The environment variable
.B PWD
is set to the current
directory. If the
.B PWD
is changed, the
.B OLDPWD
environment
variable shall also be changed to the value of the old working directory,
that is, the current working directory immediately prior to the call to
change directory
.RB ( cd ).
The shell variable
.B CDPATH
defines the
search path for the directory containing
.IR arg .
Alternative directory
names are separated by a colon
.RB ( : ).
The default path is null
(specifying the current directory). The current directory is specified by a
null path name, which can appear immediately after the equal sign or between
the colon delimiters anywhere else in the path list. If
.I arg
begins
with a
.B /
then the search path is not used. Otherwise, each directory
in the path is searched for
.IR arg .
If unsuccessful,
.B cd
attempts to
change directories to the pathname formed by the concatenation of the value
of PWD, a slash character, and arg.
.sp
.ne 2
.mk
.na
.B -L
.ad
.RS 6n
.rt
Handles the operation dot-dot (\fB\&..\fR) logically. Symbolic link
components are
.B not
resolved before dot-dot components are processed.
.RE

.sp
.ne 2
.mk
.na
.B -P
.ad
.RS 6n
.rt
.RB "Handles the operand dot-dot physically. Symbolic link components" " are"
resolved before dot-dot components are processed.
.RE

If both
.B -L
and
.B -P
options are specified, the last option to be
invoked is used and the other is ignored. If neither
.B -L
nor
.BR -P
is specified, the operand is handled dot-dot logically.
.sp
The second form of
.B cd
substitutes the string
.I new
for the string
\fIold\fR in the current directory name,
.BR PWD ,
and tries to change to
this new directory. The
.B cd
command cannot be executed by
.BR rksh .
.RE

.sp
.ne 2
.mk
.na
\fBcommand\fR [\fB-p] [\fIcommand_name\fR]
[\fBargument\fR .\|.\|.]\fR
.ad
.br
.na
\fBcommand\fR [\fB-v |\fR \fB-V\fR] \fIcommand_name\fR
.ad
.sp .6
.RS 4n
The
.B command
utility causes the shell to treat the arguments as a
simple command, suppressing the shell function lookup. The
.B -p
flag
performs the command search using a default value for
.B PATH
that is
guaranteed to find all of the standard utilities. The
.B -v
flag writes a
string to standard output that indicates the pathname or command that is
used by the shell, in the current shell execution environment, to invoke
.IR command_name .
The
.B -V
flag writes a string to standard output
that indicates how the name given in the
.I command_name
operand is
interpreted by the shell, in the current shell execution environment.
.RE

.sp
.ne 2
.mk
.na
\fBecho\fR [
.I arg
\&.\|.\|. ]\fR
.ad
.sp .6
.RS 4n
See
.BR echo (1)
for usage and description.
.RE

.sp
.ne 2
.mk
.na
\fB* eval\fR [
.I arg
\&.\|.\|. ]\fR
.ad
.sp .6
.RS 4n
The arguments are read as input to the shell and the resulting command(s)
executed.
.RE

.sp
.ne 2
.mk
.na
\fB* exec\fR [
.I arg
\&.\|.\|. ]\fR
.ad
.sp .6
.RS 4n
If
.I arg
is given, the command specified by the arguments is executed
in place of this shell without creating a new process. Input/output
arguments can appear and affect the current process. If no arguments are
given the effect of this command is to modify file descriptors as prescribed
by the input/output redirection list. In this case, any file descriptor
numbers greater than 2 that are opened with this mechanism are closed when
invoking another program.
.RE

.sp
.ne 2
.mk
.na
\fB* exit\fR [
.I n
]\fR
.ad
.sp .6
.RS 4n
Causes the calling shell or shell script to exit with the exit status
specified by
.IR n .
The value is the least significant 8 bits of the
specified status. If
.I n
is omitted then the exit status is that of the
last command executed. When
.B exit
occurs when executing a trap, the
last command refers to the command that executed before the trap was
invoked. An EOF also causes the shell to exit except for a shell which has
.RB "the " ignoreeof " option turned on. See " set .
.RE

.sp
.ne 2
.mk
.na
\fB** export\fR [ \fIname\fR[\fB=\fIvalue\fR] ] .\|.\|.\fR
.ad
.br
.na
.B "** export -p"
.ad
.sp .6
.RS 4n
The given
.IR name s
are marked for automatic export to the
\fBenvironment\fR of subsequently-executed commands.
.sp
When
.B -p
is specified,
.B export
writes to the standard output the
names and values of all exported variables in the following format:
.sp
.in +2
.nf
"export %s=%s\en", \fIname\fR, \fIvalue\fR
.fi
.in -2
.sp

if
.I name
is set, and:
.sp
.in +2
.nf
"export %s\en", \fIname\fR
.fi
.in -2
.sp

if
.I name
is unset.
.sp
The shell formats the output, including the proper use of quoting, so that
it is suitable for reinput to the shell as commands that achieve the same
exporting results, except for the following:
.RS +4
.TP
1.
Read-only variables with values cannot be reset.
.RE
.RS +4
.TP
2.
Variables that were unset at the time they were output are not reset to the
unset state if a value is assigned to the variable between the time the
state was saved and the time at which the saved output is reinput to the
shell.
.RE
.RE

.sp
.ne 2
.mk
.na
\fBfc\fR [ \fB-e\fR \fIename\fR ] [ \fB-nlr\fR ] [
.I first
[
.IR last " ] ]"
.ad
.br
.na
\fBfc -e\fR
.B -
[ \fIold\fB=\fInew\fR ] [ \fIcommand\fR
]\fR
.ad
.br
.na
\fBfc -s\fR [ \fIold\fB=\fInew\fR ] [
.I command
]\fR
.ad
.sp .6
.RS 4n
In the first form, a range of commands from
.I first
to
.I last
is
selected from the last
.B HISTSIZE
commands that were typed at the
terminal. The arguments
.IR first " and "
.I last
can be specified as a
number or as a string. A string is used to locate the most recent command
starting with the given string. A negative number is used as an offset to
the current command number. If the
.B -l
flag is selected, the commands
are listed on standard output. Otherwise, the editor program
.I ename
is
invoked on a file containing these keyboard commands. If
.I ename
is not
supplied, then the value of the variable
.B FCEDIT
(default
.BR /bin/ed )
is used as the editor. When editing is complete, the edited
command(s) is executed. If
.I last
is not specified then it is set to
.IR first .
If \fIfirst\fR is not specified the default is the previous
command for editing and \fB\(mi16\fR for listing. The flag
.B -r
reverses
the order of the commands and the flag
.B -n
suppresses command numbers
when listing. In the second form the
.I command
is re-executed after the
substitution \fIold\fB=\fInew\fR is performed. If there is not a
\fIcommand\fR argument, the most recent command typed at this terminal is
executed.
.RE

.sp
.ne 2
.mk
.na
\fBfg\fR [ \fB%\fIjob\fR.\|.\|. ]\fR
.ad
.sp .6
.RS 4n
.RI "This command is only on systems that support job control. Each" " job"
specified is brought to the foreground. Otherwise, the current job is
brought into the foreground. See "\fBJobs\fR" section above for a
description of the format of
.IR job .
.RE

.sp
.ne 2
.mk
.na
\fBgetopts\fR \fIoptstring name\fR [
.I arg
\&.\|.\|. ]\fR
.ad
.sp .6
.RS 4n
Checks
.I arg
for legal options. If
.I arg
is omitted, the positional
parameters are used. An option argument begins with a
.B +
or a
\fB\(mi\fR\&. An option not beginning with
.B +
or \fB\(mi\fR or the
argument
.B -
ends the options.
.I optstring
contains the letters that
\fBgetopts\fR recognizes. If a letter is followed by a
.BR : ,
that option
is expected to have an argument. The options can be separated from the
argument by blanks.
.sp
\fBgetopts\fR places the next option letter it finds inside variable
\fIname\fR each time it is invoked with a
.B +
prepended when \fIarg\fR
begins with a
.BR + .
The index of the next
.I arg
is stored in
.BR OPTIND .
The option argument, if any, gets stored in
.BR OPTARG .
.sp
A leading
.B :
in
.I optstring
causes
.B getopts
to store the
letter of an invalid option in
.BR OPTARG ,
and to set
.I name
to
\fB?\fR for an unknown option and to
.B :
when a required option is
missing. Otherwise,
.B getopts
prints an error message. The exit status
is non-zero when there are no more options. See
.BR getoptcvt (1)
for usage
and description.
.sp
\fBgetopts\fR supports both traditional single-character short options and
long options defined by Sun's Command Line Interface Paradigm
.RB ( CLIP ).

.sp
Each long option is an alias for a short option and is specified in
parentheses following its equivalent short option. For example, you can
.RB "specify the long option " file " as an alias for the short option " f 
using the following script line:
.sp
.in +2
.nf
getopts "f(file)" opt
.fi
.in -2
.sp

Precede long options on the command line with
.B --
or
.BR ++ .
In the
example above,
.B --file
on the command line would be the equivalent of
.BR -f ,
and \fB++file\fR on the command line would be the equivalent of
.BR +f .
.sp
Each short option can have multiple long option equivalents, although this
is in violation of the CLIP specification and should be used with caution.
You must enclose each long option equivalent parentheses, as follows:
.sp
.in +2
.nf
getopts "f:(file)(input-file)o:(output-file)"
.fi
.in -2
.sp

In the above example, both
.BR --file " and "
.B --input-file
are the
equivalent of
.BR -f ,
and
.B --output-file
is the equivalent of
.BR -o .
.sp
The variable name is always set to a short option. When a long option is
specified on the command line, name is set to the short-option equivalent.
.RE

.sp
.ne 2
.mk
.na
\fBhash\fR [
.I name
\&.\|.\|. ]\fR
.ad
.br
.na
\fBhash\fR [
.B -r
]\fR
.ad
.sp .6
.RS 4n
For each
.IR name ,
the location in the search path of the command
specified by
.I name
is determined and remembered by the shell. The
\fB-r\fR option causes the shell to forget all remembered locations. If no
arguments are given, information about remembered commands is presented.
\fIHits\fR is the number of times a command has been invoked by the shell
process.
.I Cost
is a measure of the work required to locate a command in
the search path. If a command is found in a relative directory in the search
path, after changing to that directory, the stored location of that command
is recalculated. Commands for which this is done are indicated by an
asterisk (\fB*\fR) adjacent to the
.I hits
information.
.I Cost
is
incremented when the recalculation is done.
.RE

.sp
.ne 2
.mk
.na
\fBjobs\fR [
.B -lnp
] [ \fB%\fIjob\fR .\|.\|. ]\fR
.ad
.sp .6
.RS 4n
Lists information about each given job; or all active jobs if
.I job
is
omitted. The
.B -l
flag lists process ids in addition to the normal
information. The
.B -n
flag displays only jobs that have stopped or
exited since last notified. The
.B -p
flag causes only the process group
to be listed. See \fB"Jobs"\fR section above and \fBjobs\fR(1) for a
description of the format of
.IR job .
.RE

.sp
.ne 2
.mk
.na
\fBkill\fR [ \fB-\fIsig\fR ] \fB%\fIjob\fR .\|.\|.\fR
.ad
.br
.na
\fBkill\fR [ \fB-\fIsig\fR ]
.I pid
\&.\|.\|.\fR
.ad
.br
.na
.B kill -l
.ad
.sp .6
.RS 4n
Sends either the
.B TERM
(terminate) signal or the specified signal to
the specified jobs or processes. Signals are either given by number or by
names (as given in
.BR signal.h (3HEAD)
stripped of the prefix ``SIG'' with
the exception that
.B SIGCHD
is named
.BR CHLD ).
If the signal being
sent is
.B TERM
(terminate) or
.B HUP
(hangup), then the job or
process is sent a
.B CONT
(continue) signal if it is stopped. The
argument
.I job
can be the process id of a process that is not a member
of one of the active jobs. See
.B Jobs
for a description of the format of
.IR job .
In the second form,
.BR "kill -l" ,
the signal numbers and
names are listed.
.RE

.sp
.ne 2
.mk
.na
\fBlet\fR \fIarg\fR.\|.\|.\fR
.ad
.sp .6
.RS 4n
Each
.I arg
is a separate
.I "arithmetic expression"
to be evaluated.
See the
.B "Arithmetic Evaluation"
section above, for a description of
arithmetic expression evaluation.
.sp
The exit status is
.B 0
if the value of the last expression is non-zero,
and
.B 1
otherwise.
.RE

.sp
.ne 2
.mk
.na
.B login
.I argument
\&.\|.\|.\fR
.ad
.sp .6
.RS 4n
Equivalent to `\fBexec login \fIargument\fR....' See
.BR login (1)
for
usage and description.
.RE

.sp
.ne 2
.mk
.na
\fB* newgrp\fR [
.I arg
\&.\|.\|. ]\fR
.ad
.sp .6
.RS 4n
Equivalent to
.B "exec /bin/newgrp"
\fIarg\fR ....
.RE

.sp
.ne 2
.mk
.na
\fBprint\fR [ \fB-Rnprsu\fR[\fIn\fR ] ] [
.I arg
\&.\|.\|. ]\fR
.ad
.sp .6
.RS 4n
The shell output mechanism. With no flags or with flag
.B \(mi
or
.BR - ,
the arguments are printed on standard output as described by
.BR echo (1).
The exit status is
.BR 0 ,
unless the output file is not
open for writing.
.sp
.ne 2
.mk
.na
.B -n
.ad
.RS 12n
.rt
Suppresses
.B NEWLINE
from being added to the output.
.RE

.sp
.ne 2
.mk
.na
\fB-R\fR | \fB-r\fR
.ad
.RS 12n
.rt
Raw mode. Ignores the escape conventions of
.BR echo .
The
.B -R
option
prints all subsequent arguments and options other than
.BR -n .
.RE

.sp
.ne 2
.mk
.na
.B -p
.ad
.RS 12n
.rt
Writes the arguments to the pipe of the process spawned with
.BR |&
instead of standard output.
.RE

.sp
.ne 2
.mk
.na
.B -s
.ad
.RS 12n
.rt
Writes the arguments to the history file instead of standard output.
.RE

.sp
.ne 2
.mk
.na
\fB-u\fR [
.I n
]\fR
.ad
.RS 12n
.rt
Specifies a one digit file descriptor unit number
.I n
on which the
output is placed. The default is
.BR 1 .
.RE

.RE

.sp
.ne 2
.mk
.na
\fBpwd\fR [ \fB-L\fR |
.B -P
]\fR
.ad
.sp .6
.RS 4n
Writes to the standard output an absolute pathname of the current working
directory, which does not contain the filenames dot (\fB\&.\fR) or dot-dot
(\fB\&..\fR).
.sp
.ne 2
.mk
.na
.B -L
.ad
.RS 6n
.rt
If the
.B PWD
environment variable contains an absolute pathname of the
current directory that does not contain the filenames dot or dot-dot,
\fBpwd\fR writes this pathname to standard output. Otherwise, the \fB-L\fR
option behaves like the
.B -P
option.
.RE

.sp
.ne 2
.mk
.na
.B -P
.ad
.RS 6n
.rt
The absolute pathname written shall not contain filenames that, in the
context of the pathname, refer to files of type symbolic link.
.RE

If both
.B -L
and
.B -P
are specified, the last one applies. If
neither
.B -L
nor
.B -P
is specified,
.B pwd
behaves as if
.BR -L
had been specified.
.RE

.sp
.ne 2
.mk
.na
\fBread\fR [ \fB-prsu\fR[
.I n
] ] [ \fIname\fB?\fIprompt\fR ]
[
.I name
\&.\|.\|. ]\fR
.ad
.sp .6
.RS 4n
\fBThe shell input mechanism.\fR One line is read and is broken up into
fields using the characters in
.B IFS
as separators. The escape
character, \fB(\e)\fR, is used to remove any special meaning for the next
character and for line continuation. In raw mode,
.BR -r ,
the \fB\e\fR
character is not treated specially. The first field is assigned to the first
.IR name ,
the second field to the second
.IR name ,
etc., with leftover
fields assigned to the last
.IR name .
The
.B -p
option causes the input
line to be taken from the input pipe of a process spawned by the shell using
.BR |& .
If the
.B -s
flag is present, the input is saved as a command
in the history file. The flag
.B -u
can be used to specify a one digit
file descriptor unit
.I n
to read from. The file descriptor can be opened
with the
.B exec
special command. The default value of
.I n
is
.BR 0 .
If
.I name
is omitted then
.B REPLY
is used as the default
.IR name .
The exit status is
.B 0
unless the input file is not open for
reading or an
.B EOF
is encountered. An
.B EOF
with the
.BR -p
option causes cleanup for this process so that another can be spawned. If
the first argument contains a
.BR ? ,
the remainder of this word is used as
a
.I prompt
on standard error when the shell is interactive. The exit
status is
.B 0
unless an
.B EOF
is encountered.
.RE

.sp
.ne 2
.mk
.na
\fB** readonly\fR [ \fIname\fR[\fB=\fIvalue\fR] ] .\|.\|.\fR
.ad
.br
.na
.B "** readonly -p"
.ad
.sp .6
.RS 4n
The given
.IR name "s are marked"
.B readonly
and these names cannot be
changed by subsequent assignment.
.sp
When
.B -p
is specified,
.B readonly
writes to the standard output
the names and values of all read-only variables, in the following format:
.sp
.in +2
.nf
"readonly %s=%s\en", \fIname\fR, \fIvalue\fR
.fi
.in -2
.sp

if
.I name
is set, and:
.sp
.in +2
.nf
"readonly $s\en", \fIname\fR
.fi
.in -2
.sp

if
.I name
is unset.
.sp
The shell formats the output, including the proper use of quoting, so that
it is suitable for reinput to the shell as commands that achieve the same
value and readonly attribute-setting results in a shell execution
environment in which:
.RS +4
.TP
1.
Variables with values set at the time they were output do not have the
readonly attribute set.
.RE
.RS +4
.TP
2.
Variables that were unset at the time they were output do not have a value
at the time at which the saved output is reinput to the shell.
.RE
.RE

.sp
.ne 2
.mk
.na
\fB* return\fR [
.I n
]\fR
.ad
.sp .6
.RS 4n
Causes a shell function or \fB\&'.'\fR script to return to the invoking
script with the return status specified by
.IR n .
The value is the least
significant 8 bits of the specified status. If
.I n
is omitted then the
return status is that of the last command executed. If
.B return
is
invoked while not in a function or a \fB\&'.'\fR script, then it is the same
as an
.BR exit .
.RE

.sp
.ne 2
.mk
.na
\fBset\fR [ \fB\(+-abCefhkmnopstuvx\fR ] [ \fB\(+-o\fR \fIoption\fR
].\|.\|. [ \fB\(+-A\fR \fIname\fR ] [
.I arg
\&.\|.\|. ]\fR
.ad
.sp .6
.RS 4n
The flags for this command have meaning as follows:
.sp
.ne 2
.mk
.na
.B -A
.ad
.RS 12n
.rt
Array assignment. Unsets the variable
.I name
and assigns values
sequentially from the list
.IR arg .
If
.B +A
is used, the variable
\fIname\fR is not unset first.
.RE

.sp
.ne 2
.mk
.na
.B -a
.ad
.RS 12n
.rt
All subsequent variables that are defined are automatically exported.
.RE

.sp
.ne 2
.mk
.na
.B -b
.ad
.RS 12n
.rt
Causes the shell to notify the user asynchronously of background job
completions. The following message is written to standard error:
.sp
.in +2
.nf
"[%d]%c %s%s\en", <\fIjob-number\fR>, <\fIcurrent\fR>, <\fIstatus\fR>, \e
     whe<\fIjob-name\fR>
.fi
.in -2
.sp

where the fields are as follows:
.sp
.ne 2
.mk
.na
.I <current>
.ad
.RS 16n
.rt
The character
.B +
identifies the job that would be used as a default
for the
.BR fg " or "
.B bg
utilities. This job can also be specified using
the
.I job_id
\fB%+\fR or
.BR %% .
The character
.B \(mi
identifies
the job that would become the default if the current default job were to
exit; this job can also be specified using the
.I job_id
\fB%\(mi\fR. For
other jobs, this field is a space character. At most one job can be
identified with
.B +
and at most one job can be identified with
\fB\(mi\fR\&. If there is any suspended job, then the current job is a
suspended job. If there are at least two suspended jobs, then the previous
job is also a suspended job.
.RE

.sp
.ne 2
.mk
.na
.I <job-number>
.ad
.RS 16n
.rt
A number that can be used to identify the process group to the
.BR wait ,
.BR fg ,
.BR bg ,
and
.B kill
utilities. Using these utilities, the job
can be identified by prefixing the job number with
.BR % .
.RE

.sp
.ne 2
.mk
.na
.I <status>
.ad
.RS 16n
.rt
Unspecified.
.RE

.sp
.ne 2
.mk
.na
.I <job-name>
.ad
.RS 16n
.rt
Unspecified.
.RE

When the shell notifies the user a job has been completed, it can remove
the job's process ID from the list of those known in the current shell
execution environment. Asynchronous notification is not enabled by
default.
.RE

.sp
.ne 2
.mk
.na
.B -C
.ad
.RS 12n
.rt
Prevents existing files from being overwritten by the shell's > redirection
operator. The
.B >|
redirection operator overrides this
.BR -noclobber
option for an individual file.
.RE

.sp
.ne 2
.mk
.na
.B -e
.ad
.RS 12n
.rt
If a command has a non-zero exit status, executes the
.B ERR
trap, if
set, and exit. This mode is disabled while reading profiles.
.RE

.sp
.ne 2
.mk
.na
.B -f
.ad
.RS 12n
.rt
Disables file name generation.
.RE

.sp
.ne 2
.mk
.na
.B -h
.ad
.RS 12n
.rt
Each command becomes a tracked alias when first encountered.
.RE

.sp
.ne 2
.mk
.na
.B -k
.ad
.RS 12n
.rt
All variable assignment arguments are placed in the environment for a
command, not just those that precede the command name.
.RE

.sp
.ne 2
.mk
.na
.B -m
.ad
.RS 12n
.rt
Background jobs runs in a separate process group and a line prints upon
completion. The exit status of background jobs is reported in a completion
message. On systems with job control, this flag is turned on automatically
for interactive shells.
.RE

.sp
.ne 2
.mk
.na
.B -n
.ad
.RS 12n
.rt
Reads commands and check them for syntax errors, but do not execute them.
Ignored for interactive shells.
.RE

.sp
.ne 2
.mk
.na
.B -o
.ad
.RS 12n
.rt
Writes the current option settings to standard output in a format that is
suitable for reinput to the shell as commands that achieve the same option
settings.
.RE

.sp
.ne 2
.mk
.na
.B -o
.ad
.RS 12n
.rt
The following argument can be one of the following option names:
.sp
.ne 2
.mk
.na
.B allexport
.ad
.RS 14n
.rt
Same as
.BR -a .
.RE

.sp
.ne 2
.mk
.na
.B errexit
.ad
.RS 14n
.rt
Same as
.BR -e .
.RE

.sp
.ne 2
.mk
.na
.B bgnice
.ad
.RS 14n
.rt
All background jobs are run at a lower priority. This is the default
mode.
.RE

.sp
.ne 2
.mk
.na
.B emacs
.ad
.RS 14n
.rt
Puts you in an
.B emacs
style in-line editor for command entry.
.RE

.sp
.ne 2
.mk
.na
.B gmacs
.ad
.RS 14n
.rt
Puts you in a
.B gmacs
style in-line editor for command entry.
.RE

.sp
.ne 2
.mk
.na
.B ignoreeof
.ad
.RS 14n
.rt
The shell does not exit on\fBEOF\fR. The command
.B exit
must be used.
.RE

.sp
.ne 2
.mk
.na
.B keyword
.ad
.RS 14n
.rt
Same as
.BR -k .
.RE

.sp
.ne 2
.mk
.na
.B markdirs
.ad
.RS 14n
.rt
All directory names resulting from file name generation have a trailing
\fB/\fR appended.
.RE

.sp
.ne 2
.mk
.na
.B monitor
.ad
.RS 14n
.rt
Same as
.BR -m .
.RE

.sp
.ne 2
.mk
.na
.B noclobber
.ad
.RS 14n
.rt
Prevents redirection
.B >
from truncating existing files. Require >| to
truncate a file when turned on. Equivalent to
.BR -C .
.RE

.sp
.ne 2
.mk
.na
.B noexec
.ad
.RS 14n
.rt
Same as
.BR -n .
.RE

.sp
.ne 2
.mk
.na
.B noglob
.ad
.RS 14n
.rt
Same as
.BR -f .
.RE

.sp
.ne 2
.mk
.na
.B nolog
.ad
.RS 14n
.rt
Do not save function definitions in history file.
.RE

.sp
.ne 2
.mk
.na
.B notify
.ad
.RS 14n
.rt
Equivalent to
.BR -b .
.RE

.sp
.ne 2
.mk
.na
.B nounset
.ad
.RS 14n
.rt
Same as
.BR -u .
.RE

.sp
.ne 2
.mk
.na
.B privileged
.ad
.RS 14n
.rt
Same as
.BR -p .
.RE

.sp
.ne 2
.mk
.na
.B verbose
.ad
.RS 14n
.rt
Same as
.BR -v .
.RE

.sp
.ne 2
.mk
.na
.B trackall
.ad
.RS 14n
.rt
Same as
.BR -h .
.RE

.sp
.ne 2
.mk
.na
.B vi
.ad
.RS 14n
.rt
Puts you in insert mode of a
.B vi
style in-line editor until you hit
escape character
.BR 033 .
This puts you in control mode. A return sends
the line.
.RE

.sp
.ne 2
.mk
.na
.B viraw
.ad
.RS 14n
.rt
Each character is processed as it is typed in
.B vi
mode.
.RE

.sp
.ne 2
.mk
.na
.B xtrace
.ad
.RS 14n
.rt
Same as
.BR -x .
.RE

If no option name is supplied, the current option settings are printed.
.RE

.sp
.ne 2
.mk
.na
.B -p
.ad
.RS 12n
.rt
Disables processing of the
.B $HOME/.profile
file and uses the file
\fB/etc/suid_profile\fR instead of the
.B ENV
file. This mode is on
whenever the effective uid is not equal to the real uid, or when the
effective gid is not equal to the real gid. Turning this off causes the
effective uid and gid to be set to the real uid and gid.
.RE

.sp
.ne 2
.mk
.na
.B -s
.ad
.RS 12n
.rt
Sorts the positional parameters lexicographically.
.RE

.sp
.ne 2
.mk
.na
.B -t
.ad
.RS 12n
.rt
Exits after reading and executing one command.
.RE

.sp
.ne 2
.mk
.na
.B -u
.ad
.RS 12n
.rt
Treats unset parameters as an error when substituting.
.RE

.sp
.ne 2
.mk
.na
.B -v
.ad
.RS 12n
.rt
Prints shell input lines as they are read.
.RE

.sp
.ne 2
.mk
.na
.B -x
.ad
.RS 12n
.rt
Prints commands and their arguments as they are executed.
.RE

.sp
.ne 2
.mk
.na
\fB\(mi\fR
.ad
.RS 12n
.rt
Turns off
.B -x
and
.B -v
flags and stops examining arguments for
flags.
.RE

.sp
.ne 2
.mk
.na
\fB\(mi\(mi\fR
.ad
.RS 12n
.rt
Does not change any of the flags. Useful in setting
.B $1
to a value
beginning with \fB\(mi\fR\&. If no arguments follow this flag then the
positional parameters are unset.
.sp
Using
.B +
rather than
.B \(mi
causes these flags to be turned off.
These flags can also be used upon invocation of the shell. The current set
of flags can be found in \fB$\(mi\fR. Unless
.B -A
is specified, the
remaining arguments are positional parameters and are assigned, in order, to
\fB$1 $2\fR .... If no arguments are given, the names and values of
all variables are printed on the standard output.
.RE

.RE

.sp
.ne 2
.mk
.na
\fB* shift\fR [
.I n
]\fR
.ad
.sp .6
.RS 4n
The positional parameters from \fB$\fIn\fB+1\fR \fB$\fIn\fB+1 \&.\|.\|.\fR are renamed \fB$1 .\|.\|.\fR, default \fIn\fR is 1. The
parameter
.I n
can be any arithmetic expression that evaluates to a
non-negative number less than or equal to
.BR $# .
.RE

.sp
.ne 2
.mk
.na
\fBstop\fR%\fIjobid\fR .\|.\|.\fR
.ad
.br
.na
.B stop
.I pid
\&.\|.\|.\fR
.ad
.sp .6
.RS 4n
\fBstop\fR stops the execution of a background job(s) by using its
.IR jobid ,
or of any process by using its
.IR pid .
See
.BR ps (1).
.RE

.sp
.ne 2
.mk
.na
.B suspend
.ad
.sp .6
.RS 4n
Stops the execution of the current shell (but not if it is the login
shell).
.RE

.sp
.ne 2
.mk
.na
.BI test " expression"
.ad
.sp .6
.RS 4n
.RB "Evaluates conditional expressions. See" " Conditional Expressions"
section above and
.BR test (1)
for usage and description.
.RE

.sp
.ne 2
.mk
.na
.B "* times"
.ad
.sp .6
.RS 4n
Prints the accumulated user and system times for the shell and for
processes run from the shell.
.RE

.sp
.ne 2
.mk
.na
\fB* trap\fR [
.I arg sig
\&.\|.\|. ]\fR
.ad
.sp .6
.RS 4n
\fIarg\fR is a command to be read and executed when the shell receives
signal(s)
.IR sig .
\fIarg\fR is scanned once when the trap is set and once
when the trap is taken.
.I sig
can be specified as a signal number or
signal name.
.B trap
commands are executed in order of signal number. Any
attempt to set a trap on a signal number that was ignored on entry to the
current shell is ineffective.
.sp
If
.I arg
is \fB\(mi\fR, the shell resets each
.I sig
to the default
value. If
.I arg
is null (\fB\&''\fR), the shell ignores each specified
\fIsig\fR if it arises. Otherwise,
.I arg
is read and executed by the
shell when one of the corresponding
.I sigs
arises. The action of the
trap overrides a previous action (either default action or one explicitly
set). The value of
.B $?
after the trap action completes is the value it
had before the trap was invoked.
.sp
\fIsig\fR can be \fBEXIT, 0\fR (equivalent to
.B EXIT)
or a signal
specified using a symbolic name, without the
.B SIG
prefix, for example,
.BR HUP ,
.BR INT ,
.BR QUIT ,
.BR TERM .
If
.I sig
is
.B 0
or
\fBEXIT\fR and the
.B trap
statement is executed inside the body of a
function, then the command
.I arg
is executed after the function
completes. If
.I sig
is
.B 0
or
.B EXIT
for a
.B trap
set
outside any function, the command
.I arg
is executed on exit from the
shell. If
.I sig
is
.BR ERR ,
\fIarg\fR is executed whenever a command
has a non-zero exit status. If
.I sig
is
.BR DEBUG ,
\fIarg\fR is
executed after each command.
.sp
The environment in which the shell executes a trap on
.B EXIT
is
identical to the environment immediately after the last command executed
before the trap on
.B EXIT
was taken.
.sp
Each time the trap is invoked,
.I arg
is processed in a manner
equivalent to \fBeval "$arg"\fR.
.sp
Signals that were ignored on entry to a non-interactive shell cannot be
trapped or reset, although no error need be reported when attempting to do
so. An interactive shell can reset or catch signals ignored on entry. Traps
remain in place for a given shell until explicitly changed with another
\fBtrap\fR command.
.sp
When a subshell is entered, traps are set to the default args. This does
not imply that the
.B trap
command cannot be used within the subshell to
set new traps.
.sp
The
.B trap
command with no arguments writes to standard output a list
of commands associated with each sig. The format is:
.sp
.in +2
.nf
trap \(mi\(mi %s %s .\|.\|. \fI<arg>\fR, \fI<sig>\fR .\|.\|.
.fi
.in -2
.sp

The shell formats the output, including the proper use of quoting, so that
it is suitable for reinput to the shell as commands that achieve the same
trapping results. For example:
.sp
.in +2
.nf
\fBsave_traps=$(trap)
\&.\|.\|.
eval "$save_traps"\fR
.fi
.in -2
.sp

If the trap name or number is invalid, a non-zero exit status is returned.
Otherwise,
.B 0
is returned. For both interactive and non-interactive
shells, invalid signal names or numbers are not considered a syntax error
and dol not cause the shell to abort.
.sp
Traps are not processed while a job is waiting for a foreground process.
Thus, a trap on
.B CHLD
won't be executed until the foreground job
terminates.
.RE

.sp
.ne 2
.mk
.na
.B type
.I name
\&.\|.\|.\fR
.ad
.sp .6
.RS 4n
For each
.IR name ,
indicates how it would be interpreted if used as a
command name.
.RE

.sp
.ne 2
.mk
.na
\fB** typeset\fR [ \fB\(+-HLRZfilrtux\fR[\fIn\fR] ] [
\fIname\fR[\fB=\fIvalue\fR ] ] .\|.\|.\fR
.ad
.sp .6
.RS 4n
Sets attributes and values for shell variables and functions. When
\fBtypeset\fR is invoked inside a function, a new instance of the variables
\fIname\fR is created. The variables \fIvalue\fR and
.B type
are restored
when the function completes. The following list of attributes can be
specified:
.sp
.ne 2
.mk
.na
.B -H
.ad
.RS 6n
.rt
This flag provides UNIX to host-name file mapping on non-UNIX machines.
.RE

.sp
.ne 2
.mk
.na
.B -L
.ad
.RS 6n
.rt
Left justifies and removes leading blanks from
.IR value .
If
.I n
is
non-zero it defines the width of the field. Otherwise, it is determined by
the width of the value of first assignment. When the variable is assigned
to, it is filled on the right with blanks or truncated, if necessary, to fit
into the field. Leading zeros are removed if the
.B -Z
flag is also set.
The
.B -R
flag is turned off.
.RE

.sp
.ne 2
.mk
.na
.B -R
.ad
.RS 6n
.rt
Right justifies and fills with leading blanks. If
.I n
is non-zero it
defines the width of the field, otherwise it is determined by the width of
the value of first assignment. The field is left filled with blanks or
truncated from the end if the variable is reassigned. The
.B -L
flag is
turned off.
.RE

.sp
.ne 2
.mk
.na
.B -Z
.ad
.RS 6n
.rt
Right justifies and fills with leading zeros if the first non-blank
character is a digit and the
.B -L
flag has not been set. If
.I n
is
non-zero it defines the width of the field. Otherwise, it is determined by
the width of the value of first assignment.
.RE

.sp
.ne 2
.mk
.na
.B -f
.ad
.RS 6n
.rt
The names refer to function names rather than variable names. No
assignments can be made and the only other valid flags are
.BR -t ,
.BR -u ,
and
.BR -x .
The flag
.B -t
turns on execution tracing for
this function. The flag
.B -u
causes this function to be marked
undefined. The
.B FPATH
variable is searched to find the function
definition when the function is referenced. The flag
.B -x
allows the
function definition to remain in effect across shell procedures invoked by
name.
.RE

.sp
.ne 2
.mk
.na
.B -i
.ad
.RS 6n
.rt
Parameter is an integer. This makes arithmetic faster. If
.I n
is
non-zero it defines the output arithmetic base; otherwise, the first
assignment determines the output base.
.RE

.sp
.ne 2
.mk
.na
.B -l
.ad
.RS 6n
.rt
All upper-case characters are converted to lower-case. The upper-case flag,
\fB-u\fR is turned off.
.RE

.sp
.ne 2
.mk
.na
.B -r
.ad
.RS 6n
.rt
The given
.IR name "s are marked"
.B readonly
and these names cannot be
changed by subsequent assignment.
.RE

.sp
.ne 2
.mk
.na
.B -t
.ad
.RS 6n
.rt
Tags the variables. Tags are user definable and have no special meaning to
the shell.
.RE

.sp
.ne 2
.mk
.na
.B -u
.ad
.RS 6n
.rt
All lower-case characters are converted to upper-case characters. The
lower-case flag,
.B -l
is turned off.
.RE

.sp
.ne 2
.mk
.na
.B -x
.ad
.RS 6n
.rt
The given
.IR name s
are marked for automatic export to the
\fBenvironment\fR of subsequently-executed commands.
.RE

The
.B -i
attribute cannot be specified along with
.BR -R ,
.BR -L ,
.BR -Z ,
or
.BR -f .
.sp
Using
.B +
rather than
.B \(mi
causes these flags to be turned off.
If no
.I name
arguments are given but flags are specified, a list of
\fInames\fR (and optionally the
.IR values )
of the
.I variables
which
have these flags set is printed. (Using
.B +
rather than
.B \(mi
keeps
the values from being printed.) If no
.IR name s
and flags are given, the
\fInames\fR and \fIattributes\fR of all
.I variables
are printed.
.RE

.sp
.ne 2
.mk
.na
\fBulimit\fR [ \fB-HSacdfnstv\fR ] [
.I limit
]\fR
.ad
.sp .6
.RS 4n
Sets or displays a resource limit. The available resources limits are
listed in the following section. Many systems do not contain one or more of
these limits. The limit for a specified resource is set when
.I limit
is
specified. The value of
.I limit
can be a number in the unit specified
with each resource, or the value
.BR unlimited .
The string
.BR unlimited
requests that the current limit, if any, be removed. The
.B -H
and
\fB-S\fR flags specify whether the hard limit or the soft limit for the
given resource is set. A hard limit cannot be increased once it is set. A
soft limit can be increased up to the value of the hard limit. If neither
the
.B -H
or
.B -S
options is specified, the limit applies to both.
The current resource limit is printed when
.I limit
is omitted. In this
case, the soft limit is printed unless
.B -H
is specified. When more than
one resource is specified, the limit name and unit is printed before the
value.
.sp
.ne 2
.mk
.na
.B -a
.ad
.RS 6n
.rt
Lists all of the current resource limits.
.RE

.sp
.ne 2
.mk
.na
.B -c
.ad
.RS 6n
.rt
The number of 512-byte blocks on the size of core dumps.
.RE

.sp
.ne 2
.mk
.na
.B -d
.ad
.RS 6n
.rt
The number of K-bytes on the size of the data area.
.RE

.sp
.ne 2
.mk
.na
.B -f
.ad
.RS 6n
.rt
The number of 512-byte blocks on files written by child processes (files of
any size can be read).
.RE

.sp
.ne 2
.mk
.na
.B -n
.ad
.RS 6n
.rt
The number of file descriptors plus 1.
.RE

.sp
.ne 2
.mk
.na
.B -s
.ad
.RS 6n
.rt
The number of K-bytes on the size of the stack area.
.RE

.sp
.ne 2
.mk
.na
.B -t
.ad
.RS 6n
.rt
The number of seconds to be used by each process.
.RE

.sp
.ne 2
.mk
.na
.B -v
.ad
.RS 6n
.rt
The number of K-bytes for virtual memory.
.RE

If no option is given,
.B -f
is assumed.
.RE

.sp
.ne 2
.mk
.na
\fBumask\fR [\fB-S\fR] [
.I mask
]\fR
.ad
.sp .6
.RS 4n
The user file-creation mask is set to
.I mask
(see
.BR umask (2)).
\fImask\fR can either be an octal number or a symbolic value as described in
.BR chmod (1).
If a symbolic value is given, the new
.B umask
value is
the complement of the result of applying
.I mask
to the complement of the
previous umask value. If
.I mask
is omitted, the current value of the
mask is printed. The
.B -S
flag produces symbolic output.
.RE

.sp
.ne 2
.mk
.na
.B unalias
.I name
\&.\|.\|.\fR
.ad
.br
.na
.B unalias -a
.ad
.sp .6
.RS 4n
The aliases given by the list of
.IR name s
are removed from the alias
list. The
.B -a
option removes all alias definitions from the current
execution environment.
.RE

.sp
.ne 2
.mk
.na
\fBunset\fR [ \fB-f\fR ]
.I name
\&.\|.\|.\fR
.ad
.sp .6
.RS 4n
The variables given by the list of
.IR name "s are unassigned, that is,"
their values and attributes are erased.
.B readonly
variables cannot be
unset. If the
.BR -f ,
flag is set, then the names refer to
.I function
names. Unsetting
.BR ERRNO ,
.BR LINENO ,
.BR MAILCHECK ,
.BR OPTARG ,
.BR OPTIND ,
.BR RANDOM ,
.BR SECONDS ,
.BR TMOUT ,
and
.B _
removes
their special meaning even if they are subsequently assigned to.
.RE

.sp
.ne 2
.mk
.na
\fB* wait\fR [
.I job
]\fR
.ad
.sp .6
.RS 4n
Waits for the specified
.I job
and report its termination status. If
\fIjob\fR is not given then all currently active child processes are waited
for. The exit status from this command is that of the process waited for.
See
.B Jobs
for a description of the format of
.IR job .
.RE

.sp
.ne 2
.mk
.na
\fBwhence\fR [ \fB-pv\fR ]
.I name
\&.\|.\|.\fR
.ad
.sp .6
.RS 4n
For each
.IR name ,
indicates how it would be interpreted if used as a
command name.
.sp
The
.B -v
flag produces a more verbose report.
.sp
The
.B -p
flag does a path search for
.I name
even if name is an
alias, a function, or a reserved word.
.RE

.SS "Invocation"
.sp
.LP
If the shell is invoked by
.BR exec (2),
and the first character of
argument zero (\fB$0\fR) is \fB\(mi\fR, then the shell is assumed to be a
\fBlogin\fR shell and commands are read from
.B /etc/profile
and then
from either \fB\&.profile\fR in the current directory or
.BR $HOME/.profile ,
if either file exists. Next, commands are read from
the file named by performing parameter substitution on the value of the
environment variable
.B ENV
if the file exists. If the
.B -s
flag is
not present and
.I arg
is, then a path search is performed on the first
\fIarg\fR to determine the name of the script to execute. The script
\fIarg\fR must have read permission and any
.B setuid
and \fBsetgid\fR
settings are ignored. If the script is not found on the path,
.I arg
is
processed as if it named a builtin command or function. Commands are then
read as described as follows. The following flags are interpreted by the
shell when it is invoked:
.sp
.ne 2
.mk
.na
.B -c
.ad
.RS 6n
.rt
Reads commands from the
.I command_string
operand. Sets the value of
special parameter
.B 0
from the value of the
.I command_name
operand
and the positional parameters
.RB ( $1 ,
.BR $2 ,
and so on) in sequence
from the remaining
.I arg
operands. No commands are read from the
standard input.
.RE

.sp
.ne 2
.mk
.na
.B -s
.ad
.RS 6n
.rt
If the
.B -s
flag is present or if no arguments remain, commands are
read from the standard input. Shell output, except for the output of the
\fBSpecial Commands\fR listed above, is written to file descriptor 2.
.RE

.sp
.ne 2
.mk
.na
.B -i
.ad
.RS 6n
.rt
If the
.B -i
flag is present or if the shell input and output are
attached to a terminal (as told by
.BR ioctl (2)),
then this shell is
.IR interactive .
In this case,
.B TERM
.RB "is ignored (so that" " kill"
\fB0\fR does not kill an interactive shell) and
.B INTR
is caught and
ignored (so that
.B wait
is interruptible). In all cases,
.B QUIT
is
ignored by the shell.
.RE

.sp
.ne 2
.mk
.na
.B -r
.ad
.RS 6n
.rt
If the
.B -r
flag is present the shell is a restricted shell.
.RE

.sp
.LP
The remaining flags and arguments are described under the
.B set
command
above.
.SS "rksh Only"
.sp
.LP
\fBrksh\fR is used to set up login names and execution environments whose
capabilities are more controlled than those of the standard shell. The
actions of
.B rksh
are identical to those of
.BR ksh ,
except that the
following are disallowed:
.RS +4
.TP
.ie t \(bu
.el o
changing directory (see
.BR cd (1))
.RE
.RS +4
.TP
.ie t \(bu
.el o
setting the value of
.BR SHELL ,
.BR ENV ,
or
.BR PATH
.RE
.RS +4
.TP
.ie t \(bu
.el o
specifying path or command names containing
.BR /
.RE
.RS +4
.TP
.ie t \(bu
.el o
.RB "redirecting output (" > ", " >| ,
.BR <> ,
and
.BR >> )
.RE
.RS +4
.TP
.ie t \(bu
.el o
changing group (see
.BR newgrp (1)).
.RE
.sp
.LP
The restrictions above are enforced after \fB\&.profile\fR and the
\fBENV\fR files are interpreted.
.sp
.LP
When a command to be executed is found to be a shell procedure,
.B rksh
invokes
.B ksh
to execute it. Thus, it is possible to provide to the
end-user shell procedures that have access to the full power of the standard
shell, while imposing a limited menu of commands; this scheme assumes that
the end-user does not have write and execute permissions in the same
directory.
.sp
.LP
The net effect of these rules is that the writer of the \fB\&.profile\fR
has complete control over user actions, by performing guaranteed setup
.RI "actions and leaving the user in an appropriate directory (probably" " not"
the login directory).
.sp
.LP
The system administrator often sets up a directory of commands (that is,
.BR /usr/rbin )
that can be safely invoked by
.BR rksh .
.SH ERRORS
.sp
.LP
Errors detected by the shell, such as syntax errors, cause the shell to
return a non-zero exit status. Otherwise, the shell returns the exit status
of the last command executed (see also the
.B exit
command above). If the
shell is being used non-interactively then execution of the shell file is
abandoned. Run time errors detected by the shell are reported by printing
the command or function name and the error condition. If the line number
that the error occurred on is greater than one, then the line number is also
printed in square brackets
.RB ( [] )
after the command or function name.
.sp
.LP
For a non-interactive shell, an error condition encountered by a special
built-in or other type of utility causes the shell to write a diagnostic
message to standard error and exit as shown in the following table:
.sp

.sp
.TS
tab() box;
cw(3.17i) cw(1.17i) cw(1.17i)
lw(3.17i) lw(1.17i) lw(1.17i)
.
ErrorSpecial Built-inOther Utilities
_
Shell language syntax errorexitsexits
T{
Utility syntax error (option or operand error)
T}exitsdoes not exit
Redirection errorexitsdoes not exit
Variable assignment errorexitsdoes not exit
Expansion errorexitsexits
Command not foundn/amight exit
Dot script not foundexitsn/a
.TE

.sp
.LP
An expansion error is one that occurs when the shell expansions are carried
out (for example,
.BR ${x!y} ,
because
.B !
is not a valid operator). An
implementation can treat these as syntax errors if it is able to detect them
during tokenization, rather than during expansion.
.sp
.LP
If any of the errors shown as "might exit" or "exits" occur in a subshell,
the subshell exits or might exit with a non-zero status, but the script
containing the subshell does not exit because of the error.
.sp
.LP
In all of the cases shown in the table, an interactive shell writes a
diagnostic message to standard error without exiting.
.SH USAGE
.sp
.LP
See
.BR largefile (5)
for the description of the behavior of
.B ksh
and
\fBrksh\fR when encountering files greater than or equal to 2 Gbyte (2^31
bytes).
.SH EXIT STATUS
.sp
.LP
Each command has an exit status that can influence the behavior of other
shell commands. The exit status of commands that are not utilities is
documented in this section. The exit status of the standard utilities is
documented in their respective sections.
.sp
.LP
If a command is not found, the exit status is
.BR 127 .
If the command
name is found, but it is not an executable utility, the exit status is
.BR 126 .
Applications that invoke utilities without using the shell should
use these exit status values to report similar errors.
.sp
.LP
If a command fails during word expansion or redirection, its exit status is
greater than zero.
.sp
.LP
When reporting the exit status with the special parameter
.BR ? ,
the
shell reports the full eight bits of exit status available. The exit status
of a command that terminated because it received a signal reported as
greater than
.BR 128 .
.SH FILES
.sp
.LP
.B /etc/profile
.sp
.LP
.B /etc/suid_profile
.sp
.LP
.B $HOME/.profile
.sp
.LP
.B /tmp/sh*
.sp
.LP
.B /dev/null
.SH ATTRIBUTES
.sp
.LP
See
.BR attributes (5)
for descriptions of the following attributes:
.SS "/usr/bin/ksh, /usr/bin/rksh"
.sp

.sp
.TS
tab() box;
cw(2.75i) |cw(2.75i)
lw(2.75i) |lw(2.75i)
.
ATTRIBUTE TYPEATTRIBUTE VALUE
_
AvailabilitySUNWcsu
_
CSIEnabled
.TE

.SS "/usr/xpg4/bin/sh"
.sp

.sp
.TS
tab() box;
cw(2.75i) |cw(2.75i)
lw(2.75i) |lw(2.75i)
.
ATTRIBUTE TYPEATTRIBUTE VALUE
_
AvailabilitySUNWxcu4
_
CSIEnabled
_
Interface StabilityStandard
.TE

.SH SEE ALSO
.sp
.LP
.BR cat (1),
.BR cd (1),
.BR chmod (1),
.BR cut (1),
.BR echo (1),
.BR env (1),
.BR getoptcvt (1),
.BR jobs (1),
.BR login (1),
.BR newgrp (1),
.BR paste (1),
.BR pfksh (1),
\fBpfexec\fR(1),
.BR ps (1),
.BR shell_builtins (1),
.BR stty (1),
.BR test (1),
.BR vi (1),
.BR dup (2),
.BR exec (2),
.BR fork (2),
\fBioctl\fR(2),
.BR lseek (2),
.BR pipe (2),
.BR ulimit (2),
.BR umask (2),
.BR rand (3C),
.BR signal (3C),
.BR signal.h (3HEAD),
.BR wait (3C),
.BR a.out (4),
.BR profile (4),
.BR attributes (5),
.BR environ (5),
.BR largefile (5),
\fBstandards\fR(5)
.sp
.LP
Morris I. Bolsky and David G. Korn, \fIThe KornShell Command and Programming Language\fR, Prentice Hall, 1989.
.SH WARNINGS
.sp
.LP
The use of
.B setuid
shell scripts is
.I strongly
discouraged.
.SH NOTES
.sp
.LP
If a command which is a
.I "tracked alias"
is executed, and then a command
with the same name is installed in a directory in the search path before the
directory where the original command was found, the shell continues to
\fBexec\fR the original command. Use the
.B -t
option of the \fBalias\fR
command to correct this situation.
.sp
.LP
Some very old shell scripts contain a
.B ^
as a synonym for the pipe
character
.BR | .
.sp
.LP
Using the
.B fc
built-in command within a compound command causes the
whole command to disappear from the history file.
.sp
.LP
The built-in command \fB\&.\fIfile\fR reads the whole file before any
commands are executed. Therefore,
.B alias
and
.B unalias
commands in
the file does not apply to any functions defined in the file.
.sp
.LP
When the shell executes a shell script that attempts to execute a
non-existent command interpreter, the shell returns an erroneous diagnostic
message that the shell script file does not exist.
