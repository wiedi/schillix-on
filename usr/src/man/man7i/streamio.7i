'\" te
.\" Copyright (c) 2009, Sun Microsystems, Inc.  All Rights Reserved.
.\" Copyright 1989 AT&T
.\" CDDL HEADER START
.\"
.\" The contents of this file are subject to the terms of the
.\" Common Development and Distribution License (the "License").
.\" You may not use this file except in compliance with the License.
.\"
.\" You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
.\" or http://www.opensolaris.org/os/licensing.
.\" See the License for the specific language governing permissions
.\" and limitations under the License.
.\"
.\" When distributing Covered Code, include this CDDL HEADER in each
.\" file and include the License file at usr/src/OPENSOLARIS.LICENSE.
.\" If applicable, add the following below this CDDL HEADER, with the
.\" fields enclosed by brackets "[]" replaced with your own identifying
.\" information: Portions Copyright [yyyy] [name of copyright owner]
.\"
.\" CDDL HEADER END
.TH streamio 7I "8 Apr 2009" "SunOS 5.11" "Ioctl Requests"
.SH NAME
streamio \- STREAMS ioctl commands
.SH SYNOPSIS
.LP
.nf
#include <sys/types.h>
#include <stropts.h>
#include <sys/conf.h>

\fBint\fR \fBioctl\fR(\fBint\fR \fIfildes\fR, \fBint\fR \fIcommand\fR, \fB\&.\|.\|. /*arg*/\fR);
.fi

.SH DESCRIPTION
.sp
.LP
STREAMS (see
.BR Intro (3))
\fBioctl\fR commands are a subset of the
.BR ioctl (2)
commands and perform a variety of control functions on
streams.
.sp
.LP
The \fIfildes\fR argument is an open file descriptor that refers to a
stream. The
.I command
argument determines the control function to be
performed as described below. The
.I arg
argument represents additional
information that is needed by this command. The type of
.I arg
depends
upon the command, but it is generally an integer or a pointer to a
command-specific data structure.  The
.I command
and
.I arg
arguments
are interpreted by the STREAM head. Certain combinations of these arguments
may be passed to a module or driver in the stream.
.sp
.LP
Since these STREAMS commands are
.BR ioctls ,
they are subject to the
errors described in
.BR ioctl (2).
In addition to those errors, the call
will fail with
.B errno
set to
.B EINVAL,
without processing a control
function, if the STREAM referenced by \fIfildes\fR is linked below a
multiplexor, or if
.I command
is not a valid value for a stream.
.sp
.LP
Also, as described in
.BR ioctl (2),
STREAMS modules and drivers can detect
errors. In this case, the module or driver sends an error message to the
STREAM head containing an error value. This causes subsequent calls to fail
with
.B errno
set to this value.
.SH IOCTLS
.sp
.LP
The following
.B ioctl
commands, with error values indicated, are
applicable to all STREAMS files:
.sp
.ne 2
.mk
.na
.B I_PUSH
.ad
.RS 15n
.rt
Pushes the module whose name is pointed to by
.I arg
onto the top of the
current stream, just below the STREAM head. If the STREAM is a pipe, the
module will be inserted between the stream heads of both ends of the pipe. It
then calls the open routine of the newly-pushed module. On failure,
\fBerrno\fR is set to one of the following values:
.sp
.ne 2
.mk
.na
.B EINVAL
.ad
.RS 11n
.rt
Invalid module name.
.RE

.sp
.ne 2
.mk
.na
.B EFAULT
.ad
.RS 11n
.rt
\fIarg\fR points outside the allocated address space.
.RE

.sp
.ne 2
.mk
.na
.B ENXIO
.ad
.RS 11n
.rt
Open routine of new module failed.
.RE

.sp
.ne 2
.mk
.na
.B ENXIO
.ad
.RS 11n
.rt
Hangup received on \fIfildes\fR.
.RE

.sp
.ne 2
.mk
.na
.B ENOTSUP
.ad
.RS 11n
.rt
Pushing a module is not supported on this stream.
.RE

.RE

.sp
.ne 2
.mk
.na
.B I_POP
.ad
.RS 15n
.rt
Removes the module just below the STREAM head of the STREAM pointed to by
\fIfildes\fR. To remove a module from a pipe requires that the module was
pushed on the side it is being removed from.
.I arg
should be 
.B 0
in
an
.B I_POP
request. On failure,
.B errno
is set to one of the
following values:
.sp
.ne 2
.mk
.na
.B EINVAL
.ad
.RS 11n
.rt
No module present in the stream.
.RE

.sp
.ne 2
.mk
.na
.B ENXIO
.ad
.RS 11n
.rt
Hangup received on \fIfildes\fR.
.RE

.sp
.ne 2
.mk
.na
.B EPERM
.ad
.RS 11n
.rt
Attempt to pop through an anchor by an unprivileged process.
.RE

.sp
.ne 2
.mk
.na
.B ENOTSUP
.ad
.RS 11n
.rt
Removal is not supported.
.RE

.RE

.sp
.ne 2
.mk
.na
.B I_ANCHOR
.ad
.RS 15n
.rt
Positions the stream anchor to be at the stream's module directly below the
stream head. Once this has been done, only a privileged process may pop
modules below the anchor on the stream.
.I arg
must be
.B 0
in an
\fBI_ANCHOR\fR request. On failure, \fBerrno\fR is set to the following
value:
.sp
.ne 2
.mk
.na
.B EINVAL
.ad
.RS 10n
.rt
Request to put an anchor on a pipe.
.RE

.RE

.sp
.ne 2
.mk
.na
.B I_LOOK
.ad
.RS 15n
.rt
Retrieves the name of the module just below the stream head of the stream
pointed to by
.IR fildes ,
and places it in a null terminated character
string pointed at by
.IR arg .
The buffer pointed to by
.I arg
should be
at least
.BR FMNAMESZ "+1 bytes long. This requires the declaration"
\fB#include <sys/conf.h>\fR. On failure, \fBerrno\fR is set to one of the
following values:
.sp
.ne 2
.mk
.na
.B EFAULT
.ad
.RS 10n
.rt
\fIarg\fR points outside the allocated address space.
.RE

.sp
.ne 2
.mk
.na
.B EINVAL
.ad
.RS 10n
.rt
No module present in stream.
.RE

.RE

.sp
.ne 2
.mk
.na
.B I_FLUSH
.ad
.RS 15n
.rt
This request flushes all input and/or output queues, depending on the value
of
.IR arg .
Legal
.I arg
values are:
.sp
.ne 2
.mk
.na
.B FLUSHR
.ad
.RS 11n
.rt
Flush read queues.
.RE

.sp
.ne 2
.mk
.na
.B FLUSHW
.ad
.RS 11n
.rt
Flush write queues.
.RE

.sp
.ne 2
.mk
.na
.B FLUSHRW
.ad
.RS 11n
.rt
Flush read and write queues.
.RE

If a pipe or FIFO does not have any modules pushed, the read queue of the
stream head on either end is flushed depending on the value of
.IR arg .
.sp
If
.B FLUSHR
is set and \fIfildes\fR is a pipe, the read queue for that
end of the pipe is flushed and the write queue for the other end is flushed.
If \fIfildes\fR is a FIFO, both queues are flushed.
.sp
If
.B FLUSHW
is set and \fIfildes\fR is a pipe and the other end of the
pipe exists, the read queue for the other end of the pipe is flushed and the
write queue for this end is flushed. If \fIfildes\fR is a FIFO, both queues
of the FIFO are flushed.
.sp
If
.B FLUSHRW
is set, all read queues are flushed, that is, the read
queue for the FIFO and the read queue on both ends of the pipe are flushed.
.sp
Correct flush handling of a pipe or FIFO with modules pushed is achieved via
the
.B pipemod
module.  This module should be the first module pushed onto
a pipe so that it is at the midpoint of the pipe itself.
.sp
On failure,
.B errno
is set to one of the following values:
.sp
.ne 2
.mk
.na
.B ENOSR
.ad
.RS 10n
.rt
Unable to allocate buffers for flush message due to insufficient stream
memory resources.
.RE

.sp
.ne 2
.mk
.na
.B EINVAL
.ad
.RS 10n
.rt
Invalid
.I arg
value.
.RE

.sp
.ne 2
.mk
.na
.B ENXIO
.ad
.RS 10n
.rt
Hangup received on \fIfildes\fR.
.RE

.RE

.sp
.ne 2
.mk
.na
.B I_FLUSHBAND
.ad
.RS 15n
.rt
Flushes a particular band of messages.
.I arg
points to a \fBbandinfo\fR
structure that has the following members:
.sp
.in +2
.nf
unsigned char bi_pri;
int bi_flag;
.fi
.in -2

The \fBbi_flag\fR field may be one of
.BR FLUSHR ,
.BR FLUSHW ,
or
\fBFLUSHRW\fR as described earlier.
.RE

.sp
.ne 2
.mk
.na
.B I_SETSIG
.ad
.RS 15n
.rt
Informs the stream head that the user wishes the kernel to issue the
\fBSIGPOLL\fR signal (see \fBsignal\fR(3C)) when a particular event has
occurred on the stream associated with
.IR fildes .
\fBI_SETSIG\fR supports
an asynchronous processing capability in streams. The value of
.I arg
is a
bitmask that specifies the events for which the user should be signaled. It
is the bitwise OR of any combination of the following constants:
.sp
.ne 2
.mk
.na
.B S_INPUT
.ad
.RS 13n
.rt
Any message other than an
.B M_PCPROTO
has arrived on a stream head read
queue. This event is maintained for compatibility with previous releases.
This event is triggered even if the message is of zero length.
.RE

.sp
.ne 2
.mk
.na
.B S_RDNORM
.ad
.RS 13n
.rt
An ordinary (non-priority) message has arrived on a stream head read queue.
This event is triggered even if the message is of zero length.
.RE

.sp
.ne 2
.mk
.na
.B S_RDBAND
.ad
.RS 13n
.rt
A priority band message (band > 0) has arrived on a stream head read queue.
This event is triggered even if the message is of zero length.
.RE

.sp
.ne 2
.mk
.na
.B S_HIPRI
.ad
.RS 13n
.rt
A high priority message is present on the stream head read queue. This event
is triggered even if the message is of zero length.
.RE

.sp
.ne 2
.mk
.na
.B S_OUTPUT
.ad
.RS 13n
.rt
The write queue just below the stream head is no longer full. This notifies
the user that there is room on the queue for sending (or writing) data
downstream.
.RE

.sp
.ne 2
.mk
.na
.B S_WRNORM
.ad
.RS 13n
.rt
This event is the same as
.BR S_OUTPUT .
.RE

.sp
.ne 2
.mk
.na
.B S_WRBAND
.ad
.RS 13n
.rt
A priority band greater than 0 of a queue downstream exists and is writable.
This notifies the user that there is room on the queue for sending (or
writing) priority data downstream.
.RE

.sp
.ne 2
.mk
.na
.B S_MSG
.ad
.RS 13n
.rt
A STREAMS signal message that contains the
.B SIGPOLL
signal has reached
the front of the stream head read queue.
.RE

.sp
.ne 2
.mk
.na
.B S_ERROR
.ad
.RS 13n
.rt
An
.B M_ERROR
message has reached the stream head.
.RE

.sp
.ne 2
.mk
.na
.B S_HANGUP
.ad
.RS 13n
.rt
An
.B M_HANGUP
message has reached the stream head.
.RE

.sp
.ne 2
.mk
.na
.B S_BANDURG
.ad
.RS 13n
.rt
When used in conjunction with
.BR S_RDBAND ,
\fBSIGURG\fR is generated
instead of
.B SIGPOLL
when a priority message reaches the front of the
stream head read queue.
.RE

A user process may choose to be signaled only of high priority messages by
setting the
.I arg
bitmask to the value
.BR S_HIPRI .
.sp
Processes that wish to receive
.B SIGPOLL
signals must explicitly
register to receive them using
.BR I_SETSIG .
If several processes register
to receive this signal for the same event on the same stream, each process
will be signaled when the event occurs.
.sp
If the value of
.I arg
is zero, the calling process will be unregistered
and will not receive further
.B SIGPOLL
signals.  On failure, \fBerrno\fR
is set to one of the following values:
.sp
.ne 2
.mk
.na
.B EINVAL
.ad
.RS 10n
.rt
\fIarg\fR value is invalid or \fIarg\fR is zero and process is not
registered to receive the
.B SIGPOLL
signal.
.RE

.sp
.ne 2
.mk
.na
.B EAGAIN
.ad
.RS 10n
.rt
Allocation of a data structure to store the signal request failed.
.RE

.RE

.sp
.ne 2
.mk
.na
.B I_GETSIG
.ad
.RS 15n
.rt
Returns the events for which the calling process is currently registered to
be sent a
.B SIGPOLL
signal.  The events are returned as a bitmask pointed
to by
.IR arg ,
where the events are those specified in the description of
\fBI_SETSIG\fR above. On failure, \fBerrno\fR is set to one of the following
values:
.sp
.ne 2
.mk
.na
.B EINVAL
.ad
.RS 10n
.rt
Process not registered to receive the
.B SIGPOLL
signal.
.RE

.sp
.ne 2
.mk
.na
.B EFAULT
.ad
.RS 10n
.rt
\fIarg\fR points outside the allocated address space.
.RE

.RE

.sp
.ne 2
.mk
.na
.B I_FIND
.ad
.RS 15n
.rt
Compares the names of all modules currently present in the stream to the
name pointed to by
.IR arg ,
and returns 1 if the named module is present in
the stream. It returns 0 if the named module is not present. On failure,
\fBerrno\fR is set to one of the following values:
.sp
.ne 2
.mk
.na
.B EFAULT
.ad
.RS 10n
.rt
\fIarg\fR points outside the allocated address space.
.RE

.sp
.ne 2
.mk
.na
.B EINVAL
.ad
.RS 10n
.rt
\fIarg\fR does not contain a valid module name.
.RE

.RE

.sp
.ne 2
.mk
.na
.B I_PEEK
.ad
.RS 15n
.rt
Allows a user to retrieve the information in the first message on the stream
head read queue without taking the message off the queue.
.B I_PEEK
is
analogous to
.BR getmsg (2)
except that it does not remove the message from
the queue.
.I arg
points to a
.B strpeek
structure, which contains the
following members:
.sp
.in +2
.nf
struct strbuf ctlbuf;
struct strbuf	databuf;
long flags;
.fi
.in -2

The
.B maxlen
field in the \fBctlbuf\fR and \fBdatabuf strbuf\fR
structures (see
.BR getmsg (2))
must be set to the number of bytes of
control information and/or data information, respectively, to retrieve.
\fBflags\fR may be set to \fBRS_HIPRI\fR or
.BR 0 .
If
.B RS_HIPRI
is
set,
.B I_PEEK
will look for a high priority message on the stream head
read queue. Otherwise,
.B I_PEEK
will look for the first message on the
stream head read queue.
.sp
\fBI_PEEK\fR returns \fB1\fR if a message was retrieved, and returns \fB0\fR
if no message was found on the stream head read queue. It does not wait for a
message to arrive. On return, \fBctlbuf\fR specifies information in the
control buffer, \fBdatabuf\fR specifies information in the data buffer, and
\fBflags\fR contains the value \fBRS_HIPRI\fR or
.BR 0 .
On failure,
\fBerrno\fR is set to the following value:
.sp
.ne 2
.mk
.na
.B EFAULT
.ad
.RS 11n
.rt
\fIarg\fR points, or the buffer area specified in \fBctlbuf\fR or
\fBdatabuf\fR is, outside the allocated address space.
.RE

.sp
.ne 2
.mk
.na
.B EBADMSG
.ad
.RS 11n
.rt
Queued message to be read is not valid for
.BR I_PEEK .
.RE

.sp
.ne 2
.mk
.na
.B EINVAL
.ad
.RS 11n
.rt
Illegal value for \fBflags\fR.
.RE

.sp
.ne 2
.mk
.na
.B ENOSR
.ad
.RS 11n
.rt
Unable to allocate buffers to perform the I_PEEK due to insufficient STREAMS
memory resources.
.RE

.RE

.sp
.ne 2
.mk
.na
.B I_SRDOPT
.ad
.RS 15n
.rt
Sets the read mode (see
.BR read (2))
using the value of the argument
.IR arg .
Legal
.I arg
values are:
.sp
.ne 2
.mk
.na
.B RNORM
.ad
.RS 9n
.rt
Byte-stream mode, the default.
.RE

.sp
.ne 2
.mk
.na
.B RMSGD
.ad
.RS 9n
.rt
Message-discard mode.
.RE

.sp
.ne 2
.mk
.na
.B RMSGN
.ad
.RS 9n
.rt
Message-nondiscard mode.
.RE

In addition, the stream head's treatment of control messages may be changed
by setting the following flags in
.IR arg :
.sp
.ne 2
.mk
.na
.B RPROTNORM
.ad
.RS 13n
.rt
Reject
.B read()
with
.B EBADMSG
if a control message is at the front
of the stream head read queue.
.RE

.sp
.ne 2
.mk
.na
.B RPROTDAT
.ad
.RS 13n
.rt
Deliver the control portion of a message as data when a user issues
.BR read() .
This is the default behavior.
.RE

.sp
.ne 2
.mk
.na
.B RPROTDIS
.ad
.RS 13n
.rt
Discard the control portion of a message, delivering any data portion, when
a user issues a \fBread\fR(\|).
.RE

On failure,
.B errno
is set to the following value:
.sp
.ne 2
.mk
.na
.B EINVAL
.ad
.RS 10n
.rt
\fIarg\fR is not one of the above legal values, or \fIarg\fR is the bitwise
inclusive
.B OR
of
.B RMSGD
and
.BR RMSGN .
.RE

.RE

.sp
.ne 2
.mk
.na
.B I_GRDOPT
.ad
.RS 15n
.rt
Returns the current read mode setting in an
.B int
pointed to by the
argument
.IR arg .
Read modes are described in
.BR read (\|).
On failure,
\fBerrno\fR is set to the following value:
.sp
.ne 2
.mk
.na
.B EFAULT
.ad
.RS 10n
.rt
\fIarg\fR points outside the allocated address space.
.RE

.RE

.sp
.ne 2
.mk
.na
.B I_NREAD
.ad
.RS 15n
.rt
Counts the number of data bytes in data blocks in the first message on the
stream head read queue, and places this value in the location pointed to by
.IR arg .
The return value for the command is the number of messages on the
stream head read queue. For example, if zero is returned in
.IR arg ,
but
the
.B ioctl
return value is greater than zero, this indicates that a
zero-length message is next on the queue. On failure,
.B errno
is set to
the following value:
.sp
.ne 2
.mk
.na
.B EFAULT
.ad
.RS 10n
.rt
\fIarg\fR points outside the allocated address space.
.RE

.RE

.sp
.ne 2
.mk
.na
.B I_FDINSERT
.ad
.RS 15n
.rt
Creates a message from specified buffer(s), adds information about another
stream and sends the message downstream. The message contains a control part
and an optional data part. The data and control parts to be sent are
distinguished by placement in separate buffers, as described below.
.sp
The
.I arg
argument points to a \fBstrfdinsert\fR structure, which
contains the following members:
.sp
.in +2
.nf
struct  strbuf  ctlbuf;
struct  strbuf	databuf;
t_uscalar_t  flags;
int  fildes;
int  offset;
.fi
.in -2

The
.B len
member in the \fBctlbuf strbuf\fR structure (see
.BR putmsg (2))
must be set to the size of a 
.B t_uscalar_t
plus the
number of bytes of control information to be sent with the message. The
\fBfildes\fR member specifies the file descriptor of the other stream, and
the \fBoffset\fR member, which must be suitably aligned for use as a
.BR t_uscalar_t ,
specifies the offset from the start of the control buffer
where
.B I_FDINSERT
will store a 
.B t_uscalar_t
whose interpretation
is specific to the stream end. The
.B len
member in the \fBdatabuf
strbuf\fR structure must be set to the number of bytes of data information to
be sent with the message, or to 0 if no data part is to be sent.
.sp
The \fBflags\fR member specifies the type of message to be created. A normal
message is created if \fBflags\fR is set to 0, and a high-priority message is
created if \fBflags\fR is set to
.BR RS_HIPRI .
For non-priority messages,
\fBI_FDINSERT\fR will block if the stream write queue is full due to internal
flow control conditions. For priority messages, 
.B I_FDINSERT
does not
block on this condition. For non-priority messages, 
.B I_FDINSERT
does
not block when the write queue is full and 
.B O_NDELAY
or
\fBO_NONBLOCK\fR is set. Instead, it fails and sets \fBerrno\fR to
.BR EAGAIN .
.sp
\fBI_FDINSERT\fR also blocks, unless prevented by lack of internal
resources, waiting for the availability of message blocks in the stream,
regardless of priority or whether
.B O_NDELAY
or
.B O_NONBLOCK
has been
specified. No partial message is sent.
.sp
The
.B ioctl()
function with the
.B I_FDINSERT
command will fail if:
.sp
.ne 2
.mk
.na
.B EAGAIN
.ad
.RS 10n
.rt
A non-priority message is specified, the
.B O_NDELAY
or
.BR O_NONBLOCK
flag is set, and the stream write queue is full due to internal flow control
conditions.
.RE

.sp
.ne 2
.mk
.na
.B ENOSR
.ad
.RS 10n
.rt
Buffers can not be allocated for the message that is to be created.
.RE

.sp
.ne 2
.mk
.na
.B EFAULT
.ad
.RS 10n
.rt
The
.I arg
argument points, or the buffer area specified in \fBctlbuf\fR
or \fBdatabuf\fR is, outside the allocated address space.
.RE

.sp
.ne 2
.mk
.na
.B EINVAL
.ad
.RS 10n
.rt
One of the following: The \fBfildes\fR member of the \fBstrfdinsert\fR
structure is not a valid, open stream file descriptor; the size of a
\fBt_uscalar_t\fR plus \fBoffset\fR is greater than the \fBlen\fR member for
the buffer specified through
.BR ctlptr ;
the \fBoffset\fR member does not
specify a properly-aligned location in the data buffer; or an undefined value
is stored in \fBflags\fR.
.RE

.sp
.ne 2
.mk
.na
.B ENXIO
.ad
.RS 10n
.rt
Hangup received on the \fBfildes\fR argument of the
.B ioctl
call or the
\fBfildes\fR member of the \fBstrfdinsert\fR structure.
.RE

.sp
.ne 2
.mk
.na
.B ERANGE
.ad
.RS 10n
.rt
The
.B len
field for the buffer specified through \fBdatabuf\fR does not
fall within the range specified by the maximum and minimum packet sizes of
the topmost stream module; or the
.B len
member for the buffer specified
through \fBdatabuf\fR is larger than the maximum configured size of the data
part of a message; or the
.B len
member for the buffer specified through
\fBctlbuf\fR is larger than the maximum configured size of the control part
of a message.
.RE

\fBI_FDINSERT\fR can also fail if an error message was received by the
stream head of the stream corresponding to the \fBfildes\fR member of the
\fBstrfdinsert\fR structure. In this case, \fBerrno\fR will be set to the
value in the message.
.RE

.sp
.ne 2
.mk
.na
.B I_STR
.ad
.RS 15n
.rt
Constructs an internal
.B STREAMS
ioctl message from the data pointed to
by
.IR arg ,
and sends that message downstream.
.sp
This mechanism is provided to send user
.B ioctl
requests to downstream
modules and drivers. It allows information to be sent with the \fBioctl\fR,
and will return to the user any information sent upstream by the downstream
recipient.
.B I_STR
blocks until the system responds with either a
positive or negative acknowledgement message, or until the request times out
after some period of time. If the request times out, it fails with
\fBerrno\fR set to \fBETIME\fR.
.sp
To send requests downstream,
.I arg
must point to a
.BR strioctl
structure which contains the following members:
.sp
.in +2
.nf
int  ic_cmd;
int  ic_timout;
int  ic_len;
char  *ic_dp;
.fi
.in -2

\fBic_cmd\fR is the internal \fBioctl\fR command intended for a downstream
module or driver and
.B ic_timout
is the number of seconds (-1 = infinite,
0 = use default, >0 = as specified) an \fBI_STR\fR request will wait for
acknowledgement before timing out.
.B ic_len
is the number of bytes in the
data argument and
.B ic_dp
is a pointer to the data argument. The
\fBic_len\fR field has two uses: on input, it contains the length of the data
argument passed in, and on return from the command, it contains the number of
bytes being returned to the user (the buffer pointed to by
.B ic_dp
should
be large enough to contain the maximum amount of data that any module or the
driver in the stream can return).
.sp
At most one
.B I_STR
.RB "can be active on a stream.  Further" " I_STR"
calls will block until the active
.B I_STR
completes via  a  positive  or
negative acknowlegment, a timeout, or an error condition at the stream head.
By setting  the
.B ic_timout
field  to  0, the  user is requesting
STREAMS to provide  the 
.B DEFAULT
timeout. The default timeout is
specific to the STREAMS implementation and may vary depending on which
release of Solaris you are using. For Solaris 8 (and earlier versions), the
default timeout is fifteen seconds. The
.B O_NDELAY
and
.BR O_NONBLOCK
(see
.BR open (2))
flags have no effect on this call.
.sp
The stream head will convert the information pointed to by the
\fBstrioctl\fR structure to an internal \fBioctl\fR command message and send
it downstream. On failure,
.B errno
is set to one of the following
values:
.sp
.ne 2
.mk
.na
.B ENOSR
.ad
.RS 10n
.rt
Unable to allocate buffers for the
.B ioctl
message due to insufficient
STREAMS memory resources.
.RE

.sp
.ne 2
.mk
.na
.B EFAULT
.ad
.RS 10n
.rt
Either
.I arg
points outside the allocated address space, or the buffer
area specified by
.B ic_dp
and
.B ic_len
(separately for data sent and
data returned) is outside the allocated address space.
.RE

.sp
.ne 2
.mk
.na
.B EINVAL
.ad
.RS 10n
.rt
\fBic_len\fR is less than 0 or \fBic_len\fR is larger than the maximum
configured size of the data part of a message or
.B ic_timout
is less than
-1.
.RE

.sp
.ne 2
.mk
.na
.B ENXIO
.ad
.RS 10n
.rt
Hangup received on \fIfildes\fR.
.RE

.sp
.ne 2
.mk
.na
.B ETIME
.ad
.RS 10n
.rt
A downstream
.B ioctl
timed out before acknowledgement was received.
.RE

An
.B I_STR
can also fail while waiting for an acknowledgement if a
message indicating an error or a hangup is received at the stream head. In
addition, an error code can be returned in the positive or negative
acknowledgement message, in the event the ioctl command sent downstream
fails. For these cases,
.B I_STR
will fail with
.B errno
set to the
value in the message.
.RE

.sp
.ne 2
.mk
.na
.B I_SWROPT
.ad
.RS 15n
.rt
Sets the write mode using the value of the argument
.IR arg .
Legal bit
settings for
.I arg
are:
.sp
.ne 2
.mk
.na
.B SNDZERO
.ad
.RS 11n
.rt
Send a zero-length message downstream when a write of 0 bytes occurs.
.RE

To not send a zero-length message when a write of 0 bytes occurs, this bit
must not be set in
.IR arg .
.sp
On failure,
.B errno
may be set to the following value:
.sp
.ne 2
.mk
.na
.B EINVAL
.ad
.RS 10n
.rt
\fIarg\fR is not the above legal value.
.RE

.RE

.sp
.ne 2
.mk
.na
.B I_GWROPT
.ad
.RS 15n
.rt
.RB "Returns the current write mode setting, as described above, in the" " int"
that is pointed to by the argument
.IR arg .
.RE

.sp
.ne 2
.mk
.na
.B I_SENDFD
.ad
.RS 15n
.rt
Requests the stream associated with \fIfildes\fR to send a message,
containing a file pointer, to the stream head at the other end of a stream
pipe. The file pointer corresponds to
.IR arg ,
which must be an open file
descriptor.
.sp
\fBI_SENDFD\fR converts \fIarg\fR into the corresponding system file
pointer. It allocates a message block and inserts the file pointer in the
block. The user id and group id associated with the sending process are also
inserted. This message is placed directly on the read queue (see
.BR Intro (3))
of the stream head at the other end of the stream pipe to
which it is connected.  On failure,
.B errno
is set to one of the
following values:
.sp
.ne 2
.mk
.na
.B EAGAIN
.ad
.RS 10n
.rt
The sending stream is unable to allocate a message block to contain the file
pointer.
.RE

.sp
.ne 2
.mk
.na
.B EAGAIN
.ad
.RS 10n
.rt
The read queue of the receiving stream head is full and cannot accept the
message sent by
.BR I_SENDFD.
.RE

.sp
.ne 2
.mk
.na
.B EBADF
.ad
.RS 10n
.rt
\fIarg\fR is not a valid, open file descriptor.
.RE

.sp
.ne 2
.mk
.na
.B EINVAL
.ad
.RS 10n
.rt
\fIfildes\fR is not connected to a stream pipe.
.RE

.sp
.ne 2
.mk
.na
.B ENXIO
.ad
.RS 10n
.rt
Hangup received on \fIfildes\fR.
.RE

.RE

.sp
.ne 2
.mk
.na
.B I_RECVFD
.ad
.RS 15n
.rt
Retrieves the file descriptor associated with the message sent by an
\fBI_SENDFD ioctl\fR over a stream pipe. \fIarg\fR is a pointer to a
data buffer large enough to hold an \fBstrrecvfd\fR data structure containing
the following members:
.sp
.in +2
.nf
int  fd;
uid_t  uid;
gid_t  gid;
.fi
.in -2

\fBfd\fR is an integer file descriptor. \fBuid\fR and \fBgid\fR are the user
id and group id, respectively, of the sending stream.
.sp
If
.B O_NDELAY
and
.B O_NONBLOCK
are clear (see \fBopen\fR(2)),
\fBI_RECVFD\fR will block until a message is present at the stream head. If
\fBO_NDELAY\fR or \fBO_NONBLOCK\fR is set, \fBI_RECVFD\fR will fail with
\fBerrno\fR set to \fBEAGAIN\fR if no message is present at the stream
head.
.sp
If the message at the stream head is a message sent by an
.BR I_SENDFD ,
a
new user file descriptor is allocated for the file pointer contained in the
message. The new file descriptor is placed in the \fBfd\fR field of the
\fBstrrecvfd\fR structure. The structure is copied into the user data buffer
pointed to by
.IR arg .
On failure,
.B errno
is set to one of the
following values:
.sp
.ne 2
.mk
.na
.B EAGAIN
.ad
.RS 13n
.rt
A message is not present at the stream head read queue, and the
\fBO_NDELAY\fR or \fBO_NONBLOCK\fR flag is set.
.RE

.sp
.ne 2
.mk
.na
.B EBADMSG
.ad
.RS 13n
.rt
The message at the stream head read queue is not a message containing a
passed file descriptor.
.RE

.sp
.ne 2
.mk
.na
.B EFAULT
.ad
.RS 13n
.rt
\fIarg\fR points outside the allocated address space.
.RE

.sp
.ne 2
.mk
.na
.B EMFILE
.ad
.RS 13n
.rt
\fBNOFILES\fR file descriptors are currently open.
.RE

.sp
.ne 2
.mk
.na
.B ENXIO
.ad
.RS 13n
.rt
Hangup received on \fIfildes\fR.
.RE

.sp
.ne 2
.mk
.na
.B EOVERFLOW
.ad
.RS 13n
.rt
\fIuid\fR or \fIgid\fR is too large to be stored in the structure pointed to
by
.IR arg .
.RE

.RE

.sp
.ne 2
.mk
.na
.B I_LIST
.ad
.RS 15n
.rt
Allows the user to list all the module names on the stream, up to and
including the topmost driver name. If
.I arg
is
.IR NULL ,
the return
value is the number of modules, including the driver, that are on the stream
pointed to by
.IR fildes .
This allows the user to allocate enough space for
the module names. If
.I arg
is non-null, it should point to an
\fBstr_list\fR structure that has the following members:
.sp
.in +2
.nf
int sl_nmods;
struct  str_mlist  *sl_modlist;
.fi
.in -2

The
.B str_mlist
structure has the following member:
.sp
.in +2
.nf
char l_name[FMNAMESZ+1];
.fi
.in -2

The
.B sl_nmods
member indicates the number of entries the process has
allocated in the array.  Upon return, the
.B sl_modlist
member of the
\fBstr_list\fR structure contains the list of module names, and the number of
entries that have been filled into the
.B sl_modlist
array is found in the
\fBsl_nmods\fR member (the number includes the number of modules including
the driver).  The return value from
.B ioctl()
is 0.  The entries are
filled in starting at the top of the stream and continuing downstream until
either the end of the stream is reached, or the number of requested modules
(\fBsl_nmods\fR) is satisfied. On failure, \fBerrno\fR may be set to one of
the following values:
.sp
.ne 2
.mk
.na
.B EINVAL
.ad
.RS 10n
.rt
The
.B sl_nmods
member is less than 1.
.RE

.sp
.ne 2
.mk
.na
.B EAGAIN
.ad
.RS 10n
.rt
Unable to allocate buffers
.RE

.RE

.sp
.ne 2
.mk
.na
.B I_ATMARK
.ad
.RS 15n
.rt
Allows the user to see if the current message on the stream head read queue
is ``marked'' by some module downstream.
.I arg
determines how the
checking is done when there may be multiple marked messages on the stream
head read queue. It may take the following values:
.sp
.ne 2
.mk
.na
.B ANYMARK
.ad
.RS 12n
.rt
Check if the message is marked.
.RE

.sp
.ne 2
.mk
.na
.B LASTMARK
.ad
.RS 12n
.rt
Check if the message is the last one marked on the queue.
.RE

The return value is
.B 1
if the mark condition is satisfied and
.BR 0
otherwise. On failure,
.B errno
is set to the following value:
.sp
.ne 2
.mk
.na
.B EINVAL
.ad
.RS 10n
.rt
Invalid
.I arg
value.
.RE

.RE

.sp
.ne 2
.mk
.na
.B I_CKBAND
.ad
.RS 15n
.rt
Check if the message of a given priority band exists on the stream head read
queue. This returns
.B 1
if a message of a given priority exists, \fB0\fR
if not, or \fB\(mi1\fR on error.
.I arg
should be an integer containing
the value of the priority band in question. On failure,
.B errno
is set to
the following value:
.sp
.ne 2
.mk
.na
.B EINVAL
.ad
.RS 10n
.rt
Invalid
.I arg
value.
.RE

.RE

.sp
.ne 2
.mk
.na
.B I_GETBAND
.ad
.RS 15n
.rt
Returns the priority band of the first message on the stream head read queue
in the integer referenced by
.IR arg .
On failure,
.B errno
is set to the
following value:
.sp
.ne 2
.mk
.na
.B ENODATA
.ad
.RS 11n
.rt
No message on the stream head read queue.
.RE

.RE

.sp
.ne 2
.mk
.na
.B I_CANPUT
.ad
.RS 15n
.rt
Check if a certain band is writable.
.I arg
is set to the priority band
in question. The return value is
.B 0
if the priority band
.I arg
is
flow controlled,
.B 1
if the band is writable, or \fB\(mi1\fR on error. On
failure,
.B errno
is set to the following value:
.sp
.ne 2
.mk
.na
.B EINVAL
.ad
.RS 10n
.rt
Invalid
.I arg
value.
.RE

.RE

.sp
.ne 2
.mk
.na
.B I_SETCLTIME
.ad
.RS 15n
.rt
Allows the user to set the time the stream head will delay when a stream is
closing and there are data on the write queues.  Before closing each module
and driver, the stream head will delay for the specified amount of time to
allow the data to drain. Note, however, that the module or driver may itself
delay in its close routine; this delay is independent of the stream head's
delay and is not settable. If, after the delay, data are still present, data
will be flushed.
.I arg
is a pointer to an integer containing the number
of milliseconds to delay, rounded up to the nearest legal value on the
system. The default is fifteen seconds. On failure,
.B errno
is set to the
following value:
.sp
.ne 2
.mk
.na
.B EINVAL
.ad
.RS 10n
.rt
Invalid
.I arg
value.
.RE

.RE

.sp
.ne 2
.mk
.na
.B I_GETCLTIME
.ad
.RS 15n
.rt
Returns the close time delay in the integer pointed by
.IR arg .
.RE

.sp
.ne 2
.mk
.na
.B I_SERROPT
.ad
.RS 15n
.rt
Sets the error mode using the value of the argument
.IR arg .
.sp
Normally stream head errors are persistent; once they are set due to an
\fBM_ERROR\fR or
.BR M_HANGUP ,
the error condition will remain until the
stream is closed. This option can be used to set the stream head into
non-persistent error mode i.e. once the error has been returned in response
to a
.BR read (2),
.BR getmsg (2),
.BR ioctl (2),
.BR write (2),
or
.BR putmsg (2)
call the error condition will be cleared. The error mode can
be controlled independently for read and write side errors. Legal \fIarg\fR
values are either none or one of:
.sp
.ne 2
.mk
.na
.B RERRNORM
.ad
.RS 18n
.rt
Persistent read errors, the default.
.RE

.sp
.ne 2
.mk
.na
.B RERRNONPERSIST
.ad
.RS 18n
.rt
Non-persistent read errors.
.RE

\fBOR'ed\fR with either none or one of:
.sp
.ne 2
.mk
.na
.B WERRNORM
.ad
.RS 18n
.rt
Persistent write errors, the default.
.RE

.sp
.ne 2
.mk
.na
.B WERRNONPERSIST
.ad
.RS 18n
.rt
Non-persistent write errors.
.sp
When no value is specified e.g. for the read side error behavior then the
behavior for that side will be left unchanged.
.RE

On failure,
.B errno
is set to the following value:
.sp
.ne 2
.mk
.na
.B EINVAL
.ad
.RS 10n
.rt
\fIarg\fR is not one of the above legal values.
.RE

.RE

.sp
.ne 2
.mk
.na
.B I_GERROPT
.ad
.RS 15n
.rt
Returns the current error mode setting in an
.B int
pointed to by the
argument
.IR arg .
Error modes are described above for
.BR I_SERROPT .
On
failure,\fBerrno\fR is set to the following value:
.sp
.ne 2
.mk
.na
.B EFAULT
.ad
.RS 10n
.rt
\fIarg\fR points outside the allocated address space.
.RE

.RE

.sp
.LP
The following four commands are used for connecting and disconnecting
multiplexed STREAMS configurations.
.sp
.ne 2
.mk
.na
.B I_LINK
.ad
.RS 13n
.rt
Connects two streams, where \fIfildes\fR is the file descriptor of the
stream connected to the multiplexing driver, and
.I arg
is the file
descriptor of the stream connected to another driver. The stream designated
by
.I arg
.RB "gets connected below the multiplexing driver." " I_LINK"
requires the multiplexing driver to send an acknowledgement message to the
stream head regarding the linking operation. This call returns a multiplexor
ID number (an identifier used to disconnect the multiplexor, see
.BR I_UNLINK )
on success, and -1 on failure. On failure,
.B errno
is set
to one of the following values:
.sp
.ne 2
.mk
.na
.B ENXIO
.ad
.RS 10n
.rt
Hangup received on \fIfildes\fR.
.RE

.sp
.ne 2
.mk
.na
.B ETIME
.ad
.RS 10n
.rt
Time out before acknowledgement message was received at stream head.
.RE

.sp
.ne 2
.mk
.na
.B EAGAIN
.ad
.RS 10n
.rt
Temporarily unable to allocate storage to perform the
.BR I_LINK.
.RE

.sp
.ne 2
.mk
.na
.B ENOSR
.ad
.RS 10n
.rt
Unable to allocate storage to perform the
.B I_LINK
due to insufficient
\fBSTREAMS\fR memory resources.
.RE

.sp
.ne 2
.mk
.na
.B EBADF
.ad
.RS 10n
.rt
\fIarg\fR is not a valid, open file descriptor.
.RE

.sp
.ne 2
.mk
.na
.B EINVAL
.ad
.RS 10n
.rt
\fIfildes\fR stream does not support multiplexing.
.RE

.sp
.ne 2
.mk
.na
.B EINVAL
.ad
.RS 10n
.rt
\fIarg\fR is not a stream, or is already linked under a multiplexor.
.RE

.sp
.ne 2
.mk
.na
.B EINVAL
.ad
.RS 10n
.rt
The specified link operation would cause a ``cycle'' in the resulting
configuration; that is, a driver would be linked into the multiplexing
configuration in more than one place.
.RE

.sp
.ne 2
.mk
.na
.B EINVAL
.ad
.RS 10n
.rt
\fIfildes\fR is the file descriptor of a pipe or FIFO.
.RE

.sp
.ne 2
.mk
.na
.B EINVAL
.ad
.RS 10n
.rt
Either the upper or lower stream has a major number >= the maximum major
number on the system.
.RE

An
.B I_LINK
can also fail while waiting for the multiplexing driver to
acknowledge the link request, if a message indicating an error or a hangup is
received at the stream head of
.IR fildes .
In addition, an error code can
be returned in the positive or negative acknowledgement message.  For these
cases,
.B I_LINK
will fail with
.B errno
set to the value in the
message.
.RE

.sp
.ne 2
.mk
.na
.B I_UNLINK
.ad
.RS 13n
.rt
Disconnects the two streams specified by \fIfildes\fR and \fIarg\fR.
\fIfildes\fR is the file descriptor of the stream connected to the
multiplexing driver.
.I arg
is the multiplexor ID number that was returned
by the
.BR I_LINK .
If
.I arg
is -1, then all streams that were linked to
\fIfildes\fR are disconnected.  As in
.BR I_LINK ,
this command requires the
multiplexing driver to acknowledge the unlink. On failure,
.B errno
is set
to one of the following values:
.sp
.ne 2
.mk
.na
.B ENXIO
.ad
.RS 10n
.rt
Hangup received on \fIfildes\fR.
.RE

.sp
.ne 2
.mk
.na
.B ETIME
.ad
.RS 10n
.rt
Time out before acknowledgement message was received at stream head.
.RE

.sp
.ne 2
.mk
.na
.B ENOSR
.ad
.RS 10n
.rt
Unable to allocate storage to perform the
.B I_UNLINK
due to insufficient
STREAMS memory resources.
.RE

.sp
.ne 2
.mk
.na
.B EINVAL
.ad
.RS 10n
.rt
\fIarg\fR is an invalid multiplexor ID number or \fIfildes\fR is not the
stream on which the
.B I_LINK
that returned
.I arg
was performed.
.RE

.sp
.ne 2
.mk
.na
.B EINVAL
.ad
.RS 10n
.rt
\fIfildes\fR is the file descriptor of a pipe or FIFO.
.RE

An 
.B I_UNLINK
can also fail while waiting for the multiplexing driver
to acknowledge the link request, if a message indicating an error or a hangup
is received at the stream head of
.IR fildes .
In addition, an error code
can be returned in the positive or negative acknowledgement message. For
these cases, 
.B I_UNLINK
will fail with
.B errno
set to the value in
the message.
.RE

.sp
.ne 2
.mk
.na
.B I_PLINK
.ad
.RS 13n
.rt
Connects two streams, where \fIfildes\fR is the file descriptor of the
stream connected to the multiplexing driver, and
.I arg
is the file
descriptor of the stream connected to another driver. The stream designated
by
.I arg
gets connected via a persistent link below the multiplexing
driver.
.B I_PLINK
requires the multiplexing driver to send an
acknowledgement message to the stream head regarding the linking operation.
This call creates a persistent link that continues to exist even if the file
descriptor \fIfildes\fR associated with the upper stream to the multiplexing
driver is closed. This call returns a multiplexor ID number (an identifier
that may be used to disconnect the multiplexor, see
.BR I_PUNLINK )
on
success, and -1 on failure. On failure,
.B errno
is set to one of the
following values:
.sp
.ne 2
.mk
.na
.B ENXIO
.ad
.RS 10n
.rt
Hangup received on \fIfildes\fR.
.RE

.sp
.ne 2
.mk
.na
.B ETIME
.ad
.RS 10n
.rt
Time out before acknowledgement message was received at the stream head.
.RE

.sp
.ne 2
.mk
.na
.B EAGAIN
.ad
.RS 10n
.rt
Unable to allocate STREAMS storage to perform the 
.BR I_PLINK.
.RE

.sp
.ne 2
.mk
.na
.B EBADF
.ad
.RS 10n
.rt
\fIarg\fR is not a valid, open file descriptor.
.RE

.sp
.ne 2
.mk
.na
.B EINVAL
.ad
.RS 10n
.rt
\fIfildes\fR does not support multiplexing.
.RE

.sp
.ne 2
.mk
.na
.B EINVAL
.ad
.RS 10n
.rt
\fIarg\fR is not a stream or is already linked under a multiplexor.
.RE

.sp
.ne 2
.mk
.na
.B EINVAL
.ad
.RS 10n
.rt
The specified link operation would cause a ``cycle'' in the resulting
configuration; that is, if a driver would be linked into the multiplexing
configuration in more than one place.
.RE

.sp
.ne 2
.mk
.na
.B EINVAL
.ad
.RS 10n
.rt
\fIfildes\fR is the file descriptor of a pipe or FIFO.
.RE

An
.B I_PLINK
can also fail while waiting for the multiplexing driver to
acknowledge the link request, if a message indicating an error on a hangup is
received at the stream head of
.IR fildes .
In addition, an error code can
be returned in the positive or negative acknowledgement message.  For these
cases,
.B I_PLINK
will fail with
.B errno
set to the value in the
message.
.RE

.sp
.ne 2
.mk
.na
.B I_PUNLINK
.ad
.RS 13n
.rt
Disconnects the two streams specified by \fIfildes\fR and
.I arg
that are
connected with a persistent link. \fIfildes\fR is the file descriptor of the
stream connected to the multiplexing driver.
.I arg
is the multiplexor ID
number that was returned by
.B I_PLINK
when a stream was linked below the
multiplexing driver. If
.I arg
is 
.B MUXID_ALL
then all streams that
are persistent links to \fIfildes\fR are disconnected. As in  \fBI_PLINK,\fR
this command requires the multiplexing driver to acknowledge the unlink. On
failure,
.B errno
is set to one of the following values:
.sp
.ne 2
.mk
.na
.B ENXIO
.ad
.RS 10n
.rt
Hangup received on \fIfildes\fR.
.RE

.sp
.ne 2
.mk
.na
.B ETIME
.ad
.RS 10n
.rt
Time out before acknowledgement message was received at the stream head.
.RE

.sp
.ne 2
.mk
.na
.B EAGAIN
.ad
.RS 10n
.rt
Unable to allocate buffers for the acknowledgement message.
.RE

.sp
.ne 2
.mk
.na
.B EINVAL
.ad
.RS 10n
.rt
Invalid multiplexor ID number.
.RE

.sp
.ne 2
.mk
.na
.B EINVAL
.ad
.RS 10n
.rt
\fIfildes\fR is the file descriptor of a pipe or FIFO.
.RE

An
.B I_PUNLINK
can also fail while waiting for the multiplexing driver
to acknowledge the link request if a message indicating an error or a hangup
is received at the stream head of
.IR fildes .
In addition, an error code
can be returned in the positive or negative acknowledgement message.  For
these cases,
.B I_PUNLINK
will fail with
.B errno
set to the value in
the message.
.RE

.SH RETURN VALUES
.sp
.LP
Unless specified otherwise above, the return value from
.B ioctl()
is
\fB0\fR upon success and  \fB\(mi1\fR upon failure, with \fIerrno\fR set as
indicated.
.SH SEE ALSO
.sp
.LP
.BR Intro (3),
.BR close (2),
\fBfcntl\fR(2), \fBgetmsg\fR(2),
.BR ioctl (2),
.BR open (2),
.BR poll (2),
.BR putmsg (2),
.BR read (2),
.BR write (2),
.BR signal (3C),
.BR signal.h (3HEAD),
.sp
.LP
.I STREAMS Programming Guide
