'\" te
.\" Copyright (c) 2005, Sun Microsystems, Inc.  All Rights Reserved.
.\" Copyright (c) 2012-2013, J. Schilling
.\" Copyright (c) 2013, Andreas Roehler
.\" Copyright 1989 AT&T
.\" CDDL HEADER START
.\"
.\" The contents of this file are subject to the terms of the
.\" Common Development and Distribution License ("CDDL"), version 1.0.
.\" You may only use this file in accordance with the terms of version
.\" 1.0 of the CDDL.
.\"
.\" A full copy of the text of the CDDL should have accompanied this
.\" source.  A copy of the CDDL is also available via the Internet at
.\" http://www.opensource.org/licenses/cddl1.txt
.\"
.\" When distributing Covered Code, include this CDDL HEADER in each
.\" file and include the License file at usr/src/OPENSOLARIS.LICENSE.
.\" If applicable, add the following below this CDDL HEADER, with the
.\" fields enclosed by brackets "[]" replaced with your own identifying
.\" information: Portions Copyright [yyyy] [name of copyright owner]
.\"
.\" CDDL HEADER END
.TH termio 7I "14 Sep 2005" "SunOS 5.11" "Ioctl Requests"
.SH NAME
termio \- general terminal interface
.SH SYNOPSIS
.LP
.nf
#include <termio.h>

\fBioctl\fR(\fBint\fR \fIfildes\fR, \fBint\fR \fIrequest\fR, \fBstruct termio *\fIarg\fR);
.fi

.LP
.nf
\fBioctl\fR(\fBint\fR \fIfildes\fR, \fBint\fR \fIrequest\fR, \fBint\fR \fIarg\fR);
.fi

.LP
.nf
#include <termios.h>

\fBioctl\fR(\fBint\fR \fIfildes\fR, \fBint\fR \fIrequest\fR, \fBstruct termios *\fIarg\fR);
.fi

.SH DESCRIPTION
.sp
.LP
This release supports a general interface for asynchronous communications
ports that is hardware-independent. The user interface to this functionality
is using function calls (the preferred interface) described in
.BR termios (3C)
or
.B ioctl
commands described in this section. This
section also discusses the common features of the  terminal subsystem which
are relevant with both user interfaces.
.sp
.LP
When a terminal file is opened, it normally causes the process to wait
until a connection is established. In practice, user programs seldom open
terminal files; they are opened by the system and become a user's standard
input, output, and error files. The first terminal file opened by the
session leader that is not already associated with a session becomes the
controlling terminal for that session. The controlling terminal plays a
special role in handling quit and interrupt signals, as discussed below. The
controlling terminal is inherited by a child process during a
.BR fork (2).
A process can break this association by changing its session using
.B setsid()
(see
.BR setsid (2)).
.sp
.LP
A terminal associated with one of these files ordinarily operates in
full-duplex mode. Characters may be typed at any time, even while output is
occurring, and are only lost when the character input buffers of the system
become completely full, which is rare. For example, the number of characters
in the line discipline buffer may exceed
.RB { MAX_CANON }
and
.B IMAXBEL
(see below) is not set, or the user may accumulate {
.BR MAX_INPUT }
number of input characters that have not yet been read by
some program. When the input limit is reached, all the characters saved in
the buffer up to that point are thrown away without notice.
.SS "Session Management (Job Control)"
.sp
.LP
A control terminal will distinguish one of the process groups in the
session associated with it to be the  foreground process group. All other
process groups in the session are designated as background process groups.
This foreground process group plays a special role in handling
signal-generating input characters, as discussed below. By default, when a
controlling terminal is allocated, the controlling process's process group
is assigned  as foreground process group.
.sp
.LP
Background process groups in the controlling process's session are subject
to a job control line discipline when they attempt to access their
controlling terminal. Process groups can be sent signals that will cause
them to stop, unless they have made other arrangements. An exception is made
for members of orphaned process groups.
.sp
.LP
An orphaned process group is one where the process group (see
.BR getpgid (2))
has no members with a parent in a different process group
but sharing the same controlling terminal. When a member of an orphaned
process group attempts to access its controlling terminal, EIO is returned
because there would be no way to restart the process if it were stopped on
one of these signals.
.sp
.LP
If a member of a background process group attempts to read its controlling
terminal, its process group will be sent a
.B SIGTTIN
signal, which will
normally cause the members of that process group to stop. If, however, the
process is ignoring or holding
.BR SIGTTIN ,
or is a member of an orphaned
process group, the read will fail with
.B errno
set to
.BR EIO ,
and no
signal is sent.
.sp
.LP
If a member of a background process group attempts to write its controlling
terminal and the
.B TOSTOP
bit is set in the
.B c_lflag
field, its
process group is sent a
.B SIGTTOU
signal, which will normally cause the
members of that process group to stop. If, however, the process is ignoring
or holding
.BR SIGTTOU ,
the write will succeed. If the process is not
ignoring or holding
.B SIGTTOU
and is a member of an orphaned process
group, the write will fail with
.B errno
set to
.BR EIO ,
and no
signal will be sent.
.sp
.LP
If
.B TOSTOP
is set and a member of a background process group attempts
to
.B ioctl
its controlling terminal, and that
.B ioctl
will modify
terminal parameters (for example,
.BR TCSETA ,
.BR TCSETAW ,
.BR TCSETAF ,
or
.BR TIOCSPGRP) ,
its process group will be sent a
.B SIGTTOU
signal, which will normally cause the members of that process
group to stop. If, however, the process is ignoring or holding
.BR SIGTTOU ,
the ioctl will succeed. If the process is not ignoring or
holding
.B SIGTTOU
and is a member of an orphaned process group, the
write will fail with
.B errno
set to
.BR EIO ,
and no signal will be
sent.
.SS "Canonical Mode Input Processing"
.sp
.LP
Normally, terminal input is processed in units of lines. A line is
.RB "delimited by a newline (" "ASCII LF" ") character, an end-of-file (" "ASCII EOT" )
character, or an end-of-line character. This means that a program
attempting to read will block until an entire line has been typed. Also, no
matter how many characters are requested in the read call, at most one line
will be returned. It is not necessary, however, to read a whole line at
once; any number of characters may be requested in a read, even one, without
losing information.
.sp
.LP
.RB "During input, erase and kill processing is normally done. The" " ERASE"
character (by default, the character
.BR DEL )
erases the last character
typed. The
.B WERASE
character (the character
.BR Control-w )
erases
the last "word" typed in the current input line (but not any preceding
spaces or tabs). A "word" is defined as a sequence of non-blank characters,
with tabs counted as blanks. Neither
.B ERASE
nor
.B WERASE
will erase
beyond the beginning of the line.  The
.B KILL
character (by default, the
character
.BR NAK )
kills (deletes) the entire input line, and optionally
outputs a newline character. All these characters operate on a key stroke
basis, independent of any backspacing or tabbing that may have been done.
The
.B REPRINT
character (the character Control-r) prints a newline
followed by all characters that have not been read. Reprinting also occurs
automatically if characters that would normally be erased from the screen
are fouled by program output. The characters are reprinted as if they were
being echoed; consequencely, if
.B ECHO
is not set, they are not
printed.
.sp
.LP
The
.B ERASE
and
.B KILL
characters may be entered literally by
preceding them with the escape character. In this case, the escape character
is not read. The erase and kill characters may be changed.
.SS "Non-canonical Mode Input Processing"
.sp
.LP
In non-canonical mode input processing, input characters are not assembled
into lines, and erase and kill processing does not occur. The
.B MIN
and
.B TIME
values are used to determine how to process the characters
received.
.sp
.LP
.B MIN
represents the minimum number of characters that should be
received when the read is satisfied (that is, when the characters are
returned to the user).
.B TIME
is a timer of 0.10-second granularity that
is used to timeout bursty and short-term data transmissions. The four
possible values for
.B MIN
and
.B TIME
and their interactions are
described below.
.sp
.ne 2
.mk
.na
.B "Case A: MIN > 0, TIME > 0
.ad
.RS 29n
.rt
In this case,
.B TIME
serves as an intercharacter timer and is activated
after the first character is received.  Since it is an intercharacter timer,
it is reset after a character is received. The interaction between
.B MIN
and
.B TIME
is as follows: as soon as one character is received, the
intercharacter timer is started. If
.B MIN
characters are received
before the intercharacter timer expires (note that the timer is reset upon
receipt of each character), the read is satisfied.  If the timer expires
before
.B MIN
characters are received, the characters received to that
point are returned to the user. Note that if
.B TIME
expires, at least
one character will be returned because  the timer would not have been
enabled unless a character was received. In this case (MIN > 0, TIME > 0),
the read sleeps until the
.B MIN
and
.B TIME
mechanisms are activated
by the receipt of the first character. If the number of characters read is
less than the number of characters available, the timer is not reactivated
and the subsequent read is satisfied immediately.
.RE

.sp
.ne 2
.mk
.na
.B "Case B: MIN > 0, TIME = 0
.ad
.RS 29n
.rt
In this case, since the value of
.B TIME
is zero, the timer plays no
role and only
.B MIN
is significant.  A pending read is not satisfied
until
.B MIN
characters are received (the pending read sleeps until
.B MIN
characters are received). A program that uses this case to read
record based terminal
.B I/O
may block indefinitely in the read
operation.
.RE

.sp
.ne 2
.mk
.na
.B "Case C: MIN = 0, TIME > 0
.ad
.RS 29n
.rt
In this case, since
.B MIN
= 0,
.B TIME
no longer represents an
intercharacter timer: it now serves as a read timer that is activated as
soon as a
.B read
is done.  A read is satisfied as soon as a single
character is received or the read timer expires. Note that, in this case, if
the timer expires, no character is returned. If the timer does not expire,
the only way the read can be satisfied is if a  character is received. In
this case, the read will not block indefinitely waiting for a character; if
no character is received within
.B TIME
*.10 seconds after the read is
initiated, the read returns with zero characters.
.RE

.sp
.ne 2
.mk
.na
.B "Case D: MIN = 0, TIME = 0
.ad
.RS 29n
.rt
In this case, return is immediate. The minimum of either the number of
characters requested or the number of characters currently available is
returned without waiting for more characters to be input.
.RE

.SS "Comparing Different Cases of MIN, TIME Interaction"
.sp
.LP
Some points to note about
.B MIN
and
.B TIME
:
.RS +4
.TP
.ie t \(bu
.el o
In the following explanations, note that the interactions of
.B MIN
and
.B TIME
are not symmetric.  For example, when
.B MIN
> 0 and
.B TIME
= 0,
.B TIME
has no effect. However, in the opposite case,
where
.B MIN
= 0 and
.B TIME
> 0, both 
.BR MIN " and  "
.B TIME
play
a role in that
.B MIN
is satisfied with the receipt of a single
character.
.RE
.RS +4
.TP
.ie t \(bu
.el o
Also note that in case A (\fBMIN\fR > 0,
.B TIME
> 0), \fBTIME\fR
represents an intercharacter timer,  whereas in case C (
.B MIN
= 0,
.B TIME
> 0),
.B TIME
represents a read timer.
.RE
.sp
.LP
These two points highlight the dual purpose of the
.B MIN/TIME
feature.
Cases A and B, where
.B MIN
> 0, exist to handle burst mode activity
(for example, file transfer programs), where a program would like to process
at least
.B MIN
characters at a time. In case A, the intercharacter timer
is activated by a user as a safety measure; in case B, the timer is turned
off.
.sp
.LP
Cases C and D exist to handle single character, timed transfers. These
cases are readily adaptable to screen-based applications that need to know
if a character is present in the input queue before refreshing the screen.
In case C, the read is timed, whereas in case D, it is not.
.sp
.LP
Another important note is that
.B MIN
is always just a minimum.  It does
not denote a record length. For example, if a program does a read of 20
bytes,
.B MIN
is 10, and 25 characters are present, then 20 characters
will be returned to the user.
.SS "Writing Characters"
.sp
.LP
When one or more characters are written, they are transmitted to the
terminal as soon as previously written characters have finished typing.
Input characters are echoed as they are typed if echoing has been enabled.
If a process produces characters more rapidly than they can be typed, it
will be suspended when its output queue exceeds some limit. When the queue
is drained down to some threshold, the program is resumed.
.SS "Special Characters"
.sp
.LP
Certain characters have special functions on input. These functions and
their default character values are summarized as follows:
.sp
.ne 2
.mk
.na
.B INTR
.ad
.RS 11n
.rt
(Control-c or
.BR "ASCII ETX" )
generates a
.B SIGINT
signal.
.B SIGINT
is sent to all foreground processes associated with the
controlling terminal. Normally, each such process is forced to terminate,
but arrangements may be made either to ignore the signal or to receive a
trap to an agreed upon location. (See
.BR signal.h (3HEAD)).
.RE

.sp
.ne 2
.mk
.na
.B QUIT
.ad
.RS 11n
.rt
(Control-| or
.BR "ASCII FS" )
generates a
.B SIGQUIT
signal.  Its
treatment is identical to the interrupt signal except that, unless a
receiving process has made other arrangements, it will not only be
terminated but a core image file (called
.BR core )
will be created in the
current working directory.
.RE

.sp
.ne 2
.mk
.na
.B ERASE
.ad
.RS 11n
.rt
(DEL) erases the preceding character. It does not erase beyond the start of
a line, as delimited by a
.BR NL ,
.BR EOF ,
.BR EOL ,
or
.BR EOL2
character.
.RE

.sp
.ne 2
.mk
.na
.B WERASE
.ad
.RS 11n
.rt
(Control-w or \fBASCII ETX\fR) erases the preceding "word". It does not
erase beyond the start of a line, as delimited by a
.BR NL ,
.BR EOF ,
.BR EOL ,
or
.B EOL2
character.
.RE

.sp
.ne 2
.mk
.na
.B KILL
.ad
.RS 11n
.rt
(Control-u or
.BR "ASCII NAK" )
deletes the entire line, as delimited by a
.BR NL ,
.BR EOF ,
.BR EOL ,
or
.B EOL2
character.
.RE

.sp
.ne 2
.mk
.na
.B REPRINT
.ad
.RS 11n
.rt
(Control-r or
.BR "ASCII DC2" )
reprints all characters, preceded by a
newline, that have not been read.
.RE

.sp
.ne 2
.mk
.na
.B EOF
.ad
.RS 11n
.rt
(Control-d or
.BR "ASCII EOT" )
may be used to generate an end-of-file from
a terminal. When received, all the characters waiting to be read are
immediately passed to the program, without waiting for a newline, and the
.B EOF
is discarded.  Thus, if no characters are waiting (that is, the
.B EOF
occurred at the beginning of a line) zero characters are passed
back, which is the standard end-of-file indication. Unless escaped, the
.B EOF
character is not echoed. Because
.B EOT
is the default
.B EOF
character, this prevents terminals that respond to
.B EOT
from
hanging up.
.RE

.sp
.ne 2
.mk
.na
.B NL
.ad
.RS 11n
.rt
(ASCII LF) is the normal line delimiter. It cannot be changed or escaped.
.RE

.sp
.ne 2
.mk
.na
.B EOL
.ad
.RS 11n
.rt
(ASCII NULL) is an additional line delimiter, like
.B NL
\&. It is not
normally used.
.RE

.sp
.ne 2
.mk
.na
.B EOL2
.ad
.RS 11n
.rt
is another additional line delimiter.
.RE

.sp
.ne 2
.mk
.na
.B SWTCH
.ad
.RS 11n
.rt
(Control-z or
.BR "ASCII EM" )
Header file symbols related to this special
character are present for compatibility purposes only and the kernel takes
no special action on matching SWTCH (except to discard the character).
.RE

.sp
.ne 2
.mk
.na
.B SUSP
.ad
.RS 11n
.rt
(Control-z or
.BR "ASCII SUB" )
generates a
.B SIGTSTP
signal.
.B SIGTSTP
stops all processes in the foreground process group for that
terminal.
.RE

.sp
.ne 2
.mk
.na
.B DSUSP
.ad
.RS 11n
.rt
(Control-y or
.BR "ASCII EM" ).
It generates a
.B SIGTSTP
signal as
.B SUSP
does, but the signal is sent when a process in the foreground
process group attempts to read the
.B DSUSP
character, rather than when
it is typed.
.RE

.sp
.ne 2
.mk
.na
.B STOP
.ad
.RS 11n
.rt
(Control-s or
.BR "ASCII DC3" )
can be used to suspend output temporarily.
It is useful with
.B CRT
terminals to prevent output from disappearing
before it can be read. While output is suspended,
.B STOP
characters are
ignored and not read.
.RE

.sp
.ne 2
.mk
.na
.B START
.ad
.RS 11n
.rt
(Control-q or
.BR "ASCII DC1" )
is used to resume output. Output has been
suspended by a
.B STOP
character.  While output is not suspended,
.B START
characters are ignored and not read.
.RE

.sp
.ne 2
.mk
.na
.B DISCARD
.ad
.RS 11n
.rt
(Control-o or
.BR "ASCII SI" )
causes subsequent output to be discarded.
Output is discarded until another
.B DISCARD
character is typed, more
input arrives, or the condition is cleared by a program.
.RE

.sp
.ne 2
.mk
.na
.B LNEXT
.ad
.RS 11n
.rt
(Control-v or
.BR "ASCII SYN" )
causes the special meaning of the next
character to be ignored.  This works for all the special characters
mentioned above. It allows characters to be input that would otherwise be
interpreted by the system (for example
.BR "KILL, QUIT" ).
The character
values for
.BR INTR ,
.BR QUIT ,
.BR ERASE ,
.BR WERASE ,
.BR KILL ,
.BR REPRINT ,
.BR EOF ,
.BR EOL ,
.BR EOL2 ,
.BR SWTCH ,
.BR SUSP ,
.BR DSUSP ,
.BR STOP ,
.BR START ,
.BR DISCARD ,
and
.B LNEXT
may be
changed to suit individual tastes. If the value of a special control
character is _POSIX_VDISABLE (0), the function of that special control
character is disabled. The
.BR ERASE ,
.BR KILL ,
and
.B EOF
characters
may be escaped by a preceding backslash
.RB ( \e )
character, in which case no
special function is done. Any of the special characters may be preceded by
the
.B LNEXT
character, in which case no special function is done.
.RE

.SS "Modem Disconnect"
.sp
.LP
When a modem disconnect is detected, a
.B SIGHUP
signal is sent to the
terminal's controlling process. Unless other arrangements have been made,
these signals cause the process to terminate. If
.B SIGHUP
is ignored or
caught, any subsequent read returns with an end-of-file indication until the
terminal is closed.
.sp
.LP
If the controlling process is not in the  foreground process group of the
terminal, a
.B SIGTSTP
is sent to the terminal's foreground process
group. Unless other arrangements have been made, these signals cause the
processes to stop.
.sp
.LP
Processes in background process groups that attempt to access the
controlling terminal after modem disconnect while the terminal is still
allocated to the session will receive appropriate
.B SIGTTOU
and
.B SIGTTIN
signals. Unless other arrangements have  been made, this
signal causes the processes to stop.
.sp
.LP
The controlling terminal will remain in this state until it is
reinitialized with a successful open by the controlling process, or
deallocated by the controlling process.
.SS "Terminal Parameters"
.sp
.LP
The parameters that control the behavior of devices and modules providing
the
.B termios
interface are specified by the
.B termios
structure
defined by
.BR termios.h .
Several
.BR ioctl (2)
system calls that fetch
or change these parameters use this structure that contains the following
members:
.sp
.in +2
.nf
 tcflag_t c_iflag;  /* input modes */
	tcflag_t	c_oflag;  /* output modes */
	tcflag_t	c_cflag;  /* control modes */
	tcflag_t	c_lflag;  /* local modes */
	cc_t  c_cc[NCCS];  /* control chars */
.fi
.in -2

.sp
.LP
The special control characters are defined by the array
.BR c_cc .
The
symbolic name
.B NCCS
is the size of the Control-character array and is
also defined by
.BR <termios.h> \&.
The relative positions, subscript
names, and typical default values  for each function are as follows:
.sp

.sp
.TS
tab() box;
cw(1.83i) |cw(1.83i) |cw(1.83i)
lw(1.83i) |lw(1.83i) |lw(1.83i)
.
Relative PositionSubscript NameTypical Default Value
_
0VINTRETX
_
1 VQUITFS
_
2VERASEDEL
_
3VKILLNAK
_
4VEOFEOT
_
5VEOLNUL
_
6VEOL2NUL
_
7VWSTCHNUL
_
8VSTARTNUL
_
9VSTOPDC3
_
10VSUSPSUB
_
11VDSUSPEM
_
12VREPRINTDC2
_
13VDISCARDSI
_
14VWERASEETB
_
15VLNEXTSYN
_
16-19Reserved
.TE

.SS "Input Modes"
.sp
.LP
The
.B c_iflag
field describes the basic terminal input control:
.sp
.ne 2
.mk
.na
.B IGNBRK
.ad
.RS 11n
.rt
 Ignore break condition.
.RE

.sp
.ne 2
.mk
.na
.B BRKINT
.ad
.RS 11n
.rt
Signal interrupt on break.
.RE

.sp
.ne 2
.mk
.na
.B IGNPAR
.ad
.RS 11n
.rt
Ignore characters with parity errors.
.RE

.sp
.ne 2
.mk
.na
.B PARMRK
.ad
.RS 11n
.rt
Mark parity errors.
.RE

.sp
.ne 2
.mk
.na
.B INPCK
.ad
.RS 11n
.rt
Enable input parity check.
.RE

.sp
.ne 2
.mk
.na
.B ISTRIP
.ad
.RS 11n
.rt
Strip character.
.RE

.sp
.ne 2
.mk
.na
.B INLCR
.ad
.RS 11n
.rt
Map NL to CR on input.
.RE

.sp
.ne 2
.mk
.na
.B IGNCR
.ad
.RS 11n
.rt
Ignore CR.
.RE

.sp
.ne 2
.mk
.na
.B ICRNL
.ad
.RS 11n
.rt
Map CR to NL on input.
.RE

.sp
.ne 2
.mk
.na
.B IUCLC
.ad
.RS 11n
.rt
Map upper-case to lower-case on input.
.RE

.sp
.ne 2
.mk
.na
.B IXON
.ad
.RS 11n
.rt
Enable start/stop output control.
.RE

.sp
.ne 2
.mk
.na
.B IXANY
.ad
.RS 11n
.rt
Enable any character to restart output.
.RE

.sp
.ne 2
.mk
.na
.B IXOFF
.ad
.RS 11n
.rt
Enable start/stop input control.
.RE

.sp
.ne 2
.mk
.na
.B IMAXBEL
.ad
.RS 11n
.rt
Echo
.B BEL
on input line too long.
.RE

.sp
.LP
If
.B IGNBRK
is set, a break condition (a character framing error with
data all zeros) detected on input is ignored, that is, not put on the input
queue and therefore not read by any process. If
.B IGNBRK
is not set and
.B BRKINT
is set, the break condition shall flush the input and output
queues and if the terminal is the controlling terminal of a foreground
process group, the break condition generates a single
.B SIGINT
signal to
that foreground process group. If neither
.B IGNBRK
nor
.B BRKINT
is
set, a break condition is read as a single '\e0' (\fBASCII NULL\fR)
character, or if
.B PARMRK
is set, as '\e377', '\e0', c, where '\e377'
is a single character with value 377 octal (0xff hex, 255 decimal), '\e0' is
a single character with value 0, and c is the errored character received.
.sp
.LP
If
.B IGNPAR
is set, a byte with framing or parity errors (other than
break) is ignored.
.sp
.LP
If
.B PARMRK
is set, and
.B IGNPAR
is not set, a byte with a framing
or parity error (other than break) is given to the application as the
three-character sequence: '\e377', '\e0', c, where '\e377' is a single
character with value 377 octal (0xff hex, 255 decimal), '\e0' is a single
character with value 0, and c is the errored character received. To avoid
ambiguity in this case, if
.B ISTRIP
is not set, a valid character of
\&'\e377' is given to the  application as `\e377.' If neither \fBIGNPAR\fR
nor
.B PARMRK
is set, a framing or parity error (other than break) is
given to the application as a single '\e0' (\fBASCII NULL\fR) character.
.sp
.LP
If
.B INPCK
is set, input parity checking is enabled. If
.B INPCK
is
not set, input parity checking is disabled. This allows output parity
generation without input parity errors.  Note that whether input parity
checking is enabled or disabled is independent of whether parity detection
is enabled or disabled.  If parity detection is enabled but input parity
checking is disabled, the hardware to which the terminal is connected will
recognize the parity bit, but the terminal special file will not check
whether this is set correctly or not.
.sp
.LP
If
.B ISTRIP
is set, valid input characters are first stripped to seven
bits, otherwise all eight bits are processed.
.sp
.LP
If
.B INLCR
is set, a received
.B NL
character is translated into a
.B CR
character.  If
.B IGNCR
is set, a received
.B CR
character
is ignored (not read).  Otherwise, if
.B ICRNL
is set, a received
.B CR
character is translated into a
.B NL
character.
.sp
.LP
If
.B IUCLC
is set, a received upper case, alphabetic character is
translated into the corresponding lower case character.
.sp
.LP
If
.B IXON
is set, start/stop output control is enabled. A received
.B STOP
character suspends output and a received
.B START
character
restarts output. The
.B STOP
and
.B START
characters will not be read,
but will merely perform  flow control functions. If
.B IXANY
is set, any
input character restarts output that has been suspended.
.sp
.LP
If
.B IXOFF
is set, the system transmits a
.B STOP
character when the
input queue is nearly full, and a
.B START
character when enough input
has been read so that the input queue is nearly empty again.
.sp
.LP
If
.B IMAXBEL
is set, the
.B "ASCII BEL"
character is echoed if the
input stream overflows. Further input is not stored, but any input already
present in the input stream is not disturbed.  If
.B IMAXBEL
is not set,
no
.B BEL
character is echoed, and all input present in the input queue
is discarded if the input stream overflows.
.SS "Output Modes"
.sp
.LP
The
.B c_oflag
field specifies the  system treatment of output:
.sp
.ne 2
.mk
.na
.B OPOST
.ad
.RS 10n
.rt
Post-process output.
.RE

.sp
.ne 2
.mk
.na
.B OLCUC
.ad
.RS 10n
.rt
Map lower case to upper on output.
.RE

.sp
.ne 2
.mk
.na
.B ONLCR
.ad
.RS 10n
.rt
Map NL to CR-NL on output.
.RE

.sp
.ne 2
.mk
.na
.B OCRNL
.ad
.RS 10n
.rt
Map CR to NL on output.
.RE

.sp
.ne 2
.mk
.na
.B ONOCR
.ad
.RS 10n
.rt
No
.B CR
output at column 0.
.RE

.sp
.ne 2
.mk
.na
.B ONLRET
.ad
.RS 10n
.rt
.B NL
performs
.B CR
function.
.RE

.sp
.ne 2
.mk
.na
.B OFILL
.ad
.RS 10n
.rt
Use fill characters for delay.
.RE

.sp
.ne 2
.mk
.na
.B OFDEL
.ad
.RS 10n
.rt
Fill is
.BR DEL ,
else
.IR NULL .
.RE

.sp
.ne 2
.mk
.na
.B NLDLY
.ad
.RS 10n
.rt
Select newline delays:
.br
.in +2
.B NL0
.in -2
.br
.in +2
.B NL1
.in -2
.RE

.sp
.ne 2
.mk
.na
.B CRDLY
.ad
.RS 10n
.rt
Select carriage-return delays:
.br
.in +2
.B CR0
.in -2
.br
.in +2
.B CR1
.in -2
.br
.in +2
.B CR2
.in -2
.br
.in +2
.B CR3
.in -2
.RE

.sp
.ne 2
.mk
.na
.B TABDLY
.ad
.RS 10n
.rt
Select horizontal tab delays or tab expansion:
.sp
.ne 2
.mk
.na
.B TAB0
.ad
.RS 9n
.rt

.RE

.sp
.ne 2
.mk
.na
.B TAB1
.ad
.RS 9n
.rt

.RE

.sp
.ne 2
.mk
.na
.B TAB2
.ad
.RS 9n
.rt

.RE

.sp
.ne 2
.mk
.na
.B TAB3
.ad
.RS 9n
.rt
Expand tabs to spaces
.RE

.sp
.ne 2
.mk
.na
.B XTABS
.ad
.RS 9n
.rt
Expand tabs to spaces
.RE

.RE

.sp
.ne 2
.mk
.na
.B BSDLY
.ad
.RS 10n
.rt
Select backspace delays:
.br
.in +2
.B BS0
.in -2
.br
.in +2
.B BS1
.in -2
.RE

.sp
.ne 2
.mk
.na
.B VTDLY
.ad
.RS 10n
.rt
Select vertical tab delays:
.br
.in +2
.B VT0
.in -2
.br
.in +2
.B VT1
.in -2
.RE

.sp
.ne 2
.mk
.na
.B FFDLY
.ad
.RS 10n
.rt
Select form feed delays:
.br
.in +2
.B FF0
.in -2
.br
.in +2
.B FF1
.in -2
.RE

.sp
.LP
If
.B OPOST
is set, output characters are post-processed as indicated by
the remaining flags; otherwise, characters are transmitted without change.
.sp
.LP
If
.B OLCUC
is set, a lower case alphabetic character is transmitted as
the corresponding upper case character. This function is often used in
conjunction with
.BR IUCLC.
.sp
.LP
If
.B ONLCR
is set, the
.B NL
character is transmitted as the
.B CR-NL
character pair.  If
.B OCRNL
is set, the
.B CR
character
is transmitted as the
.B NL
character.  If
.B ONOCR
is set, no
.B CR
character is transmitted when at column 0 (first position). If
.B ONRET
is set, the
.B NL
character is assumed to do the
carriage-return function; the column pointer is set to 0 and the delays
specified for
.B CR
are used.  Otherwise, the
.B NL
character is
assumed to do just the line-feed function; the column pointer remains
unchanged. The column pointer is also set to 0 if the
.B CR
character is
actually transmitted.
.sp
.LP
The delay bits specify how long transmission stops to allow for mechanical
or other movement when certain characters are sent to the terminal. In all
cases, a value of 0 indicates no delay. If
.B OFILL
is set, fill
characters are transmitted for delay instead of a timed delay. This is
useful for high baud rate terminals that need only a minimal delay.  If
.B OFDEL
is set, the fill character is
.B DEL
; otherwise it is
.IR NULL .
.sp
.LP
If a form-feed or vertical-tab delay is specified, it lasts for about 2
seconds.
.sp
.LP
Newline delay lasts about 0.10 seconds. If
.B ONLRET
is set, the
carriage-return delays are used instead of the newline delays. If
.B OFILL
is set, two fill characters are transmitted.
.sp
.LP
Carriage-return delay type 1 is dependent on the current column position,
type 2 is about 0.10 seconds, and type 3 is about 0.15 seconds. If
.B OFILL
is set, delay type 1 transmits two fill characters, and type 2
transmits four fill characters.
.sp
.LP
Horizontal-tab delay type 1 is dependent on the current column position.
Type 2 is about 0.10 seconds. Type 3 specifies that tabs are to be expanded
into spaces. If
.B OFILL
is set, two fill characters are transmitted for
any delay.
.sp
.LP
Backspace delay lasts about 0.05 seconds. If
.B OFILL
is set, one fill
character is transmitted.
.sp
.LP
The actual delays depend on line speed and system load.
.SS "Control Modes"
.sp
.LP
The
.B c_cflag
field describes the hardware control of the terminal:
.sp
.ne 2
.mk
.na
.B CBAUD
.ad
.RS 13n
.rt
Baud rate:
.RE

.sp
.ne 2
.mk
.na
.B B0
.ad
.RS 13n
.rt
Hang up
.RE

.sp
.ne 2
.mk
.na
.B B50
.ad
.RS 13n
.rt
50 baud
.RE

.sp
.ne 2
.mk
.na
.B B75
.ad
.RS 13n
.rt
75 baud
.RE

.sp
.ne 2
.mk
.na
.B B110
.ad
.RS 13n
.rt
110 baud
.RE

.sp
.ne 2
.mk
.na
.B B134
.ad
.RS 13n
.rt
134 baud
.RE

.sp
.ne 2
.mk
.na
.B B150
.ad
.RS 13n
.rt
150 baud
.RE

.sp
.ne 2
.mk
.na
.B B200
.ad
.RS 13n
.rt
200 baud
.RE

.sp
.ne 2
.mk
.na
.B B300
.ad
.RS 13n
.rt
300 baud
.RE

.sp
.ne 2
.mk
.na
.B B600
.ad
.RS 13n
.rt
600 baud
.RE

.sp
.ne 2
.mk
.na
.B B1200
.ad
.RS 13n
.rt
1200 baud
.RE

.sp
.ne 2
.mk
.na
.B B1800
.ad
.RS 13n
.rt
1800 baud
.RE

.sp
.ne 2
.mk
.na
.B B2400
.ad
.RS 13n
.rt
2400 baud
.RE

.sp
.ne 2
.mk
.na
.B B4800
.ad
.RS 13n
.rt
4800 baud
.RE

.sp
.ne 2
.mk
.na
.B B9600
.ad
.RS 13n
.rt
9600 baud
.RE

.sp
.ne 2
.mk
.na
.B B19200
.ad
.RS 13n
.rt
19200 baud
.RE

.sp
.ne 2
.mk
.na
.B EXTA
.ad
.RS 13n
.rt
External A
.RE

.sp
.ne 2
.mk
.na
.B B38400
.ad
.RS 13n
.rt
38400 baud
.RE

.sp
.ne 2
.mk
.na
.B EXTB
.ad
.RS 13n
.rt
External B
.RE

.sp
.ne 2
.mk
.na
.B B57600
.ad
.RS 13n
.rt
57600 baud
.RE

.sp
.ne 2
.mk
.na
.B B76800
.ad
.RS 13n
.rt
76800 baud
.RE

.sp
.ne 2
.mk
.na
.B B115200
.ad
.RS 13n
.rt
115200 baud
.RE

.sp
.ne 2
.mk
.na
.B B153600
.ad
.RS 13n
.rt
153600 baud
.RE

.sp
.ne 2
.mk
.na
.B B230400
.ad
.RS 13n
.rt
230400 baud
.RE

.sp
.ne 2
.mk
.na
.B B307200
.ad
.RS 13n
.rt
307200 baud
.RE

.sp
.ne 2
.mk
.na
.B B460800
.ad
.RS 13n
.rt
460800 baud
.RE

.sp
.ne 2
.mk
.na
.B CSIZE
.ad
.RS 13n
.rt
Character size:
.RE

.sp
.ne 2
.mk
.na
.B CS5
.ad
.RS 13n
.rt
5 bits
.RE

.sp
.ne 2
.mk
.na
.B CS6
.ad
.RS 13n
.rt
6 bits
.RE

.sp
.ne 2
.mk
.na
.B CS7
.ad
.RS 13n
.rt
7 bits
.RE

.sp
.ne 2
.mk
.na
.B CS8
.ad
.RS 13n
.rt
8 bits
.RE

.sp
.ne 2
.mk
.na
.B CSTOPB
.ad
.RS 13n
.rt
Send two stop bits, else one
.RE

.sp
.ne 2
.mk
.na
.B CREAD
.ad
.RS 13n
.rt
Enable receiver
.RE

.sp
.ne 2
.mk
.na
.B PARENB
.ad
.RS 13n
.rt
Parity enable
.RE

.sp
.ne 2
.mk
.na
.B PARODD
.ad
.RS 13n
.rt
Odd parity, else even
.RE

.sp
.ne 2
.mk
.na
.B HUPCL
.ad
.RS 13n
.rt
Hang up on last close
.RE

.sp
.ne 2
.mk
.na
.B CLOCAL
.ad
.RS 13n
.rt
Local line, else dial-up
.RE

.sp
.ne 2
.mk
.na
.B CIBAUD
.ad
.RS 13n
.rt
Input baud rate, if different from output rate
.RE

.sp
.ne 2
.mk
.na
.B PAREXT
.ad
.RS 13n
.rt
Extended parity for mark and space parity
.RE

.sp
.ne 2
.mk
.na
.B CRTSXOFF
.ad
.RS 13n
.rt
Enable inbound hardware flow control
.RE

.sp
.ne 2
.mk
.na
.B CRTSCTS
.ad
.RS 13n
.rt
Enable outbound hardware flow control
.RE

.sp
.ne 2
.mk
.na
.B CBAUDEXT
.ad
.RS 13n
.rt
Bit to indicate output speed > B38400
.RE

.sp
.ne 2
.mk
.na
.B CIBAUDEXT
.ad
.RS 13n
.rt
Bit to indicate input speed > B38400
.RE

.sp
.LP
The
.B CBAUD
bits together with the
.B CBAUDEXT
bit specify the
output baud rate. To retrieve the output speed from the
.B termios
structure pointed to by
.B termios_p
see the following code segment.
.sp
.in +2
.nf
speed_t ospeed;
if (termios_p->c_cflag & CBAUDEXT)
   ospeed = (termios_p->c_cflag & CBAUD) + CBAUD + 1;
else
   ospeed = termios_p->c_cflag & CBAUD;
.fi
.in -2

.sp
.LP
To store the output speed in the termios structure pointed to by
.B termios_p
see the following code segment.
.sp
.in +2
.nf
speed_t ospeed;
if (ospeed > CBAUD) {
   termios_p->c_cflag |= CBAUDEXT;
   ospeed -= (CBAUD + 1);
} else
   termios_p->c_cflag &= ~CBAUDEXT;
 termios_p->c_cflag =
	(termios_p->c_cflag & ~CBAUD) | (ospeed & CBAUD);
.fi
.in -2

.sp
.LP
The zero baud rate, B0, is used to hang up the connection. If B0 is
specified, the data-terminal-ready signal is not asserted. Normally, this
disconnects the line.
.sp
.LP
If the
.B CIBAUDEXT
or
.B CIBAUD
bits are not zero, they specify the
input baud rate, with the
.B CBAUDEXT
and
.B CBAUD
bits specifying the
output baud rate; otherwise, the output and input baud rates are both
specified by the
.B CBAUDEXT
and
.B CBAUD
bits.  The values for the
.B CIBAUD
bits are the same as the values for the
.B CBAUD
bits,
shifted left
.B IBSHIFT
bits. For any particular hardware, impossible
.RB "speed changes are ignored. To retrieve the input speed in the " " termios"
structure pointed to by
.B termios_p
see the following code segment.
.sp
.in +2
.nf
speed_t ispeed;
if (termios_p->c_cflag & CIBAUDEXT)
   ispeed = ((termios_p->c_cflag & CIBAUD) >> IBSHIFT)
   + (CIBAUD >> IBSHIFT) + 1;
else
   ispeed = (termios_p->c_cflag & CIBAUD) >> IBSHIFT;
.fi
.in -2

.sp
.LP
To store the input speed in the
.B termios
structure pointed to by
.B termios_p
see the following code segment.
.sp
.in +2
.nf
speed_t ispeed;
if (ispeed == 0) {
   ispeed = termios_p->c_cflag & CBAUD;
if (termios_p->c_cflag & CBAUDEXT)
   ispeed += (CBAUD + 1);
}
 if ((ispeed << IBSHIFT) > CIBAUD) {
    termios_p->c_cflag |= CIBAUDEXT;
    ispeed -= ((CIBAUD >> IBSHIFT) + 1);
} else
    termios_p->c_cflag &= ~CIBAUDEXT;
    termios_p->c_cflag =
    (termios_p->c_cflag & ~CIBAUD) |
           ((ispeed << IBSHIFT) & CIBAUD);
.fi
.in -2

.sp
.LP
The
.B CSIZE
bits specify the character size in bits for both
transmission and reception. This size does not include the parity bit, if
any. If
.B CSTOPB
is set, two stop bits are used; otherwise, one stop bit
is used. For example, at 110 baud, two stops bits are required.
.sp
.LP
If
.B PARENB
is set, parity generation and detection is enabled, and a
parity bit is added to each character. If parity is enabled, the
.B PARODD
flag specifies odd parity if set; otherwise, even parity is
used.
.sp
.LP
If
.B CREAD
is set, the receiver is enabled. Otherwise, no characters
are received.
.sp
.LP
If
.B HUPCL
is set, the line is disconnected when the last process with
the line open closes it or terminates. That is, the data-terminal-ready
signal is not asserted.
.sp
.LP
If
.B CLOCAL
is set, the line is assumed to be a local, direct
connection with no modem control; otherwise, modem control is assumed.
.sp
.LP
If
.B CRTSXOFF
is set, inbound hardware flow control is enabled.
.sp
.LP
If
.B CRTSCTS
is set, outbound hardware flow control is enabled.
.sp
.LP
The four possible combinations for the state of
.B CRTSCTS
and
.B CRTSXOFF
bits and their interactions are described below.
.sp
.ne 2
.mk
.na
.B Case A:
.ad
.RS 11n
.rt
.B CRTSCTS
off,
.B CRTSXOFF
off. In this case the hardware flow
control is disabled.
.RE

.sp
.ne 2
.mk
.na
.B Case B:
.ad
.RS 11n
.rt
.B CRTSCTS
on,
.B CRTSXOFF
off. In this case only outbound hardware
flow control is enabled. The state of CTS signal is used to do outbound flow
control. It is expected that output will be suspended if CTS is low and
resumed when CTS is high.
.RE

.sp
.ne 2
.mk
.na
.B Case C:
.ad
.RS 11n
.rt
.B CRTSCTS
off,
.B CRTSXOFF
on. In this case only inbound hardware
flow control is enabled. The state of RTS signal is used to do inbound flow
control. It is expected that input will be suspended if RTS is low and
resumed when RTS is high.
.RE

.sp
.ne 2
.mk
.na
.B Case D:
.ad
.RS 11n
.rt
.B CRTSCTS
on,
.B CRTSXOFF
on. In this case both inbound and outbound
hardware flow control are enabled. Uses the state of CTS signal to do
outbound flow control and RTS signal to do inbound flow control.
.RE

.SS "Local Modes"
.sp
.LP
The
.B c_lflag
field of the argument structure is used by the line
discipline to control terminal functions. The basic line discipline provides
the following:
.sp
.ne 2
.mk
.na
.B ISIG
.ad
.RS 11n
.rt
 Enable signals.
.RE

.sp
.ne 2
.mk
.na
.B ICANON
.ad
.RS 11n
.rt
Canonical input (erase and kill processing).
.RE

.sp
.ne 2
.mk
.na
.B XCASE
.ad
.RS 11n
.rt
Canonical upper/lower presentation.
.RE

.sp
.ne 2
.mk
.na
.B ECHO
.ad
.RS 11n
.rt
Enable echo.
.RE

.sp
.ne 2
.mk
.na
.B ECHOE
.ad
.RS 11n
.rt
Echo erase character as
.B BS-SP-BS
&.
.RE

.sp
.ne 2
.mk
.na
.B ECHOK
.ad
.RS 11n
.rt
Echo
.B NL
after kill character.
.RE

.sp
.ne 2
.mk
.na
.B ECHONL
.ad
.RS 11n
.rt
Echo
.B NL
\&.
.RE

.sp
.ne 2
.mk
.na
.B NOFLSH
.ad
.RS 11n
.rt
Disable flush after interrupt or quit.
.RE

.sp
.ne 2
.mk
.na
.B TOSTOP
.ad
.RS 11n
.rt
Send
.B SIGTTOU
for background output.
.RE

.sp
.ne 2
.mk
.na
.B ECHOCTL
.ad
.RS 11n
.rt
Echo control characters as
.I char,
delete as ^?.
.RE

.sp
.ne 2
.mk
.na
.B ECHOPRT
.ad
.RS 11n
.rt
Echo erase character as character erased.
.RE

.sp
.ne 2
.mk
.na
.B ECHOKE
.ad
.RS 11n
.rt
.B BS-SP-BS
erase entire line on line kill.
.RE

.sp
.ne 2
.mk
.na
.B FLUSHO
.ad
.RS 11n
.rt
Output is being flushed.
.RE

.sp
.ne 2
.mk
.na
.B PENDIN
.ad
.RS 11n
.rt
Retype pending input at next read or  input character.
.RE

.sp
.ne 2
.mk
.na
.B IEXTEN
.ad
.RS 11n
.rt
Enable extended (implementation-defined) functions.
.RE

.sp
.LP
If
.B ISIG
is set, each input character is checked against the special
control characters INTR, QUIT, SWTCH,  SUSP, STATUS, and
.BR DSUSP .
If an
input character matches one of these control characters, the function
associated with that character is performed. (Note: If SWTCH is set and the
character matches, the character is simply discarded. No other action is
taken.) If
.B ISIG
is not set, no checking is done.  Thus, these special
input functions are possible only if
.B ISIG
is set.
.sp
.LP
If
.B ICANON
is set, canonical processing is enabled. This enables the
erase and kill edit functions, and the assembly of input characters into
lines delimited by
.BR NL-c ,
.BR EOF ,
.BR EOL ,
and
.B EOL
\&. If
.B ICANON
is not set, read requests are satisfied directly from the input
queue. A read is not satisfied until at least
.B MIN
characters have been
received or the timeout value
.B TIME
has expired between characters.
This allows fast bursts of input to be read efficiently while still allowing
single character input. The time value represents tenths of seconds.
.sp
.LP
If
.B XCASE
is set and
.B ICANON
is set, an upper case letter is
accepted on input if preceded by a backslash
.RB ( \e )
character, and is
output preceded by a  backslash
.RB ( \e )
character. In this mode, the
following escape sequences are generated on output and accepted on input:
.sp

.sp
.TS
tab() box;
cw(2.75i) |cw(2.75i)
lw(2.75i) |lw(2.75i)
.
FOR:USE:
_
`\e'
_
|\e!
_
\(ap\e^
_
{\e(
_
}\e)
_
\e\e\e
.TE

.sp
.LP
For example, input A as \ea, \en as \e\en, and \eN as \e\e\en.
.sp
.LP
If
.B ECHO
is set, characters are echoed as received.
.sp
.LP
When
.B ICANON
is set, the following echo functions are possible.
.RS +4
.TP
.ie t \(bu
.el o
If
.B ECHO
and
.B ECHOE
are set, and
.B ECHOPRT
is not set,  the
.B ERASE
and
.B WERASE
characters are echoed as one or more ASCII BS
SP BS, which clears the last character(s) from a
.B CRT
screen.
.RE
.RS +4
.TP
.ie t \(bu
.el o
If
.BR ECHO ,
.BR ECHOPRT ,
and
.B IEXTEN
are set, the first
.B ERASE
and
.B WERASE
character in a sequence echoes as a backslash
.RB ( \e ),
followed by the characters being erased.  Subsequent
.B ERASE
and
.B WERASE
characters echo the characters being erased, in reverse
order. The next non-erase character causes a `/' (slash) to be typed before
it is echoed.
.B ECHOPRT
should be used for hard copy terminals.
.RE
.RS +4
.TP
.ie t \(bu
.el o
If
.B ECHOKE
and
.B IEXTEN
are set, the kill character is echoed by
erasing each  character on the line from the screen (using the mechanism
selected by
.B ECHOE
and
.BR ECHOPR a).
.RE
.RS +4
.TP
.ie t \(bu
.el o
If
.B ECHOK
is set, and
.B ECHOKE
is not set, the
.B NL
character
is echoed after the kill character to emphasize that the line is deleted.
Note that a
.RB ` \e '
(escape) character or an
.B LNEXT
character preceding the
erase or kill character removes any special function.
.RE
.RS +4
.TP
.ie t \(bu
.el o
If
.B ECHONL
is set, the
.B NL
character is echoed even if
.B ECHO
is not set.  This is useful for terminals set to local echo (so
called half-duplex).
.RE
.sp
.LP
If
.B ECHOCTL
and
.B IEXTEN
are set, all control characters
(characters with codes between 0 and 37 octal) other than
.BR "ASCII TAB" ,
.BR "ASCII NL" ,
the
.B START
character, and the
.B STOP
character,
.BR "ASCII CR" ,
and
.B "ASCII BS"
are echoed as ^
.B X,
where
.B X
is
the character given by adding 100 octal to the code of the control
.RB "character (so that the character with octal code 1 is echoed as ^" " A),"
and the
.B "ASCII DEL"
character, with code 177 octal, is echoed as ^
.BR ? .
.sp
.LP
If
.B NOFLSH
is set, the normal flush of the input and output queues
associated with the
.BR INTR ,
.BR QUIT ,
and
.B SUSP
characters is not
done. This bit should be set when restarting system calls that read from or
write to a terminal (see 
.BR sigaction (2)\|).
.sp
.LP
If
.B TOSTOP
and
.B IEXTEN
are set, the signal
.B SIGTTOU
is
sent to a process that tries to write to its controlling terminal if it is
not in the foreground process group for that terminal. This signal normally
stops the process. Otherwise, the output generated by that process is output
to the current output stream. Processes that are blocking or ignoring
.B SIGTTOU
signals are excepted and allowed to produce output, if any.
.sp
.LP
If
.B FLUSHO
and
.B IEXTEN
are set, data written to the terminal is
discarded. This bit is set when the
.B FLUSH
character is typed. A
program can cancel the effect of typing the
.B FLUSH
character by
clearing
.BR FLUSHO .
.sp
.LP
If
.B PENDIN
and
.B IEXTEN
are set, any input that has not yet been
read is reprinted when the next character arrives as input.
.B PENDIN
is
then automatically cleared.
.sp
.LP
If
.B IEXTEN
is set, the following implementation-defined functions are
enabled: special characters (
.BR WERASE ,
.BR REPRINT ,
.BR DISCARD ,
and
.BR LNEXT )
and local flags (
.BR TOSTOP ,
.BR ECHOCTL ,
.BR ECHOPRT ,
.BR ECHOKE ,
.BR FLUSHO ,
and
.BR PENDIN ).
.SS "Minimum and Timeout"
.sp
.LP
The
.B MIN
and
.B TIME
values were described previously, in the
subsection,
.BR "Non-canonical Mode Input Processing" .
The initial value of
.B MIN
is 1, and the initial value of
.B TIME
is 0.
.SS "Terminal Size"
.sp
.LP
The number of lines and columns on the terminal's display is specified in
the
.B winsize
structure defined by
.B sys/termios.h
and includes the
following members:
.sp
.in +2
.nf
unsigned	short ws_row;  /* rows, in characters */
unsigned short	ws_col;    /* columns, in characters */
unsigned short	ws_xpixel; /* horizontal size, in pixels */
unsigned short	ws_ypixel; /* vertical size, in pixels */
.fi
.in -2

.SS "Termio Structure"
.sp
.LP
The SunOS/SVR4
.B termio
structure is used by some
.BR ioctl "s; it is"
defined by
.B sys/termio.h
and includes the following members:
.sp
.in +2
.nf
unsigned	 short	c_iflag;  /* input modes */
unsigned	 short	c_oflag;  /* output modes */
unsigned	 short	c_cflag;  /* control modes */
unsigned	 short c_lflag; /* local modes */
char c_line;			  /* line discipline */
unsigned	 char  c_cc[NCC];  /* control chars */
.fi
.in -2

.sp
.LP
The special control characters are defined by the array
.BR c_cc .
The
symbolic name
.B NCC
is the size of the Control-character array and is
also defined by
.BR termio.h .
The relative positions, subscript names, and
typical default values  for each function are as follows:
.sp

.sp
.TS
tab() box;
cw(1.83i) |cw(1.83i) |cw(1.83i)
lw(1.83i) |lw(1.83i) |lw(1.83i)
.
Relative PositionsSubscript NamesTypical Default Values
_
0VINTREXT
_
1VQUITFS
_
2VERASEDEL
_
3VKILLNAK
_
4VEOFEOT
_
5VEOLNUL
_
6VEOL2NUL
_
7Reserved
.TE

.sp
.LP
The
.B MIN
values is stored in the
.B VMIN
element of the
.BR c_cc
array; the
.B TIME
value is stored in the
.B VTIME
element of the
.B c_cc
array. The
.B VMIN
element is the same element as the
.B VEOF
element; the
.B VTIME
element is the same element as the
.B VEOL
element.
.sp
.LP
The calls that use the
.B termio
structure only affect the flags and
control characters that can be stored in the
.B termio
structure; all
other flags and control characters are unaffected.
.SS "Modem Lines"
.sp
.LP
On special files representing serial ports, modem control lines can be
read. Control lines  (if the underlying hardware supports it) may also be
changed. Status lines are read-only. The following modem control and status
lines may be supported by a device; they are defined by
.BR sys/termios.h :
.sp
.ne 2
.mk
.na
.B TIOCM_LE
.ad
.RS 13n
.rt
 line enable
.RE

.sp
.ne 2
.mk
.na
.B TIOCM_DTR
.ad
.RS 13n
.rt
data terminal ready
.RE

.sp
.ne 2
.mk
.na
.B TIOCM_RTS
.ad
.RS 13n
.rt
request to send
.RE

.sp
.ne 2
.mk
.na
.B TIOCM_ST
.ad
.RS 13n
.rt
secondary transmit
.RE

.sp
.ne 2
.mk
.na
.B TIOCM_SR
.ad
.RS 13n
.rt
secondary receive
.RE

.sp
.ne 2
.mk
.na
.B TIOCM_CTS
.ad
.RS 13n
.rt
clear to send
.RE

.sp
.ne 2
.mk
.na
.B TIOCM_CAR
.ad
.RS 13n
.rt
carrier detect
.RE

.sp
.ne 2
.mk
.na
.B TIOCM_RNG
.ad
.RS 13n
.rt
ring
.RE

.sp
.ne 2
.mk
.na
.B TIOCM_DSR
.ad
.RS 13n
.rt
data set ready
.RE

.sp
.LP
.B TIOCM_CD
is a synonym for
.BR TIOCM_CAR ,
and
.B TIOCM_RI
is a
synonym for
.BR TIOCM_RNG .
Not all of these are necessarily supported by
any particular device; check the manual page for the device in question.
.sp
.LP
The software carrier mode can be enabled or disabled using the
.BR "TIOCSSOFTCAR ioctl" .
If the software carrier flag for a line is
off, the line pays attention to the hardware carrier detect (DCD) signal.
The
.B tty
device associated with the line cannot be opened until
.B DCD
is asserted. If the software carrier flag is on, the line behaves
as if
.B DCD
is always asserted.
.sp
.LP
The software carrier flag is usually turned on for locally connected
terminals or other devices, and is off for lines with modems.
.sp
.LP
To be able to issue the
.B TIOCGSOFTCAR
and
.BR TIOCSSOFTCAR
.B ioctl
calls, the
.B tty
line should be opened with
.BR O_NDELAY
so that the
.BR open (2)
will not wait for the carrier.
.SS "Default Values"
.sp
.LP
The initial
.B termios
values upon driver open is configurable. This is
accomplished by setting the "ttymodes" property in the file
.BR /kernel/drv/options.conf .
Since this property is assigned during
system initialization,  any change to the "ttymodes" property will not take
effect until the next reboot.  The string value assigned to this property
should be in the same format as the output of the
.BR stty (1)
command with
the -g option.
.sp
.LP
If this property is undefined, the following
.B termios
modes are in
effect. The initial input control value is
.BR BRKINT ,
.BR ICRNL ,
.BR IXON ,
.BR IMAXBEL .
The initial output control value is
.BR OPOST ,
.BR ONLCR ,
.BR TAB3 .
The initial hardware control value is
.BR B9600 ,
.BR CS8 ,
.BR CREAD .
The initial line-discipline control value is
.BR ISIG ,
.BR ICANON ,
.BR IEXTEN ,
.BR ECHO ,
.BR ECHOK ,
.BR ECHOE ,
.BR ECHOKE ,
.BR ECHOCTL .
.SH IOCTLS
.sp
.LP
The
.BR ioctl "s supported by devices and"
.B STREAMS
modules providing
the
.BR termios (3C)
interface are listed below. Some calls may not be
supported by all devices or modules.  The functionality provided by these
calls is also available through the preferred function call interface
specified on
.BR termios .
.sp
.ne 2
.mk
.na
.B TCGETS
.ad
.RS 16n
.rt
The argument is a pointer to a
.B termios
structure. The current
terminal parameters are fetched and stored into that structure.
.RE

.sp
.ne 2
.mk
.na
.B TCSETS
.ad
.RS 16n
.rt
The argument is a pointer to a
.B termios
structure. The current
terminal parameters are set from the values stored in that structure. The
change is immediate.
.RE

.sp
.ne 2
.mk
.na
.B TCSETSW
.ad
.RS 16n
.rt
The argument is a pointer to a
.B termios
structure. The current
terminal parameters are set from the values stored in that structure. The
change occurs after all characters queued for output have been transmitted.
This form should be used when changing parameters that affect output.
.RE

.sp
.ne 2
.mk
.na
.B TCSETSF
.ad
.RS 16n
.rt
The argument is a pointer to a
.B termios
structure. The current
terminal parameters are set from the values stored in that structure. The
change occurs after all characters queued for output have been transmitted;
all characters queued for input are discarded and then the change occurs.
.RE

.sp
.ne 2
.mk
.na
.B TCGETA
.ad
.RS 16n
.rt
The argument is a pointer to a
.B termio
structure. The current terminal
parameters are fetched, and those parameters that can be stored in a
.B termio
structure are stored into that structure.
.RE

.sp
.ne 2
.mk
.na
.B TCSETA
.ad
.RS 16n
.rt
The argument is a pointer to a
.B termio
structure. Those terminal
parameters that can be stored in a
.B termio
structure are set from the
values stored in that structure. The change is immediate.
.RE

.sp
.ne 2
.mk
.na
.B TCSETAW
.ad
.RS 16n
.rt
The argument is a pointer to a
.B termio
structure. Those terminal
parameters that can be stored in a
.B termio
structure are set from the
values stored in that structure. The change occurs after all characters
queued for output have been transmitted. This form should be used when
changing parameters that affect output.
.RE

.sp
.ne 2
.mk
.na
.B TCSETAF
.ad
.RS 16n
.rt
The argument is a pointer to a
.B termio
structure.  Those terminal
parameters that can be stored in a
.B termio
structure are set from the
values stored in that structure. The change occurs after all characters
queued for output have been transmitted; all characters queued for input are
discarded and then the change occurs.
.RE

.sp
.ne 2
.mk
.na
.B TCSBRK
.ad
.RS 16n
.rt
The argument is an
.B int
value. Wait for the output to drain. If the
argument is
.BR 0 ,
then send a break (zero valued bits for 0.25
seconds).
.RE

.sp
.ne 2
.mk
.na
.B TCXONC
.ad
.RS 16n
.rt
Start/stop control. The argument is an
.B int
value. If the argument is
.BR 0 ,
suspend output; if
.BR 1 ,
restart suspended output; if
.BR 2 ,
suspend input; if
.BR 3 ,
restart suspended input.
.RE

.sp
.ne 2
.mk
.na
.B TCFLSH
.ad
.RS 16n
.rt
The argument is an
.B int
value. If the argument is
.BR 0 ,
flush the
input queue; if
.BR 1 ,
flush the output queue; if
.BR 2 ,
flush both the
input and output queues.
.RE

.sp
.ne 2
.mk
.na
.B TIOCGPGRP
.ad
.RS 16n
.rt
The argument is a pointer to a
.BR pid_t .
Set the value of that
.B pid_t
to the process group
.B ID
of the foreground process group
associated with the terminal. See 
.BR termios (3C)
for a description of
.BR TCGETPGRP .
.RE

.sp
.ne 2
.mk
.na
.B TIOCSPGRP
.ad
.RS 16n
.rt
The argument is a pointer to a
.BR pid_t .
Associate the process group
whose process group
.B ID
is specified by the value of that
.BR pid_t
with the terminal. The new process group value must be in the range of valid
process group
.B ID
values.  Otherwise, the error
.B EPERM
is
returned.
.RE

.sp
.ne 2
.mk
.na
.B TIOCGSID
.ad
.RS 16n
.rt
The argument is a pointer to a
.BR pid_t .
The session ID of the terminal
is fetched  and stored in the
.BR pid_t .
.RE

.sp
.ne 2
.mk
.na
.B TIOCGWINSZ
.ad
.RS 16n
.rt
The argument is a pointer to a
.B winsize
structure. The terminal
driver's notion of the terminal size is stored into that structure.
.RE

.sp
.ne 2
.mk
.na
.B TIOCSWINSZ
.ad
.RS 16n
.rt
The argument is a pointer to a
.B winsize
structure. The terminal
driver's notion of the terminal size is set from the values specified in
that structure. If the new sizes are different from the old sizes, a
.B SIGWINCH
signal is set to the process group of the terminal.
.RE

.sp
.ne 2
.mk
.na
.B TIOCMBIS
.ad
.RS 16n
.rt
The argument is a pointer to an
.B int
whose value is a mask containing
modem control lines to be turned on. The control lines whose bits are set in
the argument are turned on; no other control lines are affected.
.RE

.sp
.ne 2
.mk
.na
.B TIOCMBIC
.ad
.RS 16n
.rt
The argument is a pointer to an
.B int
whose value is a mask containing
modem control lines to be turned off. The control lines whose bits are set
in the argument are turned off; no other control lines are affected.
.RE

.sp
.ne 2
.mk
.na
.B TIOCMGET
.ad
.RS 16n
.rt
The argument is a pointer to an
.BR int .
The current state of the modem
status lines is fetched and stored in the
.B int
pointed to by the
argument.
.RE

.sp
.ne 2
.mk
.na
.B TIOCMSET
.ad
.RS 16n
.rt
The argument is a pointer to an
.B int
containing a new set of modem
control lines. The modem control lines are turned on or off, depending on
whether the bit for that mode is set or clear.
.RE

.sp
.ne 2
.mk
.na
.B TIOCSPPS
.ad
.RS 16n
.rt
The argument is a pointer to an
.B int
that determines whether
pulse-per-second event handling is to be enabled (non-zero) or disabled
(zero). If a one-pulse-per-second reference clock is attached to the serial
line's data carrier detect input, the local system clock will be calibrated
to it. A clock with a high error, that is, a deviation of more than 25
microseconds per tick, is ignored.
.RE

.sp
.ne 2
.mk
.na
.B TIOCGPPS
.ad
.RS 16n
.rt
The argument is a pointer to an
.BR int ,
in which the state of the even
handling is returned. The
.B int
is set to a non-zero value if
pulse-per-second (PPS) handling has been enabled. Otherwise, it is set to
zero.
.RE

.sp
.ne 2
.mk
.na
.B TIOCGSOFTCAR
.ad
.RS 16n
.rt
The argument is a pointer to an
.B int
whose value is
.B 1
or
.BR 0 ,
depending on whether the software carrier detect is turned on or
off.
.RE

.sp
.ne 2
.mk
.na
.B TIOCSSOFTCAR
.ad
.RS 16n
.rt
The argument is a pointer to an
.B int
whose value is
.B 1
or
.BR 0 .
The value of the integer should be
.B 0
to turn off software
carrier, or
.B 1
to turn it on.
.RE

.sp
.ne 2
.mk
.na
.B TIOCGPPSEV
.ad
.RS 16n
.rt
The argument is a pointer to a
.BR "struct ppsclockev" .
This
structure contains the following members:
.sp
.in +2
.nf
struct timeval tv;
uint32_t serial;
.fi
.in -2

"tv" is the system clock timestamp when the event (pulse on the \fBDCD\fR
pin) occurred. "serial" is the ordinal of the event, which each consecutive
event being assigned the next ordinal. The first event registered gets a
"serial" value of \fB1\fR. The \fBTIOCGPPSEV\fR returns the last event
registered; multiple calls will persistently return the same event until a
new one is registered. In addition to time stamping and saving the event, if
it is of one-second period and of consistently high accuracy, the local
system clock will automatically calibrate to it.
.RE

.SH FILES
.sp
.LP
Files in or under /\fBdev\fR
.SH SEE ALSO
.sp
.LP
.BR stty (1),
.BR fork (2),
.BR getpgid (2),
.BR getsid (2),
.BR ioctl (2),
.BR setsid (2),
.BR sigaction (2),
.BR signal (3C),
.BR tcsetpgrp (3C),
.BR termios (3C),
.BR signal.h (3HEAD),
.BR streamio (7I)
