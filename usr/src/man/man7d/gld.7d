'\" te
.\" Copyright (c) 2004, Sun Microsystems, Inc. All Rights Reserved
.\" CDDL HEADER START
.\"
.\" The contents of this file are subject to the terms of the
.\" Common Development and Distribution License (the "License").
.\" You may not use this file except in compliance with the License.
.\"
.\" You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
.\" or http://www.opensolaris.org/os/licensing.
.\" See the License for the specific language governing permissions
.\" and limitations under the License.
.\"
.\" When distributing Covered Code, include this CDDL HEADER in each
.\" file and include the License file at usr/src/OPENSOLARIS.LICENSE.
.\" If applicable, add the following below this CDDL HEADER, with the
.\" fields enclosed by brackets "[]" replaced with your own identifying
.\" information: Portions Copyright [yyyy] [name of copyright owner]
.\"
.\" CDDL HEADER END
.TH gld 7D "10 Nov 2005" "SunOS 5.11" "Devices"
.SH NAME
gld \- Generic
.B LAN
Driver
.SH SYNOPSIS
.LP
.nf
\fB#include\fR \fB<sys/stropts.h>\fR
.fi

.LP
.nf
\fB#include\fR \fB<sys/stream.h>\fR
.fi

.LP
.nf
\fB#include\fR \fB<sys/dlpi.h>\fR
.fi

.LP
.nf
\fB#include\fR \fB<sys/gld.h>\fR
.fi

.SH INTERFACE LEVEL
.sp
.LP
Solaris architecture specific (Solaris DDI).
.SH DESCRIPTION
.sp
.LP
GLD is a multi-threaded, clonable, loadable kernel module providing support
for Solaris local area network  (\fBLAN\fR) device drivers. \fBLAN\fR
drivers in Solaris are
.BR STREAMS "-based drivers that use the Data Link"
Provider Interface (\fBDLPI\fR) to communicate with network protocol stacks.
These protocol stacks use the network drivers to send and receive packets on
a local area network. A network device driver must implement and adhere to
the requirements imposed by the DDI/DKI specification, \fBSTREAMS\fR
specification, DLPI specification, and programmatic interface of the device
itself.
.sp
.LP
GLD implements most
.B STREAMS
and DLPI functionality required of a
Solaris LAN driver. Several Solaris network drivers are implemented using
GLD.
.sp
.LP
A Solaris network driver implemented using GLD comprises two distinct
parts: a generic component that deals with
.B STREAMS
and DLPI
interfaces, and a device-specific component that deals with the particular
hardware device. The device-specific module indicates its dependency on the
GLD module and registers itself with GLD from within the driver's
.BR attach (9E)
function. Once it is successfully loaded, the driver is
\fBDLPI\fR-compliant. The device-specific part of the driver calls
.BR gld (9F)
functions when it receives data or needs some service from
GLD. GLD makes calls into the \fBgld\fR(9E) entry points of the
device-specific driver through pointers provided to GLD by the
device-specific driver when it registered itself with GLD. The
.BR gld_mac_info (9S)
structure is the main data interface between GLD and
the device-specific driver.
.sp
.LP
The GLD facility currently supports devices of type
.BR DL_ETHER ,
.BR DL_TPR ,
and
.BR DL_FDDI .
GLD drivers are expected to process
fully-formed MAC-layer packets and should not perform logical link control
(LLC) handling.
.LP
Note -
.sp
.RS 2
Support for the DL_TPR and DL_FDDI media types in GLD is obsolete and may
be removed in a future release of Solaris.
.RE
.sp
.LP
In some cases, it may be necessary or desirable to implement a full
DLPI-compliant driver without using the GLD facility. This is true for
devices that are not IEEE 802-style LAN devices, or where a device type or
DLPI service not supported by GLD is required.
.SS "Device Naming Constraints"
.sp
.LP
The name of the device-specific driver module must adhere to the naming
constraints outlined in the NOTES section of
.BR dlpi (7P).
.SS "Type DL_ETHER: Ethernet V2 and ISO 8802-3 (IEEE 802.3)"
.sp
.LP
For devices designated type
.BR DL_ETHER ,
GLD provides support for both
Ethernet V2 and ISO 8802-3 (IEEE 802.3) packet processing. Ethernet V2
enables a data link service user to access and use any of a variety of
conforming data link service providers without special knowledge of the
provider's protocol. A service access point (\fBSAP\fR) is the point through
which the user communicates with the service provider.
.sp
.LP
SAP 0 denotes  that the  user  wishes to use
.I 802.3
mode. In
transmission, GLD checks the destination SAP value of the DL_UNITDATA_REQ
and the SAP value to which the stream is bound. If both  are 0, the GLD
computes the length of the packet payload and transmits
.I 802.3
frames
having that length in the MAC frame header type field. Such lengths will
never exceed 1500.
.sp
.LP
All frames received from the media that have a type field in the range
[0-1500] are assumed to be
.I 802.3
frames and are routed up all open
streams that are in
.I 802.3
mode,  (those streams  bound to a SAP value
in of 0. If more than one stream is in
.I 802.3
mode, the incoming frame
is duplicated and routed up each such stream.
.sp
.LP
Streams  bound to  a  SAP  value of  1536 or greater receive incoming
packets whose Ethernet MAC header type value exactly matches the value of
the SAP to which the stream is bound. SAP values in the range [1-1535] are
undefined and should not be used.
.SS "Types DL_TPR and DL_FDDI: SNAP Processing"
.LP
Note -
.sp
.RS 2
Support for the DL_TPR and DL_FDDI media types in GLD is obsolete and may
be removed in a future release of Solaris.
.RE
.sp
.LP
For media types DL_TPR and DL_FDDI, GLD implements  minimal SNAP (Sub-Net
Access Protocol)  processing for SAP values of 1536  or greater. A SAP value
of 0 denotes that the user wishes to use LLC mode. SAP values in  the range
[1-1535] have undefined semantics and should not be used.
.sp
.LP
.B SNAP
headers are carried under LLC headers with destination SAP 0xAA.
For outgoing packets with SAP values greater than 1535, GLD creates an
LLC+SNAP header that always looks like:
.sp
.LP
``AA AA 03 00 00 00 XX XX''
.sp
.LP
where ``XX XX'' represents the 16-bit SAP, corresponding  to the Ethernet
V2 style ``type.'' This is the only class of SNAP header that is processed -
non-zero OUI fields, and LLC control fields  other than 03 are considered to
be LLC packets with SAP 0xAA.
.sp
.LP
A DL_UNITDATA_REQ  message specifying  a destination  SAP value of 0,
passed down a stream bound to SAP 0, is assumed     to  contain  an LLC
packet and will not undergo  SNAP processing.
.sp
.LP
Incoming packets are examined to ascertain whether they fall into the
format specified above. Packets that do will be passed to streams bound to
the packet's 16-bit SNAP type, as well as being passed to any stream in LLC
mode (those bound to a SAP value of 0).
.SS "Type DL_TPR: Source Routing"
.LP
Note -
.sp
.RS 2
Support for the DL_TPR media type in GLD is obsolete and may be removed in
a future release of Solaris.
.RE
.sp
.LP
For type
.B DL_TPR
devices, GLD implements minimal support for source
routing. Source routing enables a station that is sending a packet across a
bridged medium to specify (in the packet MAC header) routing information
that determines the route that the packet will take through the network.
.sp
.LP
Functionally, the source routing support provided by GLD learns routes,
solicits and responds to requests for information about possible multiple
routes and selects among the multiple routes that are available. It adds
.I Routing Information Fields
to the MAC headers of outgoing packets and
recognizes such fields in incoming packets.
.sp
.LP
GLD's source routing support does not implement the full \fIRoute
Determination Entity\fR \fB(RDE)\fR specified in \fIISO 8802-2 (IEEE
802.2)\fR Section 9. However, it is designed to interoperate with any such
implementations that may exist in the same (or a bridged) network.
.SS "Style 1 and 2 Providers"
.sp
.LP
GLD implements both Style 1 and Style 2 providers. A physical point of
attachment (\fBPPA\fR) is the point at which a system attaches itself to a
physical communication medium. All communication on that physical medium
funnels through the
.BR PPA .
The Style 1 provider attaches the stream to a
particular
.B PPA
based on the major/minor device that has been opened.
The Style 2 provider requires the DLS user to explicitly identify the
desired
.B PPA
using
.B DL_ATTACH_REQ.
In this case,
.BR open (9E)
creates a stream between the user and GLD and
.BR DL_ATTACH_REQ
subsequently associates a particular
.B PPA
with that stream. Style 2 is
denoted by a minor number of zero. If a device node whose minor number is
not zero is opened, Style 1 is indicated and the associated
.B PPA
is the
minor number minus 1. In both Style 1 and Style 2 opens, the device is
cloned.
.SS "Implemented DLPI Primitives"
.sp
.LP
GLD implements the following DLPI primitives:
.sp
.LP
The
.B DL_INFO_REQ
primitive requests information about the DLPI stream.
The message consists of one
.B M_PROTO
message block. GLD returns
device-dependent values in the
.B DL_INFO_ACK
response to this request,
based on information the GLD-based driver specified in the
.BR gld_mac_info (9S)
structure passed to
.BR gld_register() .
However GLD
returns the following values on behalf of all GLD-based drivers:
.RS +4
.TP
.ie t \(bu
.el o
The version is
.BR DL_VERSION_2 .
.RE
.RS +4
.TP
.ie t \(bu
.el o
The service mode is
.B DL_CLDLS
\(em GLD implements connectionless-mode
service.
.RE
.RS +4
.TP
.ie t \(bu
.el o
The provider style is
.B DL_STYLE1
or
.B DL_STYLE2,
depending on how
the stream was opened.
.RE
.sp
.LP
The
.B DL_ATTACH_REQ
primitive is called to associate a
.B PPA
with a
stream. This request is needed for Style 2 DLS providers to identify the
physical medium over which the communication will transpire. Upon
completion, the state changes from
.B DL_UNATTACHED
to
.BR DL_UNBOUND.
The message consists of one
.B M_PROTO
message block. This request may
not be issued when using the driver in Style 1 mode; streams opened using
Style 1 are already attached to a
.B PPA
by the time the open
completes.
.sp
.LP
The
.B DL_DETACH_REQ
primitive requests to detach the
.B PPA
from the
stream. This is only allowed if the stream was opened using Style 2.
.sp
.LP
The
.B DL_BIND_REQ
and
.B DL_UNBIND_REQ
primitives bind and unbind a
.B DLSAP
to the stream. The
.B PPA
associated with each stream will
have been initialized upon completion of the processing of the
.B DL_BIND_REQ.
Multiple streams may be bound to the same
.BR SAP ;
each
such stream receives a copy of any packets received for that SAP.
.sp
.LP
The
.B DL_ENABMULTI_REQ
and
.B DL_DISABMULTI_REQ
primitives enable
and disable reception of individual multicast group addresses. A set of
multicast addresses may be iteratively created and modified on a per-stream
basis using these primitives. The stream must be attached to a
.B PPA
for
these primitives to be accepted.
.sp
.LP
The
.B DL_PROMISCON_REQ
and
.B DL_PROMISCOFF_REQ
primitives enable
and disable promiscuous mode on a per-stream basis, either at a physical
level or at the
.B SAP
level. The DL Provider will route all received
messages on the media to the DLS user until either a
.B DL_DETACH_REQ
or
a
.B DL_PROMISCOFF_REQ
is received or the stream is closed. Physical
level promiscuous mode may be specified for all packets on the medium or for
multicast packets only. The stream must be attached to a
.B PPA
for these
primitives to be accepted.
.sp
.LP
The
.B DL_UNITDATA_REQ
primitive is used to send data in a
connectionless transfer. Because this is an unacknowledged service, there is
no guarantee of delivery. The message consists of one
.B M_PROTO
message
block followed by one or more
.B M_DATA
blocks containing at least one
byte of data.
.sp
.LP
The
.B DL_UNITDATA_IND
type is used when a packet is received and is to
be passed upstream. The packet is put into an
.B M_PROTO
message with the
primitive set to
.BR DL_UNITDATA_IND .
.sp
.LP
The
.B DL_PHYS_ADDR_REQ
primitive returns the MAC address currently
associated with the
.B PPA
attached to the stream, in the
.B DL_PHYS_ADDR_ACK
primitive. When using style 2, this primitive is only
valid following a successful
.BR DL_ATTACH_REQ .
.sp
.LP
The
.B DL_SET_PHYS_ADDR_REQ
primitive changes the MAC address currently
associated with the
.B PPA
attached to the stream. This primitive affects
all other current and future streams attached to this device. Once changed,
all streams currently or subsequently opened and attached to this device
will obtain this new physical address. The new physical address will remain
in effect until this primitive is used to change the physical address again
or the driver is reloaded.
.sp
.LP
The
.B DL_GET_STATISTICS_REQ
primitive requests a
.B DL_GET_STATISTICS_ACK
response containing statistics information
associated with the PPA attached to the stream. Style 2 streams must be
attached to a particular
.B PPA
using
.B DL_ATTACH_REQ
before this
primitive will be successful.
.sp
.LP
GLD supports the DL_NOTE_LINK_UP, DL_NOTE_LINK_DOWN and DL_NOTE_SPEED
notifications using the DL_NOTIFY_IND primitive. See
.BR dlpi (7P).
.SS "Implemented ioctl Functions"
.sp
.LP
GLD implements the
.B DLIOCRAW
ioctl described in
.BR dlpi "(7P).  For"
any other ioctl command, GLD passes it to the device-specific driver's
.B gldm_ioctl()
function as described in
.BR gld (9E).
.SS "Requirements on GLD Drivers"
.sp
.LP
GLD-based drivers must include the header file \fB<sys/gld.h>\fR\&.
.sp
.LP
GLD-based  drivers  must also specify  a link dependency on "misc/gld".
(See the -N option in
.BR ld (1)).
.sp
.LP
GLD implements the \fBopen\fR(9E) and \fBclose\fR(9E) functions and the
required \fBSTREAMS put\fR(9E) and \fBsrv\fR(9E) functions on behalf
of the device-specific driver. GLD also implements the \fBgetinfo\fR(9E)
function for the driver.
.sp
.LP
The
.B mi_idname
element of the \fBmodule_info\fR(9S) structure is a
string specifying the name of the driver. This must exactly match the name
of the driver module as it exists in the file system.
.sp
.LP
The read-side \fBqinit\fR(9S) structure should specify the following
elements as shown below:
.sp
.ne 2
.mk
.na
.B qi_putp
.ad
.RS 14n
.rt
.I NULL
.RE

.sp
.ne 2
.mk
.na
.B qi_srvp
.ad
.RS 14n
.rt
.B gld_rsrv
.RE

.sp
.ne 2
.mk
.na
.B qi_qopen
.ad
.RS 14n
.rt
.B gld_open
.RE

.sp
.ne 2
.mk
.na
.B qi_qclose
.ad
.RS 14n
.rt
.B gld_close
.RE

.sp
.LP
The write-side \fBqinit\fR(9S) structure should specify the following
elements as shown below:
.sp
.ne 2
.mk
.na
.B qi_putp
.ad
.RS 14n
.rt
.B gld_wput
.RE

.sp
.ne 2
.mk
.na
.B qi_srvp
.ad
.RS 14n
.rt
.B gld_wsrv
.RE

.sp
.ne 2
.mk
.na
.B qi_qopen
.ad
.RS 14n
.rt
.I NULL
.RE

.sp
.ne 2
.mk
.na
.B qi_qclose
.ad
.RS 14n
.rt
.I NULL
.RE

.sp
.LP
The
.B devo_getinfo
element of the
.BR dev_ops (9S)
structure should
specify \fBgld_getinfo\fR as the \fBgetinfo\fR(9E) routine.
.sp
.LP
The driver's \fBattach\fR(9E) function does all the work of associating the
hardware-specific device driver with the GLD facility and preparing the
device and driver for use.
.sp
.LP
The \fBattach\fR(9E) function allocates a \fBgld_mac_info\fR(9S)
(``macinfo'') structure using
.BR gld_mac_alloc() .
The driver usually
needs to save more information per device than is defined in the macinfo
structure; it should allocate the additional required data structure and
save a pointer to it in the
.B gldm_private
member of the
.BR gld_mac_info (9S)
structure.
.sp
.LP
The \fBattach\fR(9E) routine must initialize the macinfo structure as
described in \fBgld_mac_info\fR(9S) and then call
.B gld_register()
to
link the driver with the GLD module. The driver should map registers if
necessary and be fully initialized and prepared to accept interrupts before
calling
.BR gld_register() .
The \fBattach\fR(9E) function should add
interrupts but not enable the device to generate them. The driver should
reset the hardware before calling
.B gld_register()
to ensure it is
quiescent; the device must not be started or put into a state where it may
generate an interrupt before
.B gld_register()
is called. That will be
done later when GLD calls the driver's
.B gldm_start()
entry point
described in
.BR gld "(9E). Once"
.B gld_register()
succeeds, the
.BR gld (9E)
entry points may be called by GLD at any time.
.sp
.LP
The \fBattach\fR(9E) routine should return \fBDDI_SUCCESS\fR if
.B gld_register()
succeeds. If
.B gld_register()
fails, it returns
.B DDI_FAILURE
and the
.BR attach "(9E) routine should deallocate any"
resources it allocated before calling
.B gld_register()
and then also
return
.BR DDI_FAILURE .
Under no circumstances should a failed macinfo
structure be reused; it should be deallocated using
.BR gld_mac_free ().
.sp
.LP
The \fBdetach\fR(9E) function should attempt to unregister the driver from
GLD. This is done by calling
.B gld_unregister()
described in
.BR gld (9F).
The
.BR detach "(9E) routine can get a pointer to the needed"
.BR gld_mac_info (9S)
structure from the device's private data using
.BR ddi_get_driver_private (9F).
.BR gld_unregister ()
checks certain
conditions that could require that the driver not be detached. If the checks
fail,
.B gld_unregister()
returns
.BR DDI_FAILURE ,
in which case the
driver's
.BR detach (9E)
routine must leave the device operational and
return
.BR DDI_FAILURE .
If the checks succeed, \fBgld_unregister()\fR
ensures that the device interrupts are stopped, calling the driver's
.B gldm_stop()
routine if necessary, unlinks the driver from the GLD
framework, and returns
.BR DDI_SUCCESS .
In this case, the
.BR detach (9E)
routine should remove interrupts, deallocate any data structures allocated
in the \fBattach\fR(9E) routine, using \fBgld_mac_free()\fR to deallocate
the macinfo structure, and return
.BR DDI_SUCCESS .
It is important to
remove the interrupt \fIbefore\fR calling \fBgld_mac_free()\fR.
.SS "Network Statistics"
.sp
.LP
Solaris network drivers must implement statistics variables. GLD itself
tallies some network statistics, but other statistics must be counted by
each GLD-based driver. GLD provides support for GLD-based drivers to report
a standard set of network driver statistics. Statistics are reported by GLD
using the
.BR kstat "(7D) and"
.BR kstat (9S)
mechanism. The
.B DL_GET_STATISTICS_REQ
DLPI command may also be used to retrieve the
current statistics counters. All statistics are maintained as unsigned, and
all are 32 bits unless otherwise noted.
.sp
.LP
GLD maintains and reports the following statistics.
.sp
.ne 2
.mk
.na
.B rbytes64
.ad
.RS 15n
.rt
Total bytes successfully received on the interface (64 bits).
.RE

.sp
.ne 2
.mk
.na
.B rbytes
.ad
.RS 15n
.rt
Total bytes successfully received on the interface.
.RE

.sp
.ne 2
.mk
.na
.B obytes64
.ad
.RS 15n
.rt
Total bytes requested to be transmitted on the interface (64 bits).
.RE

.sp
.ne 2
.mk
.na
.B obytes
.ad
.RS 15n
.rt
Total bytes requested to be transmitted on the interface.
.RE

.sp
.ne 2
.mk
.na
.B ipackets64
.ad
.RS 15n
.rt
Total packets successfully received on the interface (64 bits).
.RE

.sp
.ne 2
.mk
.na
.B ipackets
.ad
.RS 15n
.rt
Total packets successfully received on the interface.
.RE

.sp
.ne 2
.mk
.na
.B opackets64
.ad
.RS 15n
.rt
Total packets requested to be transmitted on the interface (64 bits).
.RE

.sp
.ne 2
.mk
.na
.B opackets
.ad
.RS 15n
.rt
Total packets requested to be transmitted on the interface.
.RE

.sp
.ne 2
.mk
.na
.B multircv
.ad
.RS 15n
.rt
Multicast packets successfully received, including group and functional
addresses (long).
.RE

.sp
.ne 2
.mk
.na
.B multixmt
.ad
.RS 15n
.rt
Multicast packets requested to be transmitted, including group and
functional addresses (long).
.RE

.sp
.ne 2
.mk
.na
.B brdcstrcv
.ad
.RS 15n
.rt
Broadcast packets successfully received (long).
.RE

.sp
.ne 2
.mk
.na
.B brdcstxmt
.ad
.RS 15n
.rt
Broadcast packets requested to be transmitted (long).
.RE

.sp
.ne 2
.mk
.na
.B unknowns
.ad
.RS 15n
.rt
Valid received packets not accepted by any stream (long).
.RE

.sp
.ne 2
.mk
.na
.B noxmtbuf
.ad
.RS 15n
.rt
Packets discarded on output because transmit buffer was busy, or no buffer
could be allocated for transmit (long).
.RE

.sp
.ne 2
.mk
.na
.B blocked
.ad
.RS 15n
.rt
Times a received packet could not be put up a stream because the queue was
flow controlled (long).
.RE

.sp
.ne 2
.mk
.na
.B xmtretry
.ad
.RS 15n
.rt
Times transmit was retried after having been delayed due to lack of
resources (long).
.RE

.sp
.ne 2
.mk
.na
.B promisc
.ad
.RS 15n
.rt
Current ``promiscuous'' state of the interface (string).
.RE

.sp
.LP
The device dependent driver counts the following statistics, keeping track
of them in a private per-instance structure. When GLD is asked to report
statistics, it calls the driver's
.B gldm_get_stats()
entry point, as
described in \fBgld\fR(9E), to update the device-specific statistics in the
.BR gld_stats (9S)
structure. GLD then reports the updated statistics using
the named statistics variables below.
.sp
.ne 2
.mk
.na
.B ifspeed
.ad
.RS 13n
.rt
Current estimated bandwidth of the interface in bits per second (64
bits).
.RE

.sp
.ne 2
.mk
.na
.B media
.ad
.RS 13n
.rt
Current media type in use by the device (string).
.RE

.sp
.ne 2
.mk
.na
.B intr
.ad
.RS 13n
.rt
Times interrupt handler was called and claimed the interrupt (long).
.RE

.sp
.ne 2
.mk
.na
.B norcvbuf
.ad
.RS 13n
.rt
Times a valid incoming packet was known to have been discarded because no
buffer could be allocated for receive (long).
.RE

.sp
.ne 2
.mk
.na
.B ierrors
.ad
.RS 13n
.rt
Total packets received that couldn't be processed because they contained
errors (long).
.RE

.sp
.ne 2
.mk
.na
.B oerrors
.ad
.RS 13n
.rt
Total packets that weren't successfully transmitted because of errors
(long).
.RE

.sp
.ne 2
.mk
.na
.B missed
.ad
.RS 13n
.rt
Packets known to have been dropped by the hardware on receive (long).
.RE

.sp
.ne 2
.mk
.na
.B uflo
.ad
.RS 13n
.rt
Times FIFO underflowed on transmit (long).
.RE

.sp
.ne 2
.mk
.na
.B oflo
.ad
.RS 13n
.rt
Times receiver overflowed during receive (long).
.RE

.sp
.LP
The following group of statistics applies to networks of type
.BR DL_ETHER ;
these are maintained by device-specific drivers of that
type, as above.
.sp
.ne 2
.mk
.na
.B align_errors
.ad
.RS 23n
.rt
Packets received with framing errors (not an integral number of octets)
(long).
.RE

.sp
.ne 2
.mk
.na
.B fcs_errors
.ad
.RS 23n
.rt
Packets received with CRC errors (long).
.RE

.sp
.ne 2
.mk
.na
.B duplex
.ad
.RS 23n
.rt
Current duplex mode of the interface (string).
.RE

.sp
.ne 2
.mk
.na
.B carrier_errors
.ad
.RS 23n
.rt
Times carrier was lost or never detected on a transmission attempt
(long).
.RE

.sp
.ne 2
.mk
.na
.B collisions
.ad
.RS 23n
.rt
Ethernet collisions during transmit (long).
.RE

.sp
.ne 2
.mk
.na
.B ex_collisions
.ad
.RS 23n
.rt
Frames where excess collisions occurred on transmit, causing transmit
failure (long).
.RE

.sp
.ne 2
.mk
.na
.B tx_late_collisions
.ad
.RS 23n
.rt
Times a transmit collision occurred late (after 512 bit times) (long).
.RE

.sp
.ne 2
.mk
.na
.B defer_xmts
.ad
.RS 23n
.rt
Packets without collisions where first transmit attempt was delayed because
the medium was busy (long).
.RE

.sp
.ne 2
.mk
.na
.B first_collisions
.ad
.RS 23n
.rt
Packets successfully transmitted with exactly one collision.
.RE

.sp
.ne 2
.mk
.na
.B multi_collisions
.ad
.RS 23n
.rt
Packets successfully transmitted with multiple collisions.
.RE

.sp
.ne 2
.mk
.na
.B sqe_errors
.ad
.RS 23n
.rt
Times SQE test error was reported.
.RE

.sp
.ne 2
.mk
.na
.B macxmt_errors
.ad
.RS 23n
.rt
Packets encountering transmit MAC failures, except carrier and collision
failures.
.RE

.sp
.ne 2
.mk
.na
.B macrcv_errors
.ad
.RS 23n
.rt
Packets received with MAC errors, except align, fcs, and toolong errors.
.RE

.sp
.ne 2
.mk
.na
.B toolong_errors
.ad
.RS 23n
.rt
Packets received larger than the maximum permitted length.
.RE

.sp
.ne 2
.mk
.na
.B runt_errors
.ad
.RS 23n
.rt
Packets received smaller than the minimum permitted length (long).
.RE

.sp
.LP
The following group of statistics applies to networks of type
.BR DL_TPR ;
these are maintained by device-specific drivers of that type, as above.
.sp
.ne 2
.mk
.na
.B line_errors
.ad
.RS 24n
.rt
Packets received with non-data bits or FCS errors.
.RE

.sp
.ne 2
.mk
.na
.B burst_errors
.ad
.RS 24n
.rt
Times an absence of transitions for five half-bit timers was detected.
.RE

.sp
.ne 2
.mk
.na
.B signal_losses
.ad
.RS 24n
.rt
Times loss of signal condition on the ring was detected.
.RE

.sp
.ne 2
.mk
.na
.B ace_errors
.ad
.RS 24n
.rt
Times an AMP or SMP frame in which A is equal to C is equal to 0, was
followed by another such SMP frame without an intervening AMP frame.
.RE

.sp
.ne 2
.mk
.na
.B internal_errors
.ad
.RS 24n
.rt
Times the station recognized an internal error.
.RE

.sp
.ne 2
.mk
.na
.B lost_frame_errors
.ad
.RS 24n
.rt
Times the TRR timer expired during transmit.
.RE

.sp
.ne 2
.mk
.na
.B frame_copied_errors
.ad
.RS 24n
.rt
Times a frame addressed to this station was received with the FS field A
bit set to 1.
.RE

.sp
.ne 2
.mk
.na
.B token_errors
.ad
.RS 24n
.rt
Times the station acting as the active monitor recognized an error
condition that needed a token transmitted.
.RE

.sp
.ne 2
.mk
.na
.B freq_errors
.ad
.RS 24n
.rt
Times the frequency of the incoming signal differed from the expected
frequency.
.RE

.sp
.LP
The following group of statistics applies to networks of type
.BR DL_FDDI ;
these are maintained by device-specific drivers of that type,
as above.
.sp
.ne 2
.mk
.na
.B mac_errors
.ad
.RS 20n
.rt
Frames detected in error by this MAC that had not been detected in error by
another MAC.
.RE

.sp
.ne 2
.mk
.na
.B mac_lost_errors
.ad
.RS 20n
.rt
Frames received with format errors such that the frame was stripped.
.RE

.sp
.ne 2
.mk
.na
.B mac_tokens
.ad
.RS 20n
.rt
Number of tokens received (total of non-restricted and restricted).
.RE

.sp
.ne 2
.mk
.na
.B mac_tvx_expired
.ad
.RS 20n
.rt
Number of times that TVX has expired.
.RE

.sp
.ne 2
.mk
.na
.B mac_late
.ad
.RS 20n
.rt
Number of TRT expirations since this MAC was reset or a token was
received.
.RE

.sp
.ne 2
.mk
.na
.B mac_ring_ops
.ad
.RS 20n
.rt
Number of times the ring has entered the ``Ring_Operational'' state from
the ``Ring Not Operational'' state.
.RE

.SH FILES
.sp
.ne 2
.mk
.na
.B /kernel/misc/gld
.ad
.RS 21n
.rt
loadable kernel module
.RE

.SH SEE ALSO
.sp
.LP
.BR ld (1),
.BR kstat (7D),
.BR dlpi (7P),
.BR attach (9E),
.BR gld (9E),
.BR open (9E),
.BR gld (9F),
.BR gld_mac_info (9S),
.BR gld_stats (9S),
.BR kstat (9S)
.sp
.LP
.I Writing Device Drivers
.SH WARNINGS
.sp
.LP
Contrary to the DLPI specification, GLD returns the device's correct
address length and broadcast address in
.B DL_INFO_ACK
even before the
stream has been attached to a
.BR PPA .
.sp
.LP
Promiscuous mode may only be entered by streams that are attached to a
.BR PPA .
.sp
.LP
The physical address of a
.B PPA
may be changed by the superuser while
other streams are bound to the same PPA.
