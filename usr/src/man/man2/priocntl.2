'\" te
.\" Copyright 1989 AT&T.
.\" Copyright (c) 2006, Sun Microsystems, Inc.  All Rights Reserved.
.\" Copyright (c) 2012-2013, J. Schilling
.\" Copyright (c) 2013, Andreas Roehler
.\" CDDL HEADER START
.\"
.\" The contents of this file are subject to the terms of the
.\" Common Development and Distribution License ("CDDL"), version 1.0.
.\" You may only use this file in accordance with the terms of version
.\" 1.0 of the CDDL.
.\"
.\" A full copy of the text of the CDDL should have accompanied this
.\" source.  A copy of the CDDL is also available via the Internet at
.\" http://www.opensource.org/licenses/cddl1.txt
.\"
.\" When distributing Covered Code, include this CDDL HEADER in each
.\" file and include the License file at usr/src/OPENSOLARIS.LICENSE.
.\" If applicable, add the following below this CDDL HEADER, with the
.\" fields enclosed by brackets "[]" replaced with your own identifying
.\" information: Portions Copyright [yyyy] [name of copyright owner]
.\"
.\" CDDL HEADER END
.TH priocntl 2 "11 May 2006" "SunOS 5.11" "System Calls"
.SH NAME
priocntl \- process scheduler control
.SH SYNOPSIS
.LP
.nf
#include <sys/types.h>
#include <sys/priocntl.h>
#include <sys/rtpriocntl.h>
#include <sys/tspriocntl.h>
#include <sys/iapriocntl.h>
#include <sys/fsspriocntl.h>
#include <sys/fxpriocntl.h>

\fBlong\fR \fBpriocntl\fR(\fBidtype_t\fR \fIidtype\fR, \fBid_t\fR \fIid\fR, \fBint\fR \fIcmd\fR, \fB/*\fR \fIarg\fR */ .\|.\|.);
.fi

.SH DESCRIPTION
.sp
.LP
The
.B priocntl()
function provides for control over the scheduling of
an active light weight process (LWP).
.sp
.LP
LWPs fall into distinct classes with a separate scheduling policy applied
to each class. The classes currently supported are the realtime class, the
time-sharing class, the fair-share class, and the fixed-priority class. The
characteristics of these classes are described under the corresponding
headings below.
.sp
.LP
The class attribute of an LWP is inherited across the
.BR fork (2)
function and the
.BR exec (2)
family of functions. The \fBpriocntl()\fR
function can be used to dynamically change the class and other scheduling
parameters associated with a running LWP or set of LWPs given the
appropriate permissions as explained below.
.sp
.LP
In the default configuration, a runnable realtime LWP runs before any other
LWP. Therefore, inappropriate use of realtime LWP can have a dramatic
negative impact on system performance.
.sp
.LP
The
.B priocntl()
function provides an interface for specifying a
process, set of processes, or an LWP to which the function applies. The
.BR priocntlset (2)
function provides the same functions as
.BR priocntl() ,
but allows a more general interface for specifying the set
of LWPs to which the function is to apply.
.sp
.LP
For
.BR priocntl() ,
the
.I idtype
and
.I id
arguments are used
together to specify the set of LWPs. The interpretation of
.I id
depends
on the value of
.IR idtype .
The possible values for
.I idtype
and
corresponding interpretations of
.I id
are as follows:
.sp
.ne 2
.mk
.na
.B P_ALL
.ad
.RS 12n
.rt
The
.B priocntl()
function applies to all existing LWPs. The value of
.I id
is ignored. The permission restrictions described below still
apply.
.RE

.sp
.ne 2
.mk
.na
.B P_CID
.ad
.RS 12n
.rt
The
.I id
.RB "argument is a class ID (returned by the" " priocntl()"
.B PC_GETCID
command as explained below). The
.B priocntl()
function
applies to all LWPs in the specified class.
.RE

.sp
.ne 2
.mk
.na
.B P_GID
.ad
.RS 12n
.rt
The
.I id
argument is a group ID. The
.B priocntl()
function applies
to all LWPs with this effective group ID.
.RE

.sp
.ne 2
.mk
.na
.B P_LWPID
.ad
.RS 12n
.rt
The
.I id
argument is an LWP ID. The
.I priocntl
function applies to
the LWP with the specified ID within the calling process.
.RE

.sp
.ne 2
.mk
.na
.B P_PGID
.ad
.RS 12n
.rt
The
.I id
argument is a process group ID. The
.B priocntl()
function
applies to all LWPs currently associated with processes in the specified
process group.
.RE

.sp
.ne 2
.mk
.na
.B P_PID
.ad
.RS 12n
.rt
The
.I id
argument is a process ID specifying a single process. The
.B priocntl()
function applies to all LWPs currently associated with the
specified process.
.RE

.sp
.ne 2
.mk
.na
.B P_PPID
.ad
.RS 12n
.rt
The
.I id
argument is a parent process ID. The
.B priocntl()
function
applies to all LWPs currently associated with processes with the specified
parent process ID.
.RE

.sp
.ne 2
.mk
.na
.B P_PROJID
.ad
.RS 12n
.rt
The
.I id
argument is a project ID. The
.B priocntl()
function
applies to all LWPs with this project ID.
.RE

.sp
.ne 2
.mk
.na
.B P_SID
.ad
.RS 12n
.rt
The
.I id
argument is a session ID. The
.B priocntl()
function
applies to all LWPs currently associated with processes in the specified
session.
.RE

.sp
.ne 2
.mk
.na
.B P_TASKID
.ad
.RS 12n
.rt
The
.I id
argument is a task ID. The
.B priocntl()
function applies
to all LWPs currently associated with processes in the specified task.
.RE

.sp
.ne 2
.mk
.na
.B P_UID
.ad
.RS 12n
.rt
The
.I id
argument is a user ID. The
.B priocntl()
function applies
to all LWPs with this effective user ID.
.RE

.sp
.ne 2
.mk
.na
.B P_ZONEID
.ad
.RS 12n
.rt
The
.I id
argument is a zone ID. The
.B priocntl()
function applies
to all LWPs with this zone ID.
.RE

.sp
.ne 2
.mk
.na
.B P_CTID
.ad
.RS 12n
.rt
The
.I id
.RB "argument is a process contract ID. The" " priocntl()"
function applies to all LWPs with this process contract ID.
.RE

.sp
.LP
An
.I id
value of
.B P_MYID
can be used in conjunction with the
.I idtype
value to specify the LWP ID, parent process ID, process group
ID, session ID, task ID, class ID, user ID, group ID, project ID, zone ID,
or process contract ID of the calling LWP.
.sp
.LP
To change the scheduling parameters of an LWP (using the \fBPC_SETPARMS\fR
or
.B PC_SETXPARMS
command as explained below) , the real or effective
user ID of the LWP calling
.B priocntl()
must match the real or the
calling LWP must have sufficient privileges. These are the minimum
permission requirements enforced for all classes. An individual class might
impose additional permissions requirements when setting LWPs to that class
and/or when setting class-specific scheduling parameters.
.sp
.LP
A special
.B SYS
scheduling class exists for the purpose of scheduling
the execution of certain special system processes (such as the swapper
process). It is not possible to change the class of any LWP to
.BR SYS .
In
addition, any processes in the
.B SYS
class that are included in a
specified set of processes are disregarded by
.BR priocntl() .
For
example, an
.I idtype
of
.B P_UID
and an
.I id
value of 0 would
specify all processes with a user ID of 0 except processes in the
.BR SYS
class and (if changing the parameters using
.B PC_SETPARMS
or
.BR PC_SETXPARMS )
the
.BR init "(1M) process."
.sp
.LP
The
.B init
process is a special case. For a
.B priocntl()
call to
change the class or other scheduling parameters of the
.I init
process
(process ID 1), it must be the only process specified by
.I idtype
and
.IR id .
The
.B init
process can be assigned to any class configured on
the system, but the time-sharing class is almost always the appropriate
choice. (Other choices might be highly undesirable. See the \fISystem
Administration Guide: Basic Administration\fR for more information.)
.sp
.LP
The data type and value of
.I arg
are specific to the type of command
specified by
.IR cmd .
.sp
.LP
A
.B pcinfo_t
structure with the following members, defined in
.BR <sys/priocntl.h> ,
is used by the
.B PC_GETCID
and
.B PC_GETCLINFO
commands.
.sp
.in +2
.nf
id_t   pc_cid;                   /* Class id */
char   pc_clname[PC_CLNMSZ];     /* Class name */
int    pc_clinfo[PC_CLINFOSZ];   /* Class information */
.fi
.in -2

.sp
.LP
The
.I pc_cid
member is a class ID returned by the
.BR priocntl()
.B PC_GETCID
command.
.sp
.LP
The
.I pc_clname
member is a buffer of size
.BR PC_CLNMSZ ,
defined in
.BR <sys/priocntl.h> ,
used to hold the class name:
.B RT
for realtime,
.B TS
for time-sharing, \fBIA\fRfor interactive, \fBFSS\fR for
fair-share, or
.B FX
for fixed-priority. Each string is
null-terminated.
.sp
.LP
The
.I pc_clinfo
member is a buffer of size
.BR PC_CLINFOSZ ,
defined
in
.BR <sys/priocntl.h> ,
used to return data describing the attributes of
a specific class. The format of this data is class-specific and is described
under the appropriate heading (\fBREALTIME CLASS\fR, \fBTIME-SHARING
CLASS\fR,
.BR "INTERACTIVE CLASS" ,
.BR "FAIR-SHARE CLASS" ,
or
.BR "FIXED-PRIORITY CLASS" )
below.
.sp
.LP
A
.B pcparms_t
structure with the following members, defined in
.BR <sys/priocntl.h> ,
is used by the
.B PC_SETPARMS
and
.B PC_GETPARMS
commands.
.sp
.in +2
.nf
id_t  pc_cid;                   /* LWP class */
int   pc_clparms[PC_CLPARMSZ];  /* Class-specific params */
.fi
.in -2

.sp
.LP
The
.I pc_cid
member is a class ID returned by the
.BR priocntl()
.B PC_GETCID
command. The special class ID
.B PC_CLNULL
can also be
assigned to
.I pc_cid
when using the
.B PC_GETPARMS
command as
explained below.
.sp
.LP
The
.I pc_clparms
buffer holds class-specific scheduling parameters. The
format of this parameter data for a particular class is described under the
appropriate heading below.
.B PC_CLPARMSZ
is the length of the
.I pc_clparms
buffer and is defined in
.BR <sys/priocntl.h> .
.sp
.LP
The
.B PC_SETXPARMS
and
.B PC_GETXPARMS
commands exploit the
.B varargs
declaration of
.BR priocntl() .
The argument following the
command code is a class name:
.B RT
for realtime,
.B TS
for
time-sharing,
.B IA
for interactive,
.B FSS
for fair-share, or
.B FX
for fixed-priority. The parameters  after the class name build a
chain of (key, value) pairs, where the key  determines the meaning of the
value within the pair. When using
.BR PC_GETXPARMS ,
the value associated
with the key is always a pointer to a scheduling parameter. In contrast,
when using
.B PC_SETXPARMS
the scheduling parameter is given as a direct
value. A key value of
.B 0
terminates the sequence and all further keys
or values are ignored.
.sp
.LP
The
.B PC_SETXPARMS
and
.B PC_GETXPARMS
commands are more flexible
than
.B PC_SETPARMS
and
.B PC_GETPARMS
and should replace
.B PC_SETPARMS
and
.B PC_GETPARMS
on a long-term basis.
.SH COMMANDS
.sp
.LP
Available
.B priocntl()
commands are:
.sp
.ne 2
.mk
.na
.B PC_ADMIN
.ad
.RS 16n
.rt
This command provides functionality needed for the implementation of the
.BR dispadmin (1M)
utility. It is not intended for general use by other
applications.
.RE

.sp
.ne 2
.mk
.na
.B PC_DONICE
.ad
.RS 16n
.rt
Set or get nice value of the specified LWP(s) associated with the specified
process(es). When this command is used with the
.I idtype
of
.BR P_LWPID ,
it sets the nice value of the LWP. The
.I arg
argument
points to a structure of type
.BR pcnice_t .
The
.I pc_val
member
specifies the nice value and the
.I pc_op
specifies the type of the
operation.
.sp
When
.I pc_op
is set to
.BR PC_GETNICE ,
.B priocntl()
sets the
.I pc_val
to the highest priority (lowest numerical value) pertaining to
any of the specified LWPs.
.sp
When
.I pc_op
is set to
.BR PC_SETNICE ,
.B priocntl()
sets the nice
value of all LWPs in the specified set to the value specified in
.I pc_val
member of
.B pcnice_t
structure.
.sp
The
.B priocntl()
function returns \fB\(mi1\fR with
.B errno
set to
.B EPERM
if the calling LWP doesn't have appropriate permissions to set
or get nice values for one or more of the target LWPs. If \fBpriocntl()\fR
encounters an error other than permissions, it does not continue through the
set of target LWPs but returns the error immediately.
.RE

.sp
.ne 2
.mk
.na
.B PC_GETCID
.ad
.RS 16n
.rt
Get class ID and class attributes for a specific class given the class
name. The
.I idtype
and
.I id
arguments are ignored. If
.I arg
is
non-null, it points to a structure of type
.BR pcinfo_t .
The
.I pc_clname
buffer contains the name of the class whose attributes you
are getting.
.sp
On success, the class ID is returned in
.BR pc_cid ,
the class attributes
are returned in the
.I pc_clinfo
buffer, and the
.B priocntl()
call
returns the total number of classes configured in the system (including the
.B sys
class). If the class specified by
.I pc_clname
is invalid or is
not currently configured, the
.B priocntl()
call returns \fB\(mi1\fR with
.B errno
set to
.BR EINVAL .
The format of the attribute data returned
for a given class is defined in the
.BR <sys/rtpriocntl.h> ,
.BR <sys/tspriocntl.h> ,
.BR <sys/iapriocntl.h> ,
.BR <sys/fsspriocntl.h> ,
or
.B <sys/fxpriocntl.h>
header and described
under the appropriate heading below.
.sp
If
.I arg
is a null pointer, no attribute data is returned but the
.B priocntl()
call still returns the number of configured classes.
.RE

.sp
.ne 2
.mk
.na
.B PC_GETCLINFO
.ad
.RS 16n
.rt
Get class name and class attributes for a specific class given class ID.
The
.I idtype
and
.I id
arguments are ignored. If
.I arg
is
non-null, it points to a structure of type
.BR pcinfo_t .
The
.IR pc_cid
member is the class ID of the class whose attributes you are getting.
.sp
On success, the class name is returned in the
.I pc_clname
buffer, the
class attributes are returned in the
.I pc_clinfo
buffer, and the
.B priocntl()
call returns the total number of classes configured in the
system (including the
.B sys
class). The format of the attribute data
returned for a given class is defined in the
.BR <sys/rtpriocntl.h> ,
.BR <sys/tspriocntl.h> ,
.BR <sys/iapriocntl.h> ,
.BR <sys/fsspriocntl.h> ,
or
.B <sys/fxpriocntl.h>
header and described
under the appropriate heading below.
.sp
If
.I arg
is a null pointer, no attribute data is returned but the
.B priocntl()
call still returns the number of configured classes.
.RE

.sp
.ne 2
.mk
.na
.B PC_GETPARMS
.ad
.RS 16n
.rt
Get the class and/or class-specific scheduling parameters of an LWP. The
.I arg
member points to a structure of type
.BR pcparms_t .
.sp
If
.I pc_cid
specifies a configured class and a single LWP belonging to
that class is specified  by the
.I idtype
and
.I id
values or the
.B procset
structure, then the scheduling parameters of that LWP are
returned in the
.I pc_clparms
buffer. If the LWP specified does not exist
or does not belong to the specified class, the
.B priocntl()
call returns
\fB\(mi1\fR with \fBerrno\fR set to
.BR ESRCH .
.sp
If
.I pc_cid
specifies a configured class and a set of LWPs is
specified, the scheduling parameters of one of the specified LWP belonging
to the specified class are returned in the
.I pc_clparms
buffer and the
.B priocntl()
call returns the process ID of the selected LWP. The
criteria for selecting an LWP to return in this case is class-dependent. If
none of the specified LWPs exist or none of them belong to the specified
class, the
.B priocntl()
call returns \fB\(mi1\fR with
.B errno
set to
.BR ESRCH .
.sp
If
.I pc_cid
is
.B PC_CLNULL
and a single LWP is specified, the class
of the specified LWP is returned in
.I pc_cid
and its scheduling
parameters are returned in the
.I pc_clparms
buffer.
.RE

.sp
.ne 2
.mk
.na
.B PC_GETXPARMS
.ad
.RS 16n
.rt
Get the class or class-specific scheduling parameters of an LWP. The class
name (first argument after
.BR PC_GETXPARMS )
specifies the class and the
(key, value) pair sequence contains a pointer to the class-specific
parameters. The keys and the types of the class-specific parameter data are
described below and can also be found in the class-specific headers
.BR <sys/rtpriocntl.h> ,
.BR <sys/tspriocntl.h> ,
.BR <sys/iapriocntl.h> ,
.BR <sys/fsspriocntl.h> ,
and
.BR <sys/fxpriocntl.h> .
If the specified class is a configured class and a
single LWP belonging to that class is specified by the
.I idtype
and
.I id
values or the
.B procset
structure, then the scheduling
parameters of that LWP are returned in the  given (key, value) pair buffers.
If the LWP specified does not exist or does not belong to the specified
class,
.B priocntl()
returns \fB\(mi1\fR and
.B errno
is set to
.BR ESRCH .
.sp
If the class name specifies a configured class and a set of LWPs is given,
the scheduling parameters of one of the specified LWPs belonging to the
specified class are returned and the
.B priocntl()
call returns the
process ID of the selected LWP. The criteria for selecting an LWP to return
in this case is class-dependent. If none of the specified LWPs exist or none
of them belong to the specified class,
.B priocntl()
returns \fB\(mi1\fR
and
.B errno
is set to
.BR ESRCH .
.sp
If the class name is a null pointer, a single process or LWP is specified,
and a (key, value) pair for a class name request is given, \fBpriocntl()\fR
fills the buffer pointed to by value with the class name of the specified
process or LWP. The key for the class name  request is \fBPC_KY_CLNAME\fR
and the class name buffer should be declared as:
.sp
.in +2
.nf
char   pc_clname[PC_CLNMSZ];     /* Class name */
.fi
.in -2

.RE

.sp
.ne 2
.mk
.na
.B PC_SETPARMS
.ad
.RS 16n
.rt
Set the class and class-specific scheduling parameters of the specified
LWP(s) associated with the specified process(es). When this command is used
with the
.I idtype
of P_LWPID, it will set the class and class-specific
scheduling parameters of the LWP.  The
.I arg
argument points to a
structure of type
.BR pcparms_t .
The
.I pc_cid
member specifies the
class you are setting and the
.I pc_clparms
buffer contains the
class-specific parameters you are setting. The format of the class-specific
parameter data is defined in the
.BR <sys/rtpriocntl.h> ,
.BR <sys/tspriocntl.h> ,
.BR <sys/iapriocntl.h> ,
.BR <sys/fsspriocntl.h> ,
or
.B <sys/fxpriocntl.h>
header and described
under the appropriate class heading below.
.sp
When setting parameters for a set of LWPs,
.B priocntl()
acts on the
LWPs in the set in an implementation-specific order. If \fBpriocntl()\fR
encounters an error for one or more of the target processes, it might or
might not continue through the set of LWPs, depending on the nature of the
error. If the error is related to permissions
.RB ( EPERM ),
.B priocntl()
continues through the LWP set, resetting the parameters for
all target LWPs for which the calling LWP has appropriate permissions.  The
.B priocntl()
function then returns \fB\(mi1\fR with
.B errno
set to
.B EPERM
to indicate that the operation failed for one or more of the
target LWPs. If
.B priocntl()
encounters an error other than permissions,
it does not continue through the set of target LWPs but returns the error
immediately.
.RE

.sp
.ne 2
.mk
.na
.B PC_SETXPARMS
.ad
.RS 16n
.rt
Set the class and class-specific scheduling parameters of the specified
LWP(s) associated with the specified process(es). When this command is used
with
.B P_LWPID
as
.IR idtype ,
it will set the class and class-specific
scheduling parameters of the LWP. The class name (first argument after
.BR PC_SETXPARMS )
specifies the class to be changed and the following
(key, value) pair sequence contains the class-specific parameters to be
changed. Only those (key,value) pairs whose scheduling behavior is to change
must be specified. The keys and the types of the class-specific parameter
data are described below and can also be found in the class-specific header
files
.BR <sys/rtpriocntl.h> ,
.BR <sys/tspriocntl.h> ,
.BR <sys/iapriocntl.h> ,
.BR <sys/fsspriocntl.h> ,
and
.BR <sys/fxpriocntl.h> .
.sp
When setting parameters for a set of LWPs,
.B priocntl()
acts on the
LWPs in the set in an implementation-specific order. If \fBpriocntl()\fR
encounters an error for one or more of the target processes, it might or
might not continue through the set of LWPs, depending on the nature of the
error. If the error is related to permissions
.RB ( EPERM ),
.B priocntl()
continues to reset the parameters for all target LWPs where
the calling LWP has appropriate permissions. The
.B priocntl()
function
returns \fB\(mi1\fR and
.B errno
is set to
.B EPERM
when the operation
failed for one or more of the target LWPs. All errors other than \fBEPERM\fR
result in an immediate termination of
.BR priocntl() .
.RE

.SH REALTIME CLASS
.sp
.LP
The realtime class provides a fixed priority preemptive scheduling policy
for those LWPS requiring fast and deterministic response and absolute
user/application control of scheduling priorities. If the realtime class is
configured in the system, it should have exclusive control of the highest
range of scheduling priorities on the system. This ensures that a runnable
realtime LWP is given CPU service before any LWP belonging to any other
class.
.sp
.LP
The realtime class has a range of realtime priority (\fIrt_pri\fR) values
that can be assigned to an LWP within the class. Realtime priorities range
from 0 to
.IR x ,
where the value of
.I x
is configurable and can be
determined for a specific installation by using the
.BR priocntl()
.B PC_GETCID
or
.B PC_GETCLINFO
command.
.sp
.LP
The realtime scheduling policy is a fixed priority policy. The scheduling
priority of a realtime LWP is never changed except as the result of an
explicit request by the user/application to change the
.I rt_pri
value of
the LWP.
.sp
.LP
For an LWP in the realtime class, the
.I rt_pri
value is, for all
practical purposes, equivalent to the scheduling priority of the LWP. The
.I rt_pri
value completely determines the scheduling priority of a
realtime LWP relative to other LWPs within its class. Numerically higher
.I rt_pri
values represent higher priorities. Since the realtime class
controls the highest range of scheduling priorities in the system, it is
guaranteed that the runnable realtime LWP with the highest
.IR rt_pri
value is always selected to run before any other LWPs in the system.
.sp
.LP
In addition to providing control over priority,
.B priocntl()
provides
for control over the length of the time quantum allotted to the LWP in the
realtime class. The time quantum value specifies the maximum amount of time
an LWP can run assuming that it does not complete or enter a resource or
event wait state
.RI ( sleep ).
If another LWP becomes runnable at a higher
priority, the currently running LWP might be preempted before receiving its
full time quantum.
.sp
.LP
The realtime quantum signal can be used for the notification of runaway
realtime processes about the consumption of their time quantum. Those
processes, which are monitored by the realtime time quantum signal, receive
the configured signal in the event of time quantum expiration. The default
value (\fB0\fR) of the time quantum signal will denote no signal delivery
and a positive value will denote the delivery of the signal specified by the
.RB "value. The realtime quantum signal can be set with the" " priocntl()"
.B PC_SETXPARMS
command and displayed with the
.BR priocntl()
.B PC_GETXPARMS
command as explained below.
.sp
.LP
The system's process scheduler keeps the runnable realtime LWPs on a set of
scheduling queues. There is a separate queue for each configured realtime
priority and all realtime LWPs with a given
.I rt_pri
value are kept
together on the appropriate queue. The LWPs on a given queue are ordered in
FIFO order (that is, the LWP at the front of the queue has been waiting
longest for service and receives the CPU first). Realtime LWPs that wake up
after sleeping, LWPs that change to the realtime class from some other
class, LWPs that have used their full time quantum, and runnable LWPs whose
priority is reset by
.B priocntl()
are all placed at the back of the
appropriate queue for their priority. An LWP that is preempted by a higher
priority LWP remains at the front of the queue (with whatever time is
remaining in its time quantum) and runs before any other LWP at this
priority. Following a
.BR fork (2)
function call by a realtime LWP, the
parent LWP continues to run while the child LWP (which inherits its parent's
.B rt_pri
value) is placed at the back of the queue.
.sp
.LP
A
.B rtinfo_t
structure with the following members, defined in
.BR <sys/rtpriocntl.h> ,
defines the format used for the attribute data for
the realtime class.
.sp
.in +2
.nf
short    rt_maxpri;      /* Maximum realtime priority */
.fi
.in -2

.sp
.LP
The
.B "priocntl() PC_GETCID"
and
.B PC_GETCLINFO
commands return
realtime class attributes in the
.I pc_clinfo
buffer in this format.
.sp
.LP
The
.B rt_maxpri
member specifies the configured maximum
.BR rt_pri
value for the realtime class. If
.I rt_maxpri
is
.BR x ,
the valid
realtime priorities range from 0 to
.IR x .
.sp
.LP
A
.B rtparms_t
structure with the following members, defined in
.BR <sys/rtpriocntl.h> ,
defines the format used to specify the realtime
class-specific scheduling parameters of an LWP.
.sp
.in +2
.nf
short    rt_pri;       /* Real-Time priority */
uint_t   rt_tqsecs;    /* Seconds in time quantum */
int      rt_tqnsecs;   /* Additional nanoseconds in quantum */
.fi
.in -2

.sp
.LP
When using the
.B "priocntl() PC_SETPARMS"
or
.BR PC_GETPARMS
commands, if
.B pc_cid
specifies the realtime class, the data in the
.I pc_clparms
buffer are in this format.
.sp
.LP
These commands can be used to set the realtime priority to the specified
value or get the current
.I rt_pri
value. Setting the
.B rt_pri
value
of an LWP that is currently running or runnable (not sleeping) causes the
LWP to be placed at the back of the scheduling queue for the specified
priority. The LWP is placed at the back of the appropriate queue regardless
of whether the priority being set is different from the previous
.I rt_pri
value of the LWP. A running LWP can voluntarily release the CPU
and go to the back of the scheduling queue at the same priority by resetting
its
.I rt_pri
value to its current realtime priority value. To change the
time quantum of an LWP without setting the priority or affecting the LWP's
position on the queue, the
.I rt_pri
member should be set to the special
value
.BR RT_NOCHANGE ,
defined in
.BR <sys/rtpriocntl.h> .
Specifying
.B RT_NOCHANGE
when changing the class of an LWP to realtime from some
other class results in the realtime priority being set to 0.
.sp
.LP
For the
.B "priocntl() PC_GETPARMS"
command, if \fIpc_cid\fR
specifies the realtime class and more than one realtime LWP is specified,
the scheduling parameters of the realtime LWP with the highest
.IR rt_pri
value among the specified LWPs are returned and the LWP ID of this LWP is
returned by the
.B priocntl()
call. If there is more than one LWP sharing
the highest priority, the one returned is implementation-dependent.
.sp
.LP
The
.I rt_tqsecs
and
.I rt_tqnsecs
members are used for getting or
setting the time quantum associated with an LWP or group of LWPs.
.I rt_tqsecs
is the number of seconds in the time quantum and
.B rt_tqnsecs
is the number of additional nanoseconds in the quantum. For
example, setting
.I rt_tqsecs
to 2 and
.B rt_tqnsecs
to 500,000,000
(decimal) would result in a time quantum of two and one-half seconds.
Specifying a value of 1,000,000,000 or greater in the \fIrt_tqnsecs\fR
member results in an error return with
.B errno
set to
.BR EINVAL .
Although the resolution of the
.I tq_nsecs
member is very fine, the
specified time quantum length is rounded up by the system to the next
integral multiple of the system clock's resolution. The maximum time quantum
that can be specified is implementation-specific and equal to
.BR INT_MAX 1
ticks. The
.B INT_MAX
value is defined in
.BR <limits.h> .
Requesting a
quantum greater than this maximum results in an error return with
.B errno
set to
.BR ERANGE ,
although infinite quantums can be requested
using a special value as explained below. Requesting a time quantum of 0 by
setting both
.I rt_tqsecs
and
.B rt_tqnsecs
to 0 results in an error
return with
.B errno
set to
.BR EINVAL .
.sp
.LP
The
.I rt_tqnsecs
member can also be set to one of the following special
values defined in
.BR <sys/rtpriocntl.h> ,
in which case the value of
.I rt_tqsecs
is ignored:
.sp
.ne 2
.mk
.na
.B RT_TQINF
.ad
.RS 15n
.rt
Set an infinite time quantum.
.RE

.sp
.ne 2
.mk
.na
.B RT_TQDEF
.ad
.RS 15n
.rt
Set the time quantum to the default for this priority (see
.BR rt_dptbl (4)).
.RE

.sp
.ne 2
.mk
.na
.B RT_NOCHANGE
.ad
.RS 15n
.rt
Do not set the time quantum. This value is useful when you wish to change
the realtime priority of an LWP without affecting the time quantum.
Specifying this value when changing the class of an LWP to realtime from
some other class is equivalent to specifying
.BR RT_TQDEF .
.RE

.sp
.LP
When using the
.B "priocntl() PC_SETXPARMS"
or
.BR PC_GETXPARMS
commands, the first argument after the command code must be the class name
of the realtime class (\fBRT\fR) . The next arguments are formed as (key,
value) pairs, terminated by a
.B 0
key. The definition for the keys of
the realtime class can be found in
.BR <sys/rtpriocntl.h> .
A repeated
specification of the same key results in an error return and
.B errno
set
to
.BR EINVAL .
.sp

.sp
.TS
tab() box;
cw(1.44i) |cw(1.08i) |cw(2.98i)
lw(1.44i) |lw(1.08i) |lw(2.98i)
.
KeyValue TypeDescription
_
\fBRT_KY_PRI\fR\fBpri_t\fRrealtime priority
\fBRT_KY_TQSECS\fR\fBuint_t\fRseconds in time quantum
_
\fBRT_KY_TQNSECS\fR\fBint\fRnanoseconds in time quantum
_
\fBRT_KY_TQSIG\fR\fBint\fRrealtime time quantum signal
.TE

.sp
.LP
When using the
.B "priocntl() PC_GETXPARMS"
command, the value
associated with the key is always a pointer to a scheduling parameter of the
value type shown in the table above. In contrast, when using the
.B priocntl() PC_SETXPARMS
command, the scheduling parameter is
given as a  direct value.
.sp
.LP
A
.B "priocntl() PC_SETXPARMS"
command with the class name
(\fBRT\fR) and without a following (key, value) pair will set or reset all
realtime scheduling parameters of the target process(es) to their default
values. Changing the class of an LWP to realtime from some other class
causes the parameters to be set to their default values. The default
realtime priority (\fBRT_KY_PRI\fR) is
.BR 0 .
A default time quantum
(\fBRT_TQDEF\fR) is assigned to each priority class (see
.BR rt_dptbl (4)).
The default realtime time quantum signal (\fBRT_KY_TQSIG\fR) is
.BR 0 .
.sp
.LP
The value associated with
.B RT_KY_TQSECS
is the number of seconds in
the time quantum. The value associated with
.B RT_KY_TQNSECS
is the
number of nanoseconds in the quantum. Specifying a value of 1,000,000,000 or
greater for the number of nanoseconds results in an error return and
.B errno
is set to
.BR EINVAL .
The specified time quantum is rounded up
by the system to the next integral multiple of the system clock's
resolution. The maximum time quantum that can be specified is
implementation-specific and equal to
.B INT_MAX
ticks, defined in
.BR <limits.h> .
Requesting a quantum greater than this maximum results in
an error return and
.B errno
is set to
.BR ERANGE .
If seconds
(\fBRT_KY_TQSECS\fR) but no nanoseconds (\fBRT_KY_TQNSECS\fR) are supplied,
the number of nanoseconds is set to
.BR 0 .
If nanoseconds
(\fBRT_KY_TQNSECS\fR) but no seconds (\fBRT_KY_TQSECS\fR) are supplied, the
number of seconds is set to
.BR 0 .
A time quantum of
.B 0
(seconds and
nanoseconds are
.BR 0 )
results in an error return with
.B errno
set to
.BR EINVAL .
Special values for
.B RT_KY_TQSECS
are
.B RT_TQINF
and
.B RT_TQDEF
(as described above). The
.B priocntl()
command
.B PC_SETXPARMS
knows no special value
.BR RT_NOCHANGE .
.sp
.LP
To change the class of an LWP to realtime from any other class, the LWP
invoking
.B priocntl()
must have sufficient privileges. To change the
priority or time quantum setting of a realtime LWP, the LWP invoking
.B priocntl()
must have sufficient privileges or must itself be a
realtime LWP whose real or effective user ID matches the real of effective
user ID of the target LWP.
.sp
.LP
The realtime priority and time quantum are inherited across
.BR fork (2)
and the
.B exec
family of functions. When using the time quantum signal
with a user-defined signal handler across the
.B exec
functions, the new
image must install an appropriate user-defined signal handler before the
time quantum expires. Otherwise, unpredictable behavior might result.
.SH TIME-SHARING CLASS
.sp
.LP
The time-sharing scheduling policy provides for a fair and effective
allocation of the CPU resource among LWPs with varying CPU consumption
characteristics. The objectives of the time-sharing policy are to provide
good response time to interactive LWPs and good throughput to CPU-bound
jobs, while providing a degree of user/application control over
scheduling.
.sp
.LP
The time-sharing class has a range of time-sharing user priority (see
.I ts_upri
below) values that can be assigned to LWPs within the class. A
.I ts_upri
value of 0 is defined as the default base priority for the
time-sharing class. User priorities range from \(mi\fIx\fR to +\fIx\fR where
the value of
.I x
is configurable and can be determined for a specific
installation by using the
.B "priocntl() PC_GETCID"
or
.B PC_GETCLINFO
command.
.sp
.LP
The purpose of the user priority is to provide some degree of
user/application control over the scheduling of LWPs in the time-sharing
class. Raising or lowering the
.I ts_upri
value of an LWP in the
time-sharing class raises or lowers the scheduling priority of the LWP. It
is not guaranteed, however, that an LWP with a higher
.I ts_upri
value
will run before one with a lower
.I ts_upri
value, since the
.I ts_upri
value is just one factor used to determine the scheduling
priority of a time-sharing LWP. The system can dynamically adjust the
internal scheduling priority of a time-sharing LWP based on other factors
such as recent CPU usage.
.sp
.LP
In addition to the system-wide limits on user priority (returned by the
.B PC_GETCID
and
.B PC_GETCLINFO
commands) there is a per LWP user
priority limit (see
.I ts_uprilim
below) specifying the maximum
.I ts_upri
value that can be set for a given LWP. By default,
.I ts_uprilim
is 0.
.sp
.LP
A
.B tsinfo_t
structure with the following members, defined in
.BR <sys/tspriocntl.h> ,
defines the format used for the attribute data for
the time-sharing class.
.sp
.in +2
.nf
short    ts_maxupri;     /* Limits of user priority range */
.fi
.in -2

.sp
.LP
The
.B "priocntl() PC_GETCID"
and
.B PC_GETCLINFO
commands return
time-sharing class attributes in the
.B pc_clinfo
buffer in this
format.
.sp
.LP
The
.B ts_maxupri
member specifies the configured maximum user priority
value for the time-sharing class. If
.B ts_maxupri
is
.IR x ,
the valid
range for both user priorities and user priority limits is from \(mi\fIx\fR
to +\fIx\fR.
.sp
.LP
A
.B tsparms_t
structure with the following members, defined in
.BR <sys/tspriocntl.h> ,
defines the format used to specify the
time-sharing class-specific scheduling parameters of an LWP.
.sp
.in +2
.nf
short    ts_uprilim;     /* Time-Sharing user priority limit */
short    ts_upri;        /* Time-Sharing user priority */
.fi
.in -2

.sp
.LP
When using the
.B "priocntl() PC_SETPARMS"
or
.BR PC_GETPARMS
commands, if
.B pc_cid
specifies the time-sharing class, the data in the
.B pc_clparms
buffer is in this format.
.sp
.LP
For the
.B "priocntl() PC_GETPARMS"
command, if \fBpc_cid\fR
specifies the time-sharing class and more than one time-sharing LWP is
specified, the scheduling parameters of the time-sharing LWP with the
highest
.I ts_upri
value among the specified LWPs is returned and the LWP
ID of this LWP is returned by the
.B priocntl()
call. If there is more
than one LWP sharing the highest user priority, the one returned is
implementation-dependent.
.sp
.LP
Any time-sharing LWP can lower its own
.I ts_uprilim
(or that of another
LWP with the same user ID). Only a time-sharing LWP with sufficient
privileges can raise a
.IR ts_uprilim .
When changing the class of an LWP
to time-sharing from some other class, sufficient privileges are required to
set the initial
.I ts_uprilim
to a value greater than 0. Attempts by an
unprivileged LWP to raise a
.I ts_uprilim
or set an initial
.I ts_uprilim
greater than 0 fail with a return value of \(mi1 and
.B errno
set to
.BR EPERM .
.sp
.LP
Any time-sharing LWP can set its own
.I ts_upri
(or that of another LWP
with the same user ID) to any value less than or equal to the LWP's
.IR ts_uprilim .
Attempts to set the
.I ts_upri
above the
.I ts_uprilim
(and/or set the
.I ts_uprilim
below the
.IR ts_upri )
result in the
.I ts_upri
being set equal to the
.IR ts_uprilim .
.sp
.LP
Either of the
.I ts_uprilim
or
.I ts_upri
members can be set to the
special value
.BR TS_NOCHANGE ,
defined in
.BR <sys/tspriocntl.h> ,
to set
one of the values without affecting the other. Specifying \fBTS_NOCHANGE\fR
for the
.I ts_upri
when the
.I ts_uprilim
is being set to a value
below the current
.I ts_upri
causes the
.I ts_upri
to be set equal to
the
.I ts_uprilim
being set. Specifying
.B TS_NOCHANGE
for a parameter
when changing the class of an LWP to time-sharing (from some other class)
causes the parameter to be set to a default value. The default value for the
.I ts_uprilim
is
.B 0
and the default for the
.I ts_upri
is to set
it equal to the
.I ts_uprilim
that is being set.
.sp
.LP
When using the
.B "priocntl() PC_SETXPARMS"
or
.BR PC_GETXPARMS
commands, the first argument after the command code is the class name of the
time-sharing class (\fBTS\fR) . The next arguments are formed as (key,
value) pairs, terminated by a
.B 0
key. The definition for the keys of
the time-sharing class can be found in
.BR <sys/tspriocntl.h> .
A repeated
specification of the same key results in an error return and
.B errno
set
to
.BR EINVAL .
.sp

.sp
.TS
tab() box;
cw(1.44i) |cw(1.08i) |cw(2.98i)
lw(1.44i) |lw(1.08i) |lw(2.98i)
.
KeyValue TypeDescription
_
\fBTS_KY_UPRILIM\fR\fBpri_t\fRuser priority limit
\fBTS_KY_UPRI\fR\fBpri_t\fRuser priority
.TE

.sp
.LP
When using the
.B "priocntl() PC_GETXPARMS"
command, the value
associated with the key is always a pointer to a scheduling parameter of the
.RB "value type in the table above. In contrast, when using the" " priocntl()"
.B PC_SETXPARMS
command, the scheduling parameter is given as a direct
value.
.sp
.LP
A
.B "priocntl() PC_SETXPARMS"
command with the class name
(\fBTS\fR) and without a following (key, value) pair will set or reset all
time-sharing scheduling parameters of the target process(es) to their
default values. Changing the class of an LWP to time-sharing from some other
class causes the parameters to be set to their default values. The default
value for the user priority limit (\fBTS_KY_UPRILIM\fR) is
.BR 0 .
The
default value for the user priority (\fBTS_KY_UPRI\fR) is equal to the user
priority limit (\fBTS_KY_UPRILIM\fR) that is being set.
.sp
.LP
The
.B priocntl()
command
.B PC_SETXPARMS
knows no special value
.BR TS_NOCHANGE .
.sp
.LP
The time-sharing user priority and user priority limit are inherited across
.B fork()
and the
.B exec
family of functions.
.SH INTERACTIVE CLASS
.sp
.LP
The interactive scheduling policy is a variation on the time-sharing
scheduling policy. All that can be said about the time-sharing scheduling
policy is also true for the interactive scheduling policy, with one
addition: An LWP in the interactive class with its
.I ia_mode
value set
to
.B IA_SET_INTERACTIVE
has its time-sharing priority boosted by
.B IA_BOOST
(10).
.sp
.LP
An
.B iainfo_t
structure with the following members, defined in
.BR <sys/iapriocntl.h> ,
defines the format used for the attribute data for
the interactive class.
.sp
.in +2
.nf
short    ia_maxupri;     /* Limits of user priority range */
.fi
.in -2

.sp
.LP
The
.B "priocntl() PC_GETCID"
and
.B PC_GETCLINFO
commands return
interactive class attributes in the
.I pc_clinfo
buffer in this format.
.sp
.LP
The
.I ia_maxupri
member specifies the configured maximum user priority
value for the interactive class. If
.I ia_maxupri
is
.BR x ,
the valid
range for both user priorities and user priority limits is from -x to +x.
.sp
.LP
A
.B iaparms_t
structure with the following members, defined in
.BR <sys/iapriocntl.h> ,
defines the format used to specify the interactive
class-specific scheduling parameters of an LWP.
.sp
.in +2
.nf
short    ia_uprilim;     /* Interactive user priority limit */
short    ia_upri;        /* Interactive user priority */
int      ia_mode;        /* interactive on/off */
.fi
.in -2

.sp
.LP
When using the
.B "priocntl() PC_SETPARMS"
or
.BR PC_GETPARMS
commands, if
.I pc_cid
specifies the interactive class, the data in the
.I pc_clparms
buffer is in this format.
.sp
.LP
For the
.B "priocntl() PC_GETPARMS"
command, if \fIpc_cid\fR
specifies the interactive class and more than one interactive LWP is
specified, the scheduling parameters of the interactive LWP with the highest
.I ia_upri
value among the specified LWPs is returned and the LWP ID of
this LWP is returned by the
.B priocntl()
call. If there is more than one
LWP sharing the highest user priority, the one returned is
implementation-dependent.
.sp
.LP
All that is said above in the TIME-SHARING CLASS section concerning
manipulation of
.I ts_uprilim
and
.I ts_upri
applies equally to
manipulations of
.I ia_uprilim
and
.I ia_upri
in the interactive
class.
.sp
.LP
When using the
.B PC_SETPARMS
command, the
.I ia_mode
member must be
set to one of the values
.BR IA_SET_INTERACTIVE ,
.BR IA_INTERACTIVE_OFF ,
or
.BR IA_NOCHANGE ,
defined in
.BR <sys/iapriocntl.h> ,
to set the
interactive mode on or off or to make no change to the interactive mode.
.sp
.LP
When using the
.B "priocntl() PC_SETXPARMS"
or
.BR PC_GETXPARMS
commands, the first argument after the command code is the class name of the
interactive class (IA) . The next arguments are formed as (key, value)
pairs, terminated by a 0 key. The definition for the keys of the interactive
class can be found in
.BR <sys/iapriocntl.h> .
A repeated specification of
the same key results in an error return and
.B errno
set to
.BR EINVAL .
.sp

.sp
.TS
tab();
cw(1.83i) cw(1.83i) cw(1.83i)
lw(1.83i) lw(1.83i) lw(1.83i)
.
KeyValue TypeDescription
\fBIA_KY_UPRILIM\fR\fBpri_t\fRuser priority limit
\fBIA_KY_UPRI\fR\fBpri_t\fRuser priority
\fBIA_KY_MODE\fR\fBint\fRinteractive mode
.TE

.sp
.LP
When using the
.B "priocntl() PC_GETXPARMS"
command, the value
associated with the key is always a pointer to a scheduling parameter of the
.RB "value type in the table above. In contrast, when using the" " priocntl()"
.B PC_SETXPARMS
command, the scheduling parameter is given as a direct
value.
.sp
.LP
A
.B "priocntl() PC_SETXPARMS"
command with the class name (IA) and
without a following (key, value) pair will set or reset all interactive
scheduling parameters of the target process(es) to their default values.
Changing the class of an LWP to interactive from some other class causes the
parameters to be set to their default values. The default value for the user
priority limit (\fBIA_KY_UPRILIM\fR) is 0. The default value for the user
priority (\fBIA_KY_UPRI\fR) is equal to the user priority limit
(\fBIA_KY_UPRILIM\fR) that is being set. The default value for the
interactive mode (\fBIA_KY_MODE\fR) is
.BR IA_SET_INTERACTIVE .
.sp
.LP
The
.B priocntl()
command
.B PC_SETXPARMS
knows no special value
.BR IA_NOCHANGE .
.sp
.LP
The interactive user priority and user priority limit are inherited across
fork and the exec family of functions.
.SH FAIR-SHARE CLASS
.sp
.LP
The fair-share scheduling policy provides a fair allocation of CPU
resources among projects, independent of the number of processes they
contain. Projects are given "shares" to control their quota of CPU
resources. See
.BR FSS (7)
for more information about how to configure
shares.
.sp
.LP
The fair share class supports the notion of per-LWP user priority (see
.B fss_upri
below) values for compatibility with the time-sharing
scheduling class. An
.I fss_upri
value of 0 is defined as the default
base priority for the fair-share class. User priorities range from -\fIx\fR
to +\fIx\fR where the value of \fIx\fR is configurable and can be determined
for a specific installation by using the
.B "priocntl() PC_GETCID"
or
.B PC_GETCLINFO
command.
.sp
.LP
The purpose of the user priority is to provide some degree of
user/application control over the scheduling of LWPs in the fair-share
class. Raising the
.B fss_upri
value of an LWP in the fair-share class
tells the scheduler to give this LWP more CPU time slices, while lowering
the
.B fss_upri
value tells the scheduler to give it less CPU slices. It
is not guaranteed, however, that an LWP with a higher
.B fss_upri
value
will run before one with a lower
.B fss_upri
value. This is because the
.B fss_upri
value is just one factor used to determine the scheduling
priority of a fair-share LWP. The system can dynamically adjust the internal
scheduling priority of a fair-share LWP based on other factors such as
recent CPU usage. The fair-share scheduler attempts to provide an evenly
graded effect across the whole range of user priority values.
.sp
.LP
User priority values do not interfere with project shares. That is,
changing a user priority value of a process does not have any effect on its
project CPU entitlement, which is based on the number of shares it is
allocated in comparison with other projects.
.sp
.LP
In addition to the system-wide limits on user priority (returned by the
.B PC_GETCID
and
.B PC_GETCLINFO
commands), there is a per-LWP user
priority limit (see
.I fss_uprilim
below) that specifies the maximum
.B fss_upri
value that can be set for a given LWP. By default,
.I fss_uprilim
is 0.
.sp
.LP
A
.B fssinfo_t
structure with the following members, defined in
.BR <sys/fsspriocntl.h> ,
defines  the format used for the attribute data
for the fair-share class.
.sp
.in +2
.nf
short    fss_maxupri;    /* Limits of user priority range */
.fi
.in -2

.sp
.LP
The
.B "priocntl() PC_GETCID"
and
.B PC_GETCLINFO
commands return
fair-share class attributes in the
.I pc_clinfo
buffer in this format.
.sp
.LP
.I fss_maxupri
specifies the configured maximum user priority value for
the fair-share class. If
.B fss_maxupri
is
.IR x ,
the valid range for
both user priorities and user priority limits is from -\fIx\fR to
+\fIx\fR.
.sp
.LP
A
.B fssparms_t
structure with the following members, defined in
.BR <sys/fsspriocntl.h> ,
defines the format used to specify the fair-share
class-specific scheduling parameters of an LWP.
.sp
.in +2
.nf
short    fss_uprilim;   /* Fair-share user priority limit */
short    fss_upri;      /* Fair-share user priority */
.fi
.in -2

.sp
.LP
When using the
.B "priocntl() PC_SETPARMS"
or
.BR PC_GETPARMS
commands, if
.I pc_cid
specifies the fair-share class, the data in the
.I pc_clparms
buffer is in this format.
.sp
.LP
For the
.B "priocntl() PC_GETPARMS"
command, if \fIpc_cid\fR
specifies the fair-share class and more than one fair-share LWP is
specified, the scheduling parameters of the  fair-share LWP with the highest
.I fss_upri
value among the specified LWPs is returned and the LWP ID of
this LWP is returned by the
.B priocntl()
call. If there is more than one
LWP sharing the highest user priority, the one returned is
implementation-dependent.
.sp
.LP
Any fair-share LWP can lower its own
.I fss_uprilim
(or that of another
LWP with the same user ID). Only a fair-share LWP with sufficient privileges
can raise an
.IR fss_uprilim .
When changing the class of an LWP to
fair-share from some other class, sufficient privileges are required to
enter the FSS class or to set the initial
.I fss_uprilim
to a value
greater than 0. Attempts by an unprivileged LWP to raise an
.I fss_uprilim
or set an initial
.I fss_uprilim
greater than 0 fail
with a return value of -1 and
.B errno
set to
.BR EPERM .
.sp
.LP
Any fair-share LWP can set its own
.I fss_upri
(or that of another LWP
with the same user ID) to any value less than or equal to the LWP's
.IR fss_uprilim .
Attempts to set the \fBfss_upr\fRi above the
.B fss_uprilim
(and/or set the
.I fss_uprilim
below the
.IR fss_upri )
result in the
.I fss_upri
being set equal to the
.IR fss_uprilim .
.sp
.LP
Either of the \fIfss_uprilim\fR or \fBfss_upri\fR members can be set to the
special value
.B FSS_NOCHANGE
(defined in
.BR <sys/fsspriocntl.h> )
to
set one of the values without affecting the other. Specifying
.B FSS_NOCHANGE
for the \fIfss_upri\fR when the \fIfss_uprilim\fR is
being set to a value below the current
.I fss_upri
causes the
.I fss_upri
to be set equal to the
.I fss_uprilim
being set.
Specifying
.B FSS_NOCHANGE
for a parameter when changing the class of an
LWP to fair-share (from some other class) causes the parameter to be set to
a default value. The default value for the
.B fss_uprilim
is 0 and the
default for the \fBfss_upri\fR is to set it equal to the \fIfss_uprilim\fR
which is being set.
.sp
.LP
The fair-share user priority and user priority limit are inherited across
.B fork()
and the
.B exec
family of functions.
.SH FIXED-PRIORITY CLASS
.sp
.LP
The fixed-priority class provides a fixed-priority preemptive scheduling
policy for those LWPs requiring that the scheduling priorities do not get
dynamically adjusted by the system and that the user/application have
control of the scheduling priorities.
.sp
.LP
The fixed-priority class has a range of fixed-priority user priority (see
.B fx_upri
below) values that can be assigned to LWPs within the class. A
.I fx_upri
value of 0 is defined as the default base priority for the
fixed-priority class. User priorities range from 0 to
.I x
where the
value of
.I x
is configurable and can be determined for a specific
installation by using the
.B "priocntl() PC_GETCID"
or
.B PC_GETCLINFO
command.
.sp
.LP
The purpose of the user priority is to provide user/application control
over the scheduling of processes in the fixed-priority class. For processes
in the fixed-priority class, the
.I fx_upri
value is, for all practical
purposes, equivalent to the scheduling priority of the process. The
.I fx_upri
value completely determines the scheduling priority of a
fixed-priority process relative to other processes within its class.
Numerically higher
.I fx_upri
values represent higher priorities.
.sp
.LP
In addition to the system-wide limits on user priority (returned by the
.B PC_GETCID
and
.B PC_GETCLINFO
commands), there is a per-LWP user
priority limit (see
.I fx_uprilim
below) that specifies the maximum
.I fx_upri
value that can be set for a given LWP. By default,
.I fx_uprilim
is 0.
.sp
.LP
A structure with the following member (defined in
.BR <sys/fxpriocntl.h> )
defines the format used for the attribute data for the fixed-priority
class.
.sp
.in +2
.nf
pri_t   fx_maxupri;      /* Maximum user priority */
.fi
.in -2

.sp
.LP
The
.B "priocntl() PC_GETCID"
and
.B PC_GETCLINFO
commands return
fixed-priority class attributes in the
.I pc_clinfo
buffer in this
format.
.sp
.LP
The
.I fx_maxupri
member specifies the configured maximum user priority
value for the fixed-priority class. If
.I fx_maxupri
is
.IR x ,
the
valid range for both user priorities and user priority limits is from 0 to
.IR x .
.sp
.LP
A structure with the following members (defined in
.BR <sys/fxpriocntl.h> )
defines the format used to specify the
fixed-priority class-specific scheduling parameters of an LWP.
.sp
.in +2
.nf
pri_t    fx_upri;     /* Fixed-priority user priority */
pri_t    fx_uprilim;  /* Fixed-priority user priority limit */
uint_t   fx_tqsecs;   /* seconds in time quantum */
int      fx_tqnsecs;  /* additional nanosecs in time quant */
.fi
.in -2

.sp
.LP
When using the
.B "priocntl() PC_SETPARMS"
or
.BR PC_GETPARMS
commands, if
.I pc_cid
specifies the fixed-priority class, the data in
the
.I pc_clparms
buffer is in this format.
.sp
.LP
For the
.B "priocntl() PC_GETPARMS"
command, if \fIpc_cid\fR
specifies the fixed-priority class and more than one fixed-priority LWP is
specified, the scheduling parameters of the fixed-priority LWP with the
highest
.I fx_upri
value among the specified LWPs is returned and the LWP
ID of this LWP is returned by the
.B priocntl()
call. If there is more
than one LWP sharing the highest user priority, the one returned is
implementation-dependent.
.sp
.LP
Any fixed-priority LWP can lower its own
.I fx_uprilim
(or that of
another LWP with the same user ID). Only a fixed-priority LWP with
sufficient privileges can raise a
.IR fx_uprilim .
When changing the class
of an LWP to fixed-priority from some other class, sufficient privileges are
required to set the initial
.I fx_uprilim
to a value greater than 0.
Attempts by an unprivileged LWP to raise a
.I fx_uprilim
or set an
initial
.B fx_uprilim
greater than 0 fail with a return value of -1 and
errno set to
.BR EPERM .
.sp
.LP
Any fixed-priority LWP can set its own
.I fx_upri
(or that of another
LWP with the same user ID) to any value less than or equal to the LWP's
.IR fx_uprilim .
Attempts to set the
.I fx_upri
above the
.B fx_uprilim
(and/or set the \fIfx_uprilim\fR below the \fIfx_upri\fR)
result in the \fBfx_upri\fR being set equal to the \fIfx_uprilim\fR.
.sp
.LP
Either of the \fIfx_uprilim\fR or \fIfx_upri\fR members can be set to the
special value
.B FX_NOCHANGE
(defined in
.BR <sys/fxpriocntl.h> )
to set
one of the values without affecting the other. Specifying \fBFX_NOCHANGE\fR
for the \fIfx_upri\fR when the \fIfx_uprilim\fR is being set to a value
below the current \fIfx_upri\fR causes the \fIfx_upri\fR to be set equal to
the \fIfx_uprilim\fR being set. Specifying \fBFX_NOCHANGE\fR for a parameter
when changing the class of an LWP to fixed-priority (from some other class)
causes the parameter to be set to a default value. The default value for the
.I fx_uprilim
is 0 and the default for the
.I fx_upri
is to set it
equal to the
.I fx_uprilim
that is being set. The default for time
quantum is dependent on the
.I fx_upri
and on the system configuration;
see
.BR fx_dptbl (4).
.sp
.LP
The \fIfx_tqsecs\fR and \fIfx_tqnsecs\fR members are used for getting or
setting the time quantum associated with an LWP or group of LWPs.
.I fx_tqsecs
is the number of seconds in the time quantum and
.I fx_tqnsecs
is the number of additional nanoseconds in the quantum. For
example, setting \fIfx_tqsecs\fR to 2 and \fIfx_tqnsecs\fR to 500,000,000
(decimal) would result in a time quantum of two and one-half seconds.
Specifying a value of 1,000,000,000 or greater in the \fIfx_tqnsecs\fR
member results in an error return with
.B errno
set to
.BR EINVAL .
Although the resolution of the
.I tq_nsecs
member is very fine, the
specified time quantum length is rounded up by the system to the next
integral multiple of the system clock's resolution. The maximum time quantum
that can be specified is implementation-specific and equal to \fBINT_MAX\fR
ticks (defined in
.BR <limits.h> ).
Requesting a quantum greater than this
maximum results in an error return with
.B errno
set to
.BR ERANGE ,
although infinite quantums can be requested using a special value as
explained below. Requesting a time quantum of 0 (setting both
.I fx_tqsecs
and
.I fx_tqnsecs
to 0) results in an error return with
.B errno
set to
.BR EINVAL .
.sp
.LP
The
.I fx_tqnsecs
member can also be set to one of the following special
values (defined in
.BR <sys/fxpriocntl.h> ),
in which case the value of
.I fx_tqsecs
is ignored:
.sp
.ne 2
.mk
.na
.B FX_TQINF
.ad
.RS 15n
.rt
Set an infinite time quantum.
.RE

.sp
.ne 2
.mk
.na
.B FX_TQDEF
.ad
.RS 15n
.rt
Set the time quantum to the default for this priority (see
.BR fx_dptbl (4)).
.RE

.sp
.ne 2
.mk
.na
.B FX_NOCHANGE
.ad
.RS 15n
.rt
Do not set the time quantum. This value is useful in changing the user
priority of an LWP without affecting the time quantum. Specifying this value
when changing the class of an LWP to fixed-priority from some other class is
equivalent to specifying
.BR FX_TQDEF .
.RE

.sp
.LP
When using the
.B "priocntl() PC_SETXPARMS"
or
.BR PC_GETXPARMS
commands, the first argument after the command code must be the class name
of the fixed-priority class (FX) . The next arguments are formed as (key,
value) pairs, terminated by a 0 key. The definition for the keys of the
fixed-priority class can be found in
.BR <sys/fxpriocntl.h> .
A repeated
specification of the same key results in an error return and
.B errno
set
to
.BR EINVAL .
.sp

.sp
.TS
tab() box;
cw(1.44i) |cw(1.08i) |cw(2.98i)
lw(1.44i) |lw(1.08i) |lw(2.98i)
.
KeyValue TypeDescription
_
\fBFX_KY_UPRILIM\fR\fBpri_t\fRuser priority limit
\fBFX_KY_UPRI\fR\fBpri_t\fRuser priority
_
\fBFX_KY_TQSECS\fR\fBuint_t\fRseconds in time quantum
_
\fBFX_KY_TQNSECS\fR\fBint\fRnanoseconds in time quantum
.TE

.sp
.LP
When using the
.B "priocntl() PC_GETXPARMS"
command, the value
associated with the key is always a pointer to a scheduling parameter of the
value type shown in the table above. In contrast, when using the
.B priocntl() PC_SETXPARMS
command, the scheduling parameter is
given as a direct value.
.sp
.LP
A
.B "priocntl() PC_SETXPARMS"
command with the class name (FX) and
without a following (key, value) pair will set or reset all realtime
scheduling parameters of the target process(es) to their default values.
Changing the class of an LWP to fixed-priority from some other class causes
the parameters to be set to their default values. The default value for the
user priority limit (\fBFX_KY_UPRILIM\fR) is 0. The default value for the
user priority (\fBFX_KY_UPRI\fR) is equal to the user priority limit
(\fBFX_KY_UPRILIM\fR) that is being set. A default time quantum
(\fBFX_TQDEF\fR) is assigned to each priority class (see
.BR fx_dptbl (4)).
.sp
.LP
The value associated with
.B FX_KY_TQSECS
is the number of seconds in
the time quantum. The value associated with
.B FX_KY_TQNSECS
is the
number of nanoseconds in the quantum. Specifying a value of 1,000,000,000 or
greater for the number of nanoseconds results in an error return and
.B errno
is set to
.BR EINVAL .
The specified time quantum is rounded up
by the system to the next integral multiple of the system clock's
resolution. The maximum time quantum that can be specified is
implementation-specific and equal to
.B INT_MAX
ticks, defined in
.BR <limits.h> .
Requesting a quantum greater than this maximum results in
an error return and
.B errno
is set to
.BR ERANGE .
If seconds
(\fBFX_KY_TQSECS\fR) but no nanoseconds (\fBFX_KY_TQNSECS\fR) are supplied,
the number of nanoseconds is set to 0. If nanoseconds (\fBFX_KY_TQNSECS\fR)
but no seconds (\fBFX_KY_TQSECS\fR) are supplied, the number of seconds is
set to 0. A time quantum of 0 (seconds and nanoseconds are 0) results in an
error return with
.B errno
set to
.BR EINVAL .
Special values for
.B FX_KY_TQSECS
are
.B FX_TQINF
and
.B FX_TQDEF
(as described
above). The
.B priocntl()
command
.B PC_SETXPARMS
knows no special
value
.BR FX_NOCHANGE .
.sp
.LP
The fixed-priority user priority and user priority limit are inherited
across
.BR fork (2)
and the
.B exec
family of functions.
.SH RETURN VALUES
.sp
.LP
Unless otherwise noted above,
.B priocntl()
returns
.B 0
on success.
On failure,
.B priocntl()
returns \fB\(mi1\fR and sets
.B errno
to
indicate the error.
.SH ERRORS
.sp
.LP
The
.B priocntl()
function will fail if:
.sp
.ne 2
.mk
.na
.B EAGAIN
.ad
.RS 10n
.rt
An attempt to change the class of an LWP failed because of insufficient
resources other than memory (for example, class-specific kernel data
structures).
.RE

.sp
.ne 2
.mk
.na
.B EFAULT
.ad
.RS 10n
.rt
One of the arguments points to an illegal address.
.RE

.sp
.ne 2
.mk
.na
.B EINVAL
.ad
.RS 10n
.rt
The argument
.I cmd
was invalid, an invalid or unconfigured class was
specified, or one of the parameters specified was invalid.
.RE

.sp
.ne 2
.mk
.na
.B ENOMEM
.ad
.RS 10n
.rt
An attempt to change the class of an LWP failed because of insufficient
memory.
.RE

.sp
.ne 2
.mk
.na
.B EPERM
.ad
.RS 10n
.rt
The {\fBPRIV_PROC_PRIOCNTL\fR} privilege is not asserted in the effective
set of the calling LWP.
.sp
The calling LWP does not have sufficient privileges to affect the target
LWP.
.RE

.sp
.ne 2
.mk
.na
.B ERANGE
.ad
.RS 10n
.rt
The requested time quantum is out of range.
.RE

.sp
.ne 2
.mk
.na
.B ESRCH
.ad
.RS 10n
.rt
None of the specified LWPs exist.
.RE

.SH SEE ALSO
.sp
.LP
.BR priocntl (1),
.BR dispadmin (1M),
.BR init (1M),
.BR exec (2),
.BR fork (2),
.BR nice (2),
.BR priocntlset (2),
.BR fx_dptbl (4),
.BR process (4),
.BR rt_dptbl (4),
.BR privileges (5)
.sp
.LP
.I System Administration Guide: Basic Administration
.sp
.LP
.I Programming Interfaces Guide
