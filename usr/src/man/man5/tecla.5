'\" te
.\" Copyright (c) 2000, 2001, 2002, 2003, 2004 by Martin C. Shepherd. All Rights Reserved.
.\" Permission is hereby granted, free of charge, to any person obtaining
.\" a copy of this software and associated documentation files (the
.\" "Software"), to deal in the Software without restriction, including
.\" without limitation the rights to use, copy, modify, merge, publish,
.\" distribute, and/or sell copies of the Software, and to permit persons
.\" to whom the Software is furnished to do so, provided that the above
.\" copyright notice(s) and this permission notice appear in all copies of
.\" the Software and that both the above copyright notice(s) and this
.\" permission notice appear in supporting documentation.
.\"
.\" THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
.\" OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
.\" MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT
.\" OF THIRD PARTY RIGHTS. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
.\" HOLDERS INCLUDED IN THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL
.\" INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING
.\" FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
.\" NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
.\" WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
.\"
.\" Except as contained in this notice, the name of a copyright holder
.\" shall not be used in advertising or otherwise to promote the sale, use
.\" or other dealings in this Software without prior written authorization
.\" of the copyright holder.
.\" Portions Copyright (c) 2005, Sun Microsystems, Inc. All Rights Reserved.
.\" Copyright (c) 2012-2013, J. Schilling
.\" Copyright (c) 2013, Andreas Roehler
.TH tecla 5 "20 May 2004" "SunOS 5.11" "Standards, Environments, and Macros"
.SH NAME
tecla, teclarc \- User interface provided by the tecla library.
.SH DESCRIPTION
.sp
.LP
This man page describes the command-line editing features that are available
to users of programs that read keyboard input via the tecla library. Users of
the
.B "tcsh shell"
will find the default key bindings very familiar. Users
of the
.B bash
shell will also find it quite familiar, but with a few minor
differences, most notably in how forward and backward searches through the
list of historical commands are performed. There are two major editing modes,
one with
.BR emacs -like
key bindings and another with \fBvi\fR-like key
bindings. By default
.B emacs
mode is enabled, but
.BR vi (1)
mode can
alternatively be selected via the user's configuration file. This file can
also be used to change the bindings of individual keys to suit the user's
preferences. By default, tab completion is provided. If the application hasn't
reconfigured this to complete other types of symbols, then tab completion
completes file names.
.SS "Key Sequence Notation"
.sp
.LP
In the rest of this man page, and also in all tecla configuration files, key
sequences are expressed as follows.
.sp
.ne 2
.mk
.na
.B ^A
or
.BR C-a
.ad
.RS 13n
.rt
This is a 'CONTROL-A', entered by pressing the CONTROL key at the same time
as the 'A' key.
.RE

.sp
.ne 2
.mk
.na
\fB\E\fR or \fBM-\fR
.ad
.RS 13n
.rt
In key sequences, both of these notations can be entered either by pressing
the ESCAPE key, then the following key, or by pressing the META key at the
same time as the following key. Thus the key sequence
.B M-p
can be typed
in two ways, by pressing the ESCAPE key, followed by pressing 'P', or by
pressing the META key at the same time as 'P'.
.RE

.sp
.ne 2
.mk
.na
.B up
.ad
.RS 13n
.rt
This refers to the up-arrow key.
.RE

.sp
.ne 2
.mk
.na
.B down
.ad
.RS 13n
.rt
This refers to the down-arrow key.
.RE

.sp
.ne 2
.mk
.na
.B left
.ad
.RS 13n
.rt
This refers to the left-arrow key.
.RE

.sp
.ne 2
.mk
.na
.B right
.ad
.RS 13n
.rt
This refers to the right-arrow key.
.RE

.sp
.ne 2
.mk
.na
.B a
.ad
.RS 13n
.rt
This is just a normal 'A' key.
.RE

.SS "The Tecla Configuration File"
.sp
.LP
By default, tecla looks for a file called \fB\&.teclarc\fR in your home
directory (ie.
.BR ~/.teclarc ).
If it finds this file, it reads it,
interpreting each line as defining a new key binding or an editing
configuration option. Since the
.B emacs
key-bindings are installed by
default, if you want to use the non-default
.B vi
editing mode, the most
important item to go in this file is the following line:
.sp
.in +2
.nf
edit-mode vi
.fi
.in -2

.sp
.LP
This will re-configure the default bindings for
.BR vi -mode.
The complete
set of arguments that this command accepts are:
.sp
.ne 2
.mk
.na
.B vi
.ad
.RS 9n
.rt
Install key bindings like those of the
.B vi
editor.
.RE

.sp
.ne 2
.mk
.na
.B emacs
.ad
.RS 9n
.rt
Install key bindings like those of the
.B emacs
editor. This is the
default.
.RE

.sp
.ne 2
.mk
.na
.B none
.ad
.RS 9n
.rt
Use just the native line editing facilities provided by the terminal
driver.
.RE

.sp
.LP
To prevent the terminal bell from being rung, such as when an unrecognized
control-sequence is typed, place the following line in the configuration
file:
.sp
.in +2
.nf
nobeep
.fi
.in -2

.sp
.LP
An example of a key binding line in the configuration file is the
following.
.sp
.in +2
.nf
bind M-[2~ insert-mode
.fi
.in -2

.sp
.LP
On many keyboards, the above key sequence is generated when one presses the
insert key, so with this key binding, one can toggle between the
\fBemacs\fR-mode insert and overwrite modes by hitting one key. One could also
do it by typing out the above sequence of characters one by one. As explained
above, the
.B M-
part of this sequence can be typed either by pressing the
ESCAPE key before the following key, or by pressing the META key at the same
time as the following key. Thus if you had set the above key binding, and the
insert key on your keyboard didn't generate the above key sequence, you could
still type it in either of the following 2 ways.
.RS +4
.TP
1.
Hit the ESCAPE key momentarily, then press '[', then '2', then finally '~'.
.RE
.RS +4
.TP
2.
Press the META key at the same time as pressing the '[' key, then press '2',
then '~'.
.RE
.sp
.LP
If you set a key binding for a key sequence that is already bound to a
function, the new binding overrides the old one. If in the new binding you
omit the name of the new function to bind to the key sequence, the original
binding becomes undefined.
.sp
.LP
Starting with versions of
.B libtecla
later than 1.3.3 it is now possible
to bind key sequences that begin with a printable character. Previously key
sequences were required to start with a CONTROL or META character.
.sp
.LP
Note that the special keywords "up", "down", "left", and "right" refer to the
arrow keys, and are thus not treated as key sequences. So, for example, to
rebind the up and down arrow keys to use the history search mechanism instead
of the simple history recall method, you could place the following in your
configuration file:
.sp
.in +2
.nf
bind up history-search-backwards
bind down history-search-backwards
.fi
.in -2

.sp
.LP
To unbind an existing binding, you can do this with the bind command by
omitting to name any action to rebind the key sequence to. For example, by not
specifying an action function, the following command unbinds the default
beginning-of-line action from the
.B ^A
key sequence:
.sp
.in +2
.nf
bind ^A
.fi
.in -2

.sp
.LP
If you create a
.B ~/.teclarc
configuration file, but it appears to have
no effect on the program, check the documentation of the program to see if the
author chose a different name for this file.
.SS "Filename and Tilde Completion"
.sp
.LP
With the default key bindings, pressing the TAB key (aka.
.BR ^I )
results
in tecla attempting to complete the incomplete file name that precedes the
cursor. Tecla searches backwards from the cursor, looking for the start of the
file name, stopping when it hits either a space or the start of the line. If
more than one file has the specified prefix, then tecla completes the file
name up to the point at which the ambiguous matches start to differ, then
lists the possible matches.
.sp
.LP
In addition to literally written file names, tecla can complete files that
start with
.B ~/
and
.B ~user/
expressions and that contain
.B $envvar
expressions. In particular, if you hit TAB within an incomplete
.BR ~user ,
expression, tecla will attempt to complete the username, listing
any ambiguous matches.
.sp
.LP
The completion binding is implemented using the
.BR cpl_complete_word()
function, which is also available separately to users of this library. See the
.BR cpl_complete_word (3TECLA)
man page for more details.
.SS "Filename Expansion"
.sp
.LP
With the default key bindings, pressing
.B ^X*
causes tecla to expand the
file name that precedes the cursor, replacing
.B ~/
and
.BR ~user/
expressions with the corresponding home directories, and replacing
.B $envvar
expressions with the value of the specified environment
variable, then if there are any wildcards, replacing the so far expanded file
name with a space-separated list of the files which match the wild cards.
.sp
.LP
The expansion binding is implemented using the
.B ef_expand_file()
function. See the
.BR ef_expand_file (3TECLA)
man page for more details.
.SS "Recalling Previously Typed Lines"
.sp
.LP
Every time that a new line is entered by the user, it is appended to a list
of historical input lines maintained within the
.B GetLine
resource object.
You can traverse up and down this list using the up and down arrow keys.
Alternatively, you can do the same with the
.BR ^P ,
and
.B ^N
keys, and
in
.B vi
command mode you can alternatively use the k and j characters.
Thus pressing up-arrow once, replaces the current input line with the
previously entered line. Pressing up-arrow again, replaces this with the line
that was entered before it, etc.. Having gone back one or more lines into the
history list, one can return to newer lines by pressing down-arrow one or more
times. If you do this sufficient times, you will return to the original line
that you were entering when you first hit up-arrow.
.sp
.LP
Note that in
.B vi
mode, all of the history recall functions switch the
library into command mode.
.sp
.LP
In
.B emacs
mode the
.B M-p
and
.B M-n
keys work just like the
.B ^P
and
.B ^N
keys, except that they skip all but those historical
lines which share the prefix that precedes the cursor. In
.B vi
command
mode the upper case 'K' and 'J' characters do the same thing, except that the
string that they search for includes the character under the cursor as well as
what precedes it.
.sp
.LP
Thus for example, suppose that you were in
.B emacs
mode, and you had just
entered the following list of commands in the order shown:
.sp
.in +2
.nf
ls ~/tecla/
cd ~/tecla
ls -l getline.c
\fBemacs\fR ~/tecla/getline.c
.fi
.in -2

.sp
.LP
If you next typed:
.sp
.in +2
.nf
ls
.fi
.in -2

.sp
.LP
and then hit
.BR M-p ,
then rather than returning the previously typed
\fBemacs\fR line, which doesn't start with "ls", tecla would recall the "ls -l
getline.c" line. Pressing \fBM-p\fR again would recall the "ls ~/tecla/"
line.
.sp
.LP
Note that if the string that you are searching for, contains any of the
special characters, *, ?, or '[', then it is interpretted as a pattern to be
matched. Thus, cotinuing with the above example, after typing in the list of
commands shown, if you then typed:
.sp
.in +2
.nf
*tecla*
.fi
.in -2

.sp
.LP
and hit \fBM-p\fR, then the "\fBemacs\fR ~/tecla/getline.c" line would be
recalled first, since it contains the word tecla somewhere in the line,
Similarly, hitting \fBM-p\fR again, would recall the "ls ~/tecla/" line, and
hitting it once more would recall the "ls ~/tecla/" line. The pattern syntax
is the same as that described for file name expansion, in the
.BR ef_expand_file (3TECLA).
.SS "History Files"
.sp
.LP
Authors of programs that use the tecla library have the option of saving
historical command-lines in a file before exiting, and subsequently reading
them back in from this file when the program is next started. There is no
standard name for this file, since it makes sense for each application to use
its own history file, so that commands from different applications don't get
mixed up.
.SS "International Character Sets"
.sp
.LP
Since
.B libtecla
version 1.4.0, tecla has been 8-bit clean. This means
that all 8-bit characters that are printable in the user's current locale are
now displayed verbatim and included in the returned input line. Assuming that
the calling program correctly contains a call like the following,
.sp
.in +2
.nf
setlocale(LC_CTYPE, "");
.fi
.in -2

.sp
.LP
then the current locale is determined by the first of the environment
variables
.BR LC_CTYPE ,
.BR LC_ALL ,
and
.BR LANG ,
that is found to
contain a valid locale name. If none of these variables are defined, or the
program neglects to call
.BR setlocale ,
then the default C locale is used,
which is US 7-bit ASCII. On most unix-like platforms, you can get a list of
valid locales by typing the command:
.sp
.in +2
.nf
locale -a
.fi
.in -2

.sp
.LP
at the shell prompt.
.SS "Meta Keys and Locales"
.sp
.LP
Beware that in most locales other than the default C locale, META characters
.RB "become printable, and they are then no longer considered to match" " M-c"
style key bindings. This allows international characters to be entered with
the compose key without unexpectedly triggering META key bindings. You can
still invoke META bindings, since there are actually two ways to do this. For
example the binding
.B M-c
can also be invoked by pressing the ESCAPE key
momentarily, then pressing the c key, and this will work regardless of locale.
Moreover, many modern terminal emulators, such as gnome's gnome-terminal's and
KDE's konsole terminals, already generate escape pairs like this when you use
the META key, rather than a real meta character, and other emulators usually
have a way to request this behavior, so you can continue to use the META key
on most systems.
.sp
.LP
For example, although xterm terminal emulators generate real 8-bit meta
characters by default when you use the META key, they can be configured to
output the equivalent escape pair by setting their
.B EightBitInput
X
resource to False. You can either do this by placing a line like the following
in your
.B ~/.Xdefaults
file,
.sp
.in +2
.nf
XTerm*EightBitInput: False
.fi
.in -2

.sp
.LP
or by starting an
.B xterm
with an
.B -xrm
\&'*EightBitInput: False'
command-line argument. In recent versions of xterm you can toggle this feature
on and off with the 'Meta Sends Escape' option in the menu that is displayed
when you press the left mouse button and the CONTROL key within an xterm
window. In CDE, dtterms can be similarly coerced to generate escape pairs in
place of meta characters, by setting the
.B Dtterm*KshMode
resource to
True.
.SS "Entering International Characters"
.sp
.LP
If you don't have a keyboard that generates all of the international
characters that you need, there is usually a compose key that will allow you
to enter special characters, or a way to create one. For example, under X
windows on unix-like systems, if your keyboard doesn't have a compose key, you
can designate a redundant key to serve this purpose with the xmodmap command.
For example, on many PC keyboards there is a microsoft-windows key, which is
otherwise useless under Linux. On a laptop, for example, the
.B xev
program
might report that pressing this key generates keycode 115. To turn this key
into a COMPOSE  key, do the following:
.sp
.in +2
.nf
xmodmap -e 'keycode 115 = Multi_key'
.fi
.in -2

.sp
.LP
Type this key followed by a " character to enter an 'I' with a umlaut over
it.
.SS "The Available Key Binding Functions"
.sp
.LP
The following is a list of the editing functions provided by the tecla
library. The names in the leftmost column of the list can be used in
configuration files to specify which function a given key or combination of
keys should invoke. They are also used in the next two sections to list the
default key bindings in
.B emacs
and
.B vi
modes.
.sp
.ne 2
.mk
.na
.B user-interrupt
.ad
.RS 30n
.rt
Send a SIGINT signal to the parent process.
.RE

.sp
.ne 2
.mk
.na
.B suspend
.ad
.RS 30n
.rt
Suspend the parent process.
.RE

.sp
.ne 2
.mk
.na
.B stop-output
.ad
.RS 30n
.rt
Pause terminal output.
.RE

.sp
.ne 2
.mk
.na
.B start-output
.ad
.RS 30n
.rt
Resume paused terminal output.
.RE

.sp
.ne 2
.mk
.na
.B literal-next
.ad
.RS 30n
.rt
Arrange for the next character to be treated as a normal character. This
allows control characters to be entered.
.RE

.sp
.ne 2
.mk
.na
.B cursor-right
.ad
.RS 30n
.rt
Move the cursor one character right.
.RE

.sp
.ne 2
.mk
.na
.B cursor-left
.ad
.RS 30n
.rt
Move the cursor one character left.
.RE

.sp
.ne 2
.mk
.na
.B insert-mode
.ad
.RS 30n
.rt
Toggle between insert mode and overwrite mode.
.RE

.sp
.ne 2
.mk
.na
.B beginning-of-line
.ad
.RS 30n
.rt
Move the cursor to the beginning of the line.
.RE

.sp
.ne 2
.mk
.na
.B end-of-line
.ad
.RS 30n
.rt
Move the cursor to the end of the line.
.RE

.sp
.ne 2
.mk
.na
.B delete-line
.ad
.RS 30n
.rt
Delete the contents of the current line.
.RE

.sp
.ne 2
.mk
.na
.B kill-line
.ad
.RS 30n
.rt
Delete everything that follows the cursor.
.RE

.sp
.ne 2
.mk
.na
.B backward-kill-line
.ad
.RS 30n
.rt
Delete all characters between the cursor and the start of the line.
.RE

.sp
.ne 2
.mk
.na
.B forward-word
.ad
.RS 30n
.rt
Move to the end of the word which follows the cursor.
.RE

.sp
.ne 2
.mk
.na
.B forward-to-word
.ad
.RS 30n
.rt
Move the cursor to the start of the word that follows the cursor.
.RE

.sp
.ne 2
.mk
.na
.B backward-word
.ad
.RS 30n
.rt
Move to the start of the word which precedes the cursor.
.RE

.sp
.ne 2
.mk
.na
.B goto-column
.ad
.RS 30n
.rt
Move the cursor to the 1-relative column in the line specified by any
preceding digit-argument sequences (see Entering Repeat Counts below).
.RE

.sp
.ne 2
.mk
.na
.B find-parenthesis
.ad
.RS 30n
.rt
If the cursor is currently over a parenthesis character, move it to the
matching parenthesis character. If not over a parenthesis character move right
to the next close parenthesis.
.RE

.sp
.ne 2
.mk
.na
.B forward-delete-char
.ad
.RS 30n
.rt
Delete the character under the cursor.
.RE

.sp
.ne 2
.mk
.na
.B backward-delete-char
.ad
.RS 30n
.rt
Delete the character which precedes the cursor.
.RE

.sp
.ne 2
.mk
.na
.B list-or-eof
.ad
.RS 30n
.rt
This is intended for binding to
.BR ^D .
When invoked when the cursor is
within the line it displays all possible completions then redisplays the line
unchanged. When invoked on an empty line, it signals end-of-input (EOF) to the
caller of
.BR gl_get_line() .
.RE

.sp
.ne 2
.mk
.na
.B del-char-or-list-or-eof
.ad
.RS 30n
.rt
This is intended for binding to
.BR ^D .
When invoked when the cursor is
within the line it invokes forward-delete-char. When invoked at the end of the
line it displays all possible completions then redisplays the line unchanged.
When invoked on an empty line, it signals end-of-input (EOF) to the caller of
.BR gl_get_line() .
.RE

.sp
.ne 2
.mk
.na
.B forward-delete-word
.ad
.RS 30n
.rt
Delete the word which follows the cursor.
.RE

.sp
.ne 2
.mk
.na
.B backward-delete-word
.ad
.RS 30n
.rt
Delete the word which precedes the cursor.
.RE

.sp
.ne 2
.mk
.na
.B upcase-word
.ad
.RS 30n
.rt
Convert all of the characters of the word which follows the cursor, to upper
case.
.RE

.sp
.ne 2
.mk
.na
.B downcase-word
.ad
.RS 30n
.rt
Convert all of the characters of the word which follows the cursor, to lower
case.
.RE

.sp
.ne 2
.mk
.na
.B capitalize-word
.ad
.RS 30n
.rt
Capitalize the word which follows the cursor.
.RE

.sp
.ne 2
.mk
.na
.B change-case
.ad
.RS 30n
.rt
If the next character is upper case, toggle it to lower case and vice
versa.
.RE

.sp
.ne 2
.mk
.na
.B redisplay
.ad
.RS 30n
.rt
Redisplay the line.
.RE

.sp
.ne 2
.mk
.na
.B clear-screen
.ad
.RS 30n
.rt
Clear the terminal, then redisplay the current line.
.RE

.sp
.ne 2
.mk
.na
.B transpose-chars
.ad
.RS 30n
.rt
Swap the character under the cursor with the character just before the
cursor.
.RE

.sp
.ne 2
.mk
.na
.B set-mark
.ad
.RS 30n
.rt
Set a mark at the position of the cursor.
.RE

.sp
.ne 2
.mk
.na
.B exchange-point-and-mark
.ad
.RS 30n
.rt
Move the cursor to the last mark that was set, and move the mark to where the
cursor used to be.
.RE

.sp
.ne 2
.mk
.na
.B kill-region
.ad
.RS 30n
.rt
Delete the characters that lie between the last mark that was set, and the
cursor.
.RE

.sp
.ne 2
.mk
.na
.B copy-region-as-kill
.ad
.RS 30n
.rt
Copy the text between the mark and the cursor to the cut buffer, without
deleting the original text.
.RE

.sp
.ne 2
.mk
.na
.B yank
.ad
.RS 30n
.rt
Insert the text that was last deleted, just before the current position of
the cursor.
.RE

.sp
.ne 2
.mk
.na
.B append-yank
.ad
.RS 30n
.rt
Paste the current contents of the cut buffer, after the cursor.
.RE

.sp
.ne 2
.mk
.na
.B up-history
.ad
.RS 30n
.rt
Recall the next oldest line that was entered. Note that in
.B vi
mode you
are left in command mode.
.RE

.sp
.ne 2
.mk
.na
.B down-history
.ad
.RS 30n
.rt
Recall the next most recent line that was entered. If no history recall
session is currently active, the next line from a previous recall session is
recalled. Note that in vi mode you are left in command mode.
.RE

.sp
.ne 2
.mk
.na
.B history-search-backward
.ad
.RS 30n
.rt
Recall the next oldest line who's prefix matches the string which currently
precedes the cursor (in
.B vi
command-mode the character under the cursor
is also included in the search string). Note that in
.B vi
mode you are
left in command mode.
.RE

.sp
.ne 2
.mk
.na
.B history-search-forward
.ad
.RS 30n
.rt
Recall the next newest line who's prefix matches the string which currently
precedes the cursor (in
.B vi
command-mode the character under the cursor
is also included in the search string). Note that in
.B vi
mode you are
left in command mode.
.RE

.sp
.ne 2
.mk
.na
.B history-re-search-backward
.ad
.RS 30n
.rt
Recall the next oldest line who's prefix matches that established by the last
invocation of either history-search-forward or history-search-backward.
.RE

.sp
.ne 2
.mk
.na
.B history-re-search-forward
.ad
.RS 30n
.rt
Recall the next newest line who's prefix matches that established by the last
invocation of either history-search-forward or history-search-backward.
.RE

.sp
.ne 2
.mk
.na
.B complete-word
.ad
.RS 30n
.rt
Attempt to complete the incomplete word which precedes the cursor. Unless the
host program has customized word completion, file name completion is
attempted. In
.B vi
commmand mode the character under the cursor is also
included in the word being completed, and you are left in
.B vi
insert
mode.
.RE

.sp
.ne 2
.mk
.na
.B expand-filename
.ad
.RS 30n
.rt
Within the command line, expand wild cards, tilde expressions and dollar
expressions in the file name which immediately precedes the cursor. In
.B vi
commmand mode the character under the cursor is also included in the
file name being expanded, and you are left in
.B vi
insert mode.
.RE

.sp
.ne 2
.mk
.na
.B list-glob
.ad
.RS 30n
.rt
List any file names which match the wild-card, tilde and dollar expressions
in the file name which immediately precedes the cursor, then redraw the input
line unchanged.
.RE

.sp
.ne 2
.mk
.na
.B list-history
.ad
.RS 30n
.rt
Display the contents of the history list for the current history group. If a
repeat count of
.B "> 1"
is specified, only that many of the most recent
lines are displayed. See the Entering Repeat Counts section.
.RE

.sp
.ne 2
.mk
.na
.B read-from-file
.ad
.RS 30n
.rt
Temporarily switch to reading input from the file who's name precedes the
cursor.
.RE

.sp
.ne 2
.mk
.na
.B read-init-files
.ad
.RS 30n
.rt
Re-read
.B teclarc
configuration files.
.RE

.sp
.ne 2
.mk
.na
.B beginning-of-history
.ad
.RS 30n
.rt
Move to the oldest line in the history list. Note that in
.B vi
mode you
are left in command mode.
.RE

.sp
.ne 2
.mk
.na
.B end-of-history
.ad
.RS 30n
.rt
Move to the newest line in the history list (ie. the current line). Note that
in
.B vi
mode this leaves you in command mode.
.RE

.sp
.ne 2
.mk
.na
.B digit-argument
.ad
.RS 30n
.rt
Enter a repeat count for the next key binding function. For details, see the
Entering Repeat Counts section.
.RE

.sp
.ne 2
.mk
.na
.B newline
.ad
.RS 30n
.rt
Terminate and return the current contents of the line, after appending a
newline character. The newline character is normally '\en', but will be the
first character of the key sequence that invoked the newline action, if this
happens to be a printable character. If the action was invoked by the '\en'
newline character or the '\er' carriage return character, the line is appended
to the history buffer.
.RE

.sp
.ne 2
.mk
.na
.B repeat-history
.ad
.RS 30n
.rt
Return the line that is being edited, then arrange for the next most recent
entry in the history buffer to be recalled when tecla is next called.
Repeatedly invoking this action causes successive historical input lines to be
re-executed. Note that this action is equivalent to the 'Operate' action in
ksh.
.RE

.sp
.ne 2
.mk
.na
.B ring-bell
.ad
.RS 30n
.rt
Ring the terminal bell, unless the bell has been silenced via the nobeep
configuration option (see The Tecla Configuration File section).
.RE

.sp
.ne 2
.mk
.na
.B forward-copy-char
.ad
.RS 30n
.rt
Copy the next character into the cut buffer (NB. use repeat counts to copy
more than one).
.RE

.sp
.ne 2
.mk
.na
.B backward-copy-char
.ad
.RS 30n
.rt
Copy the previous character into the cut buffer.
.RE

.sp
.ne 2
.mk
.na
.B forward-copy-word
.ad
.RS 30n
.rt
Copy the next word into the cut buffer.
.RE

.sp
.ne 2
.mk
.na
.B backward-copy-word
.ad
.RS 30n
.rt
Copy the previous word into the cut buffer.
.RE

.sp
.ne 2
.mk
.na
.B forward-find-char
.ad
.RS 30n
.rt
Move the cursor to the next occurrence of the next character that you type.
.RE

.sp
.ne 2
.mk
.na
.B backward-find-char
.ad
.RS 30n
.rt
Move the cursor to the last occurrence of the next character that you type.
.RE

.sp
.ne 2
.mk
.na
.B forward-to-char
.ad
.RS 30n
.rt
Move the cursor to the character just before the next occurrence of the next
character that the user types.
.RE

.sp
.ne 2
.mk
.na
.B backward-to-char
.ad
.RS 30n
.rt
Move the cursor to the character just after the last occurrence before the
cursor of the next character that the user types.
.RE

.sp
.ne 2
.mk
.na
.B repeat-find-char
.ad
.RS 30n
.rt
Repeat the last backward-find-char, forward-find-char, backward-to-char or
forward-to-char.
.RE

.sp
.ne 2
.mk
.na
.B invert-refind-char
.ad
.RS 30n
.rt
Repeat the last backward-find-char, forward-find-char, backward-to-char, or
forward-to-char in the opposite direction.
.RE

.sp
.ne 2
.mk
.na
.B delete-to-column
.ad
.RS 30n
.rt
Delete the characters from the cursor up to the column that is specified by
the repeat count.
.RE

.sp
.ne 2
.mk
.na
.B delete-to-parenthesis
.ad
.RS 30n
.rt
Delete the characters from the cursor up to and including the matching
parenthesis, or next close parenthesis.
.RE

.sp
.ne 2
.mk
.na
.B forward-delete-find
.ad
.RS 30n
.rt
Delete the characters from the cursor up to and including the following
occurence of the next character typed.
.RE

.sp
.ne 2
.mk
.na
.B backward-delete-find
.ad
.RS 30n
.rt
Delete the characters from the cursor up to and including the preceding
occurence of the next character typed.
.RE

.sp
.ne 2
.mk
.na
.B forward-delete-to
.ad
.RS 30n
.rt
Delete the characters from the cursor up to, but not including, the following
occurence of the next character typed.
.RE

.sp
.ne 2
.mk
.na
.B backward-delete-to
.ad
.RS 30n
.rt
Delete the characters from the cursor up to, but not including, the preceding
occurence of the next character typed.
.RE

.sp
.ne 2
.mk
.na
.B delete-refind
.ad
.RS 30n
.rt
Repeat the last *-delete-find or *-delete-to action.
.RE

.sp
.ne 2
.mk
.na
.B delete-invert-refind
.ad
.RS 30n
.rt
Repeat the last *-delete-find or *-delete-to action, in the opposite
direction.
.RE

.sp
.ne 2
.mk
.na
.B copy-to-column
.ad
.RS 30n
.rt
Copy the characters from the cursor up to the column that is specified by the
repeat count, into the cut buffer.
.RE

.sp
.ne 2
.mk
.na
.B copy-to-parenthesis
.ad
.RS 30n
.rt
Copy the characters from the cursor up to and including the matching
parenthesis, or next close parenthesis, into the cut buffer.
.RE

.sp
.ne 2
.mk
.na
.B forward-copy-find
.ad
.RS 30n
.rt
Copy the characters from the cursor up to and including the following
occurence of the next character typed, into the cut buffer.
.RE

.sp
.ne 2
.mk
.na
.B backward-copy-find
.ad
.RS 30n
.rt
Copy the characters from the cursor up to and including the preceding
occurence of the next character typed, into the cut buffer.
.RE

.sp
.ne 2
.mk
.na
.B forward-copy-to
.ad
.RS 30n
.rt
Copy the characters from the cursor up to, but not including, the following
occurence of the next character typed, into the cut buffer.
.RE

.sp
.ne 2
.mk
.na
.B backward-copy-to
.ad
.RS 30n
.rt
Copy the characters from the cursor up to, but not including, the preceding
occurence of the next character typed, into the cut buffer.
.RE

.sp
.ne 2
.mk
.na
.B copy-refind
.ad
.RS 30n
.rt
Repeat the last *-copy-find or *-copy-to action.
.RE

.sp
.ne 2
.mk
.na
.B copy-invert-refind
.ad
.RS 30n
.rt
Repeat the last *-copy-find or *-copy-to action, in the opposite direction.
.RE

.sp
.ne 2
.mk
.na
.B vi-mode
.ad
.RS 30n
.rt
Switch to
.B vi
mode from emacs mode.
.RE

.sp
.ne 2
.mk
.na
.B emacs-mode
.ad
.RS 30n
.rt
Switch to
.B emacs
mode from
.B vi
mode.
.RE

.sp
.ne 2
.mk
.na
.B vi-insert
.ad
.RS 30n
.rt
From
.B vi
command mode, switch to insert mode.
.RE

.sp
.ne 2
.mk
.na
.B vi-overwrite
.ad
.RS 30n
.rt
From
.B vi
command mode, switch to overwrite mode.
.RE

.sp
.ne 2
.mk
.na
.B vi-insert-at-bol
.ad
.RS 30n
.rt
From
.B vi
command mode, move the cursor to the start of the line and
switch to insert mode.
.RE

.sp
.ne 2
.mk
.na
.B vi-append-at-eol
.ad
.RS 30n
.rt
From
.B vi
command mode, move the cursor to the end of the line and switch
to append mode.
.RE

.sp
.ne 2
.mk
.na
.B vi-append
.ad
.RS 30n
.rt
From
.B vi
command mode, move the cursor one position right, and switch to
insert mode.
.RE

.sp
.ne 2
.mk
.na
.B vi-replace-char
.ad
.RS 30n
.rt
From
.B vi
command mode, replace the character under the cursor with the
next character entered.
.RE

.sp
.ne 2
.mk
.na
.B vi-forward-change-char
.ad
.RS 30n
.rt
From
.B vi
command mode, delete the next character then enter insert
mode.
.RE

.sp
.ne 2
.mk
.na
.B vi-backward-change-char
.ad
.RS 30n
.rt
From vi command mode, delete the preceding character then enter insert
mode.
.RE

.sp
.ne 2
.mk
.na
.B vi-forward-change-word
.ad
.RS 30n
.rt
From
.B vi
command mode, delete the next word then enter insert mode.
.RE

.sp
.ne 2
.mk
.na
.B vi-backward-change-word
.ad
.RS 30n
.rt
From vi command mode, delete the preceding word then enter insert mode.
.RE

.sp
.ne 2
.mk
.na
.B vi-change-rest-of-line
.ad
.RS 30n
.rt
From
.B vi
command mode, delete from the cursor to the end of the line,
then enter insert mode.
.RE

.sp
.ne 2
.mk
.na
.B vi-change-line
.ad
.RS 30n
.rt
From
.B vi
command mode, delete the current line, then enter insert
mode.
.RE

.sp
.ne 2
.mk
.na
.B vi-change-to-bol
.ad
.RS 30n
.rt
From
.B vi
command mode, delete all characters between the cursor and the
beginning of the line, then enter insert mode.
.RE

.sp
.ne 2
.mk
.na
.B vi-change-to-column
.ad
.RS 30n
.rt
From
.B vi
command mode, delete the characters from the cursor up to the
column that is specified by the repeat count, then enter insert mode.
.RE

.sp
.ne 2
.mk
.na
.B vi-change-to-parenthesis
.ad
.RS 30n
.rt
Delete the characters from the cursor up to and including the matching
parenthesis, or next close parenthesis, then enter
.B vi
insert mode.
.RE

.sp
.ne 2
.mk
.na
.B vi-forward-change-find
.ad
.RS 30n
.rt
From
.B vi
command mode, delete the characters from the cursor up to and
including the following occurence of the next character typed, then enter
insert mode.
.RE

.sp
.ne 2
.mk
.na
.B vi-backward-change-find
.ad
.RS 30n
.rt
From vi command mode, delete the characters from the cursor up to and
including the preceding occurence of the next character typed, then enter
insert mode.
.RE

.sp
.ne 2
.mk
.na
.B vi-forward-change-to
.ad
.RS 30n
.rt
From
.B vi
command mode, delete the characters from the cursor up to, but
not including, the following occurence of the next character typed, then enter
insert mode.
.RE

.sp
.ne 2
.mk
.na
.B vi-backward-change-to
.ad
.RS 30n
.rt
From
.B vi
command mode, delete the characters from the cursor up to, but
not including, the preceding occurence of the next character typed, then enter
insert mode.
.RE

.sp
.ne 2
.mk
.na
.B vi-change-refind
.ad
.RS 30n
.rt
Repeat the last vi-*-change-find or vi-*-change-to action.
.RE

.sp
.ne 2
.mk
.na
.B vi-change-invert-refind
.ad
.RS 30n
.rt
Repeat the last vi-*-change-find or vi-*-change-to action, in the opposite
direction.
.RE

.sp
.ne 2
.mk
.na
.B vi-undo
.ad
.RS 30n
.rt
In
.B vi
mode, undo the last editing operation.
.RE

.sp
.ne 2
.mk
.na
.B vi-repeat-change
.ad
.RS 30n
.rt
In
.B vi
command mode, repeat the last command that modified the line.
.RE

.SS "Default Key Bindings In \fBemacs\fR Mode"
.sp
.LP
The following default key bindings, which can be overriden by the tecla
configuration file, are designed to mimic most of the bindings of the unix
.B tcsh shell
shell, when it is in
.B emacs
editing mode.
.sp
.LP
This is the default editing mode of the tecla library.
.sp
.LP
Under UNIX the terminal driver sets a number of special keys for certain
functions. The tecla library attempts to use the same key bindings to maintain
consistency. The key sequences shown for the following 6 bindings are thus
just examples of what they will probably be set to. If you have used the stty
command to change these keys, then the default bindings should match.
.sp
.ne 2
.mk
.na
.B ^C
.ad
.RS 6n
.rt
user-interrupt
.RE

.sp
.ne 2
.mk
.na
\fB^\e\fR
.ad
.RS 6n
.rt
abort
.RE

.sp
.ne 2
.mk
.na
.B ^Z
.ad
.RS 6n
.rt
suspend
.RE

.sp
.ne 2
.mk
.na
.B ^Q
.ad
.RS 6n
.rt
start-output
.RE

.sp
.ne 2
.mk
.na
.B ^S
.ad
.RS 6n
.rt
stop-output
.RE

.sp
.ne 2
.mk
.na
.B ^V
.ad
.RS 6n
.rt
literal-next
.RE

.sp
.LP
The cursor keys are refered to by name, as follows. This is necessary because
different types of terminals generate different key sequences when their
cursor keys are pressed.
.sp
.ne 2
.mk
.na
.B right
.ad
.RS 9n
.rt
cursor-right
.RE

.sp
.ne 2
.mk
.na
.B left
.ad
.RS 9n
.rt
cursor-left
.RE

.sp
.ne 2
.mk
.na
.B up
.ad
.RS 9n
.rt
up-history
.RE

.sp
.ne 2
.mk
.na
.B down
.ad
.RS 9n
.rt
down-history
.RE

.sp
.LP
The remaining bindings don't depend on the terminal setttings.
.sp
.ne 2
.mk
.na
.B ^F
.ad
.RS 21n
.rt
cursor-right
.RE

.sp
.ne 2
.mk
.na
.B ^B
.ad
.RS 21n
.rt
cursor-left
.RE

.sp
.ne 2
.mk
.na
.B M-i
.ad
.RS 21n
.rt
insert-mode
.RE

.sp
.ne 2
.mk
.na
.B ^A
.ad
.RS 21n
.rt
beginning-of-line
.RE

.sp
.ne 2
.mk
.na
.B ^E
.ad
.RS 21n
.rt
end-of-line
.RE

.sp
.ne 2
.mk
.na
.B ^U
.ad
.RS 21n
.rt
delete-line
.RE

.sp
.ne 2
.mk
.na
.B ^K
.ad
.RS 21n
.rt
kill-line
.RE

.sp
.ne 2
.mk
.na
.B M-f
.ad
.RS 21n
.rt
forward-word
.RE

.sp
.ne 2
.mk
.na
.B M-b
.ad
.RS 21n
.rt
backward-word
.RE

.sp
.ne 2
.mk
.na
.B ^D
.ad
.RS 21n
.rt
del-char-or-list-or-eof
.RE

.sp
.ne 2
.mk
.na
.B ^H
.ad
.RS 21n
.rt
backward-delete-char
.RE

.sp
.ne 2
.mk
.na
.B ^?
.ad
.RS 21n
.rt
backward-delete-char
.RE

.sp
.ne 2
.mk
.na
.B M-d
.ad
.RS 21n
.rt
forward-delete-word
.RE

.sp
.ne 2
.mk
.na
.B M-^H
.ad
.RS 21n
.rt
backward-delete-word
.RE

.sp
.ne 2
.mk
.na
.B M-^?
.ad
.RS 21n
.rt
backward-delete-word
.RE

.sp
.ne 2
.mk
.na
.B M-u
.ad
.RS 21n
.rt
upcase-word
.RE

.sp
.ne 2
.mk
.na
.B M-l
.ad
.RS 21n
.rt
downcase-word
.RE

.sp
.ne 2
.mk
.na
.B M-c
.ad
.RS 21n
.rt
capitalize-word
.RE

.sp
.ne 2
.mk
.na
.B ^R
.ad
.RS 21n
.rt
redisplay
.RE

.sp
.ne 2
.mk
.na
.B ^L
.ad
.RS 21n
.rt
clear-screen
.RE

.sp
.ne 2
.mk
.na
.B ^T
.ad
.RS 21n
.rt
transpose-chars
.RE

.sp
.ne 2
.mk
.na
.B ^@
.ad
.RS 21n
.rt
set-mark
.RE

.sp
.ne 2
.mk
.na
.B ^X^X
.ad
.RS 21n
.rt
exchange-point-and-mark
.RE

.sp
.ne 2
.mk
.na
.B ^W
.ad
.RS 21n
.rt
kill-region
.RE

.sp
.ne 2
.mk
.na
.B M-w
.ad
.RS 21n
.rt
copy-region-as-kill
.RE

.sp
.ne 2
.mk
.na
.B ^Y
.ad
.RS 21n
.rt
yank
.RE

.sp
.ne 2
.mk
.na
.B ^P
.ad
.RS 21n
.rt
up-history
.RE

.sp
.ne 2
.mk
.na
.B ^N
.ad
.RS 21n
.rt
down-history
.RE

.sp
.ne 2
.mk
.na
.B M-p
.ad
.RS 21n
.rt
history-search-backward
.RE

.sp
.ne 2
.mk
.na
.B M-n
.ad
.RS 21n
.rt
history-search-forward
.RE

.sp
.ne 2
.mk
.na
.B ^I
.ad
.RS 21n
.rt
complete-word
.RE

.sp
.ne 2
.mk
.na
.B ^X*
.ad
.RS 21n
.rt
expand-filename
.RE

.sp
.ne 2
.mk
.na
.B ^X^F
.ad
.RS 21n
.rt
read-from-file
.RE

.sp
.ne 2
.mk
.na
.B ^X^R
.ad
.RS 21n
.rt
read-init-files
.RE

.sp
.ne 2
.mk
.na
.B ^Xg
.ad
.RS 21n
.rt
list-glob
.RE

.sp
.ne 2
.mk
.na
.B ^Xh
.ad
.RS 21n
.rt
list-history
.RE

.sp
.ne 2
.mk
.na
.B M-<
.ad
.RS 21n
.rt
beginning-of-history
.RE

.sp
.ne 2
.mk
.na
.B M->
.ad
.RS 21n
.rt
end-of-history
.RE

.sp
.ne 2
.mk
.na
\fB\en\fR
.ad
.RS 21n
.rt
newline
.RE

.sp
.ne 2
.mk
.na
\fB\er\fR
.ad
.RS 21n
.rt
newline
.RE

.sp
.ne 2
.mk
.na
.B M-o
.ad
.RS 21n
.rt
repeat-history
.RE

.sp
.ne 2
.mk
.na
.B M-^V
.ad
.RS 21n
.rt
.BR vi -mode
.RE

.sp
.ne 2
.mk
.na
\fBM-0, M-1, .\|.\|. M-9\fR
.ad
.RS 21n
.rt
digit-argument (see below)
.RE

.sp
.LP
Note that
.B ^I
is what the TAB key generates, and that
.B ^@
can be
generated not only by pressing the CONTROL key and the @ key simultaneously,
but also by pressing the CONTROL key and the space bar at the same time.
.SS "Default Key Bindings in \fBvi\fR Mode"
.sp
.LP
The following default key bindings are designed to mimic the
.B vi
style
of editing as closely as possible. This means that very few editing functions
are provided in the initial character input mode, editing functions instead
being provided by the
.B vi
command mode. The
.B vi
command mode is
entered whenever the ESCAPE character is pressed, or whenever a key sequence
that starts with a meta character is entered. In addition to mimicing
.BR vi ,
.B libtecla
provides bindings for tab completion, wild-card
expansion of file names, and historical line recall.
.sp
.LP
To learn how to tell the tecla library to use
.B vi
mode instead of the
default
.B emacs
editing mode, see the earlier section entitled The Tecla
Configuration File.
.sp
.LP
Under UNIX the terminal driver sets a number of special keys for certain
functions. The tecla library attempts to use the same key bindings to maintain
consistency, binding them both in input mode and in command mode. The key
sequences shown for the following 6 bindings are thus just examples of what
they will probably be set to. If you have used the
.B stty
command to
change these keys, then the default bindings should match.
.sp
.ne 2
.mk
.na
.B ^C
.ad
.RS 8n
.rt
user-interrupt
.RE

.sp
.ne 2
.mk
.na
\fB^\e\fR
.ad
.RS 8n
.rt
abort
.RE

.sp
.ne 2
.mk
.na
.B ^Z
.ad
.RS 8n
.rt
suspend
.RE

.sp
.ne 2
.mk
.na
.B ^Q
.ad
.RS 8n
.rt
start-output
.RE

.sp
.ne 2
.mk
.na
.B ^S
.ad
.RS 8n
.rt
stop-output
.RE

.sp
.ne 2
.mk
.na
.B ^V
.ad
.RS 8n
.rt
literal-next
.RE

.sp
.ne 2
.mk
.na
.B M-^C
.ad
.RS 8n
.rt
user-interrupt
.RE

.sp
.ne 2
.mk
.na
\fBM-^\e\fR
.ad
.RS 8n
.rt
abort
.RE

.sp
.ne 2
.mk
.na
.B M-^Z
.ad
.RS 8n
.rt
suspend
.RE

.sp
.ne 2
.mk
.na
.B M-^Q
.ad
.RS 8n
.rt
start-output
.RE

.sp
.ne 2
.mk
.na
.B M-^S
.ad
.RS 8n
.rt
stop-output
.RE

.sp
.LP
Note that above, most of the bindings are defined twice, once as a raw
control code like
.B ^C
and then a second time as a META character like
.BR M-^C .
The former is the binding for
.B vi
input mode, whereas the
latter is the binding for
.B vi
command mode. Once in command mode all key
sequences that the user types that they don't explicitly start with an ESCAPE
or a META key, have their first key secretly converted to a META character
before the key sequence is looked up in the key binding table. Thus, once in
command mode, when you type the letter i, for example, the tecla library
actually looks up the binding for
.BR M-i .
.sp
.LP
The cursor keys are refered to by name, as follows. This is necessary because
different types of terminals generate different key sequences when their
cursor keys are pressed.
.sp
.ne 2
.mk
.na
.B right
.ad
.RS 9n
.rt
cursor-right
.RE

.sp
.ne 2
.mk
.na
.B left
.ad
.RS 9n
.rt
cursor-left
.RE

.sp
.ne 2
.mk
.na
.B up
.ad
.RS 9n
.rt
up-history
.RE

.sp
.ne 2
.mk
.na
.B down
.ad
.RS 9n
.rt
down-history
.RE

.sp
.LP
The cursor keys normally generate a key sequence that start with an ESCAPE
character, so beware that using the arrow keys will put you into command mode
(if you aren't already in command mode).
.sp
.LP
The following are the terminal-independent key bindings for
.B vi
input
mode.
.sp
.ne 2
.mk
.na
.B ^D
.ad
.RS 8n
.rt
list-or-eof
.RE

.sp
.ne 2
.mk
.na
.B ^G
.ad
.RS 8n
.rt
list-glob
.RE

.sp
.ne 2
.mk
.na
.B ^H
.ad
.RS 8n
.rt
backward-delete-char
.RE

.sp
.ne 2
.mk
.na
.B ^I
.ad
.RS 8n
.rt
complete-word
.RE

.sp
.ne 2
.mk
.na
\fB\er\fR
.ad
.RS 8n
.rt
newline
.RE

.sp
.ne 2
.mk
.na
\fB\en\fR
.ad
.RS 8n
.rt
newline
.RE

.sp
.ne 2
.mk
.na
.B ^L
.ad
.RS 8n
.rt
clear-screen
.RE

.sp
.ne 2
.mk
.na
.B ^N
.ad
.RS 8n
.rt
down-history
.RE

.sp
.ne 2
.mk
.na
.B ^P
.ad
.RS 8n
.rt
up-history
.RE

.sp
.ne 2
.mk
.na
.B ^R
.ad
.RS 8n
.rt
redisplay
.RE

.sp
.ne 2
.mk
.na
.B ^U
.ad
.RS 8n
.rt
backward-kill-line
.RE

.sp
.ne 2
.mk
.na
.B ^W
.ad
.RS 8n
.rt
backward-delete-word
.RE

.sp
.ne 2
.mk
.na
.B ^X*
.ad
.RS 8n
.rt
expand-filename
.RE

.sp
.ne 2
.mk
.na
.B ^X^F
.ad
.RS 8n
.rt
read-from-file
.RE

.sp
.ne 2
.mk
.na
.B ^X^R
.ad
.RS 8n
.rt
read-init-files
.RE

.sp
.ne 2
.mk
.na
.B ^?
.ad
.RS 8n
.rt
backward-delete-char
.RE

.sp
.LP
The following are the key bindings that are defined in
.B vi
command mode,
this being specified by them all starting with a META character. As mentioned
above, once in command mode the initial meta character is optional. For
example, you might enter command mode by typing ESCAPE, and then press 'H'
twice to move the cursor two positions to the left. Both 'H' characters get
quietly converted to
.B M-h
before being compared to the key binding table,
the first one because ESCAPE followed by a character is always converted to
the equivalent META character, and the second because command mode was already
active.
.sp
.ne 2
.mk
.na
\fBM-\e\fR
.ad
.RS 21n
.rt
cursor-right (META-space)
.RE

.sp
.ne 2
.mk
.na
.B M-$
.ad
.RS 21n
.rt
end-of-line
.RE

.sp
.ne 2
.mk
.na
.B M-*
.ad
.RS 21n
.rt
expand-filename
.RE

.sp
.ne 2
.mk
.na
.B M-+
.ad
.RS 21n
.rt
down-history
.RE

.sp
.ne 2
.mk
.na
.B M--
.ad
.RS 21n
.rt
up-history
.RE

.sp
.ne 2
.mk
.na
.B M-<
.ad
.RS 21n
.rt
beginning-of-history
.RE

.sp
.ne 2
.mk
.na
.B M->
.ad
.RS 21n
.rt
end-of-history
.RE

.sp
.ne 2
.mk
.na
.B M-^
.ad
.RS 21n
.rt
beginning-of-line
.RE

.sp
.ne 2
.mk
.na
.B M-
.ad
.RS 21n
.rt
repeat-find-char
.RE

.sp
.ne 2
.mk
.na
.B M-,
.ad
.RS 21n
.rt
invert-refind-char
.RE

.sp
.ne 2
.mk
.na
.B M-|
.ad
.RS 21n
.rt
goto-column
.RE

.sp
.ne 2
.mk
.na
.B M-~
.ad
.RS 21n
.rt
change-case
.RE

.sp
.ne 2
.mk
.na
.B M-.
.ad
.RS 21n
.rt
vi-repeat-change
.RE

.sp
.ne 2
.mk
.na
.B M-%
.ad
.RS 21n
.rt
find-parenthesis
.RE

.sp
.ne 2
.mk
.na
.B M-a
.ad
.RS 21n
.rt
vi-append
.RE

.sp
.ne 2
.mk
.na
.B M-A
.ad
.RS 21n
.rt
vi-append-at-eol
.RE

.sp
.ne 2
.mk
.na
.B M-b
.ad
.RS 21n
.rt
backward-word
.RE

.sp
.ne 2
.mk
.na
.B M-B
.ad
.RS 21n
.rt
backward-word
.RE

.sp
.ne 2
.mk
.na
.B M-C
.ad
.RS 21n
.rt
vi-change-rest-of-line
.RE

.sp
.ne 2
.mk
.na
.B M-cb
.ad
.RS 21n
.rt
vi-backward-change-word
.RE

.sp
.ne 2
.mk
.na
.B M-cB
.ad
.RS 21n
.rt
vi-backward-change-word
.RE

.sp
.ne 2
.mk
.na
.B M-cc
.ad
.RS 21n
.rt
vi-change-line
.RE

.sp
.ne 2
.mk
.na
.B M-ce
.ad
.RS 21n
.rt
vi-forward-change-word
.RE

.sp
.ne 2
.mk
.na
.B M-cE
.ad
.RS 21n
.rt
vi-forward-change-word
.RE

.sp
.ne 2
.mk
.na
.B M-cw
.ad
.RS 21n
.rt
vi-forward-change-word
.RE

.sp
.ne 2
.mk
.na
.B M-cW
.ad
.RS 21n
.rt
vi-forward-change-word
.RE

.sp
.ne 2
.mk
.na
.B M-cF
.ad
.RS 21n
.rt
vi-backward-change-find
.RE

.sp
.ne 2
.mk
.na
.B M-cf
.ad
.RS 21n
.rt
vi-forward-change-find
.RE

.sp
.ne 2
.mk
.na
.B M-cT
.ad
.RS 21n
.rt
vi-backward-change-to
.RE

.sp
.ne 2
.mk
.na
.B M-ct
.ad
.RS 21n
.rt
vi-forward-change-to
.RE

.sp
.ne 2
.mk
.na
.B M-c;
.ad
.RS 21n
.rt
vi-change-refind
.RE

.sp
.ne 2
.mk
.na
.B M-c,
.ad
.RS 21n
.rt
vi-change-invert-refind
.RE

.sp
.ne 2
.mk
.na
.B M-ch
.ad
.RS 21n
.rt
vi-backward-change-char
.RE

.sp
.ne 2
.mk
.na
.B M-c^H
.ad
.RS 21n
.rt
vi-backward-change-char
.RE

.sp
.ne 2
.mk
.na
.B M-c^?
.ad
.RS 21n
.rt
vi-backward-change-char
.RE

.sp
.ne 2
.mk
.na
.B M-cl
.ad
.RS 21n
.rt
vi-forward-change-char
.RE

.sp
.ne 2
.mk
.na
\fBM-c\e\fR
.ad
.RS 21n
.rt
vi-forward-change-char (META-c-space)
.RE

.sp
.ne 2
.mk
.na
.B M-c^
.ad
.RS 21n
.rt
vi-change-to-bol
.RE

.sp
.ne 2
.mk
.na
.B M-c0
.ad
.RS 21n
.rt
vi-change-to-bol
.RE

.sp
.ne 2
.mk
.na
.B M-c$
.ad
.RS 21n
.rt
vi-change-rest-of-line
.RE

.sp
.ne 2
.mk
.na
.B M-c|
.ad
.RS 21n
.rt
vi-change-to-column
.RE

.sp
.ne 2
.mk
.na
.B M-c%
.ad
.RS 21n
.rt
vi-change-to-parenthesis
.RE

.sp
.ne 2
.mk
.na
.B M-dh
.ad
.RS 21n
.rt
backward-delete-char
.RE

.sp
.ne 2
.mk
.na
.B M-d^H
.ad
.RS 21n
.rt
backward-delete-char
.RE

.sp
.ne 2
.mk
.na
.B M-d^?
.ad
.RS 21n
.rt
backward-delete-char
.RE

.sp
.ne 2
.mk
.na
.B M-dl
.ad
.RS 21n
.rt
forward-delete-char
.RE

.sp
.ne 2
.mk
.na
.B M-d
.ad
.RS 21n
.rt
forward-delete-char (META-d-space)
.RE

.sp
.ne 2
.mk
.na
.B M-dd
.ad
.RS 21n
.rt
delete-line
.RE

.sp
.ne 2
.mk
.na
.B M-db
.ad
.RS 21n
.rt
backward-delete-word
.RE

.sp
.ne 2
.mk
.na
.B M-dB
.ad
.RS 21n
.rt
backward-delete-word
.RE

.sp
.ne 2
.mk
.na
.B M-de
.ad
.RS 21n
.rt
forward-delete-word
.RE

.sp
.ne 2
.mk
.na
.B M-dE
.ad
.RS 21n
.rt
forward-delete-word
.RE

.sp
.ne 2
.mk
.na
.B M-dw
.ad
.RS 21n
.rt
forward-delete-word
.RE

.sp
.ne 2
.mk
.na
.B M-dW
.ad
.RS 21n
.rt
forward-delete-word
.RE

.sp
.ne 2
.mk
.na
.B M-dF
.ad
.RS 21n
.rt
backward-delete-find
.RE

.sp
.ne 2
.mk
.na
.B M-df
.ad
.RS 21n
.rt
forward-delete-find
.RE

.sp
.ne 2
.mk
.na
.B M-dT
.ad
.RS 21n
.rt
backward-delete-to
.RE

.sp
.ne 2
.mk
.na
.B M-dt
.ad
.RS 21n
.rt
forward-delete-to
.RE

.sp
.ne 2
.mk
.na
.B M-d;
.ad
.RS 21n
.rt
delete-refind
.RE

.sp
.ne 2
.mk
.na
.B M-d,
.ad
.RS 21n
.rt
delete-invert-refind
.RE

.sp
.ne 2
.mk
.na
.B M-d^
.ad
.RS 21n
.rt
backward-kill-line
.RE

.sp
.ne 2
.mk
.na
.B M-d0
.ad
.RS 21n
.rt
backward-kill-line
.RE

.sp
.ne 2
.mk
.na
.B M-d$
.ad
.RS 21n
.rt
kill-line
.RE

.sp
.ne 2
.mk
.na
.B M-D
.ad
.RS 21n
.rt
kill-line
.RE

.sp
.ne 2
.mk
.na
.B M-d|
.ad
.RS 21n
.rt
delete-to-column
.RE

.sp
.ne 2
.mk
.na
.B M-d%
.ad
.RS 21n
.rt
delete-to-parenthesis
.RE

.sp
.ne 2
.mk
.na
.B M-e
.ad
.RS 21n
.rt
forward-word
.RE

.sp
.ne 2
.mk
.na
.B M-E
.ad
.RS 21n
.rt
forward-word
.RE

.sp
.ne 2
.mk
.na
.B M-f
.ad
.RS 21n
.rt
forward-find-char
.RE

.sp
.ne 2
.mk
.na
.B M-F
.ad
.RS 21n
.rt
backward-find-char
.RE

.sp
.ne 2
.mk
.na
.B M--
.ad
.RS 21n
.rt
up-history
.RE

.sp
.ne 2
.mk
.na
.B M-h
.ad
.RS 21n
.rt
cursor-left
.RE

.sp
.ne 2
.mk
.na
.B M-H
.ad
.RS 21n
.rt
beginning-of-history
.RE

.sp
.ne 2
.mk
.na
.B M-i
.ad
.RS 21n
.rt
vi-insert
.RE

.sp
.ne 2
.mk
.na
.B M-I
.ad
.RS 21n
.rt
vi-insert-at-bol
.RE

.sp
.ne 2
.mk
.na
.B M-j
.ad
.RS 21n
.rt
down-history
.RE

.sp
.ne 2
.mk
.na
.B M-J
.ad
.RS 21n
.rt
history-search-forward
.RE

.sp
.ne 2
.mk
.na
.B M-k
.ad
.RS 21n
.rt
up-history
.RE

.sp
.ne 2
.mk
.na
.B M-K
.ad
.RS 21n
.rt
history-search-backward
.RE

.sp
.ne 2
.mk
.na
.B M-l
.ad
.RS 21n
.rt
cursor-right
.RE

.sp
.ne 2
.mk
.na
.B M-L
.ad
.RS 21n
.rt
end-of-history
.RE

.sp
.ne 2
.mk
.na
.B M-n
.ad
.RS 21n
.rt
history-re-search-forward
.RE

.sp
.ne 2
.mk
.na
.B M-N
.ad
.RS 21n
.rt
history-re-search-backward
.RE

.sp
.ne 2
.mk
.na
.B M-p
.ad
.RS 21n
.rt
append-yank
.RE

.sp
.ne 2
.mk
.na
.B M-P
.ad
.RS 21n
.rt
yank
.RE

.sp
.ne 2
.mk
.na
.B M-r
.ad
.RS 21n
.rt
vi-replace-char
.RE

.sp
.ne 2
.mk
.na
.B M-R
.ad
.RS 21n
.rt
vi-overwrite
.RE

.sp
.ne 2
.mk
.na
.B M-s
.ad
.RS 21n
.rt
vi-forward-change-char
.RE

.sp
.ne 2
.mk
.na
.B M-S
.ad
.RS 21n
.rt
vi-change-line
.RE

.sp
.ne 2
.mk
.na
.B M-t
.ad
.RS 21n
.rt
forward-to-char
.RE

.sp
.ne 2
.mk
.na
.B M-T
.ad
.RS 21n
.rt
backward-to-char
.RE

.sp
.ne 2
.mk
.na
.B M-u
.ad
.RS 21n
.rt
vi-undo
.RE

.sp
.ne 2
.mk
.na
.B M-w
.ad
.RS 21n
.rt
forward-to-word
.RE

.sp
.ne 2
.mk
.na
.B M-W
.ad
.RS 21n
.rt
forward-to-word
.RE

.sp
.ne 2
.mk
.na
.B M-x
.ad
.RS 21n
.rt
forward-delete-char
.RE

.sp
.ne 2
.mk
.na
.B M-X
.ad
.RS 21n
.rt
backward-delete-char
.RE

.sp
.ne 2
.mk
.na
.B M-yh
.ad
.RS 21n
.rt
backward-copy-char
.RE

.sp
.ne 2
.mk
.na
.B M-y^H
.ad
.RS 21n
.rt
backward-copy-char
.RE

.sp
.ne 2
.mk
.na
.B M-y^?
.ad
.RS 21n
.rt
backward-copy-char
.RE

.sp
.ne 2
.mk
.na
.B M-yl
.ad
.RS 21n
.rt
forward-copy-char
.RE

.sp
.ne 2
.mk
.na
\fBM-y\e\fR
.ad
.RS 21n
.rt
forward-copy-char (META-y-space)
.RE

.sp
.ne 2
.mk
.na
.B M-ye
.ad
.RS 21n
.rt
forward-copy-word
.RE

.sp
.ne 2
.mk
.na
.B M-yE
.ad
.RS 21n
.rt
forward-copy-word
.RE

.sp
.ne 2
.mk
.na
.B M-yw
.ad
.RS 21n
.rt
forward-copy-word
.RE

.sp
.ne 2
.mk
.na
.B M-yW
.ad
.RS 21n
.rt
forward-copy-word
.RE

.sp
.ne 2
.mk
.na
.B M-yb
.ad
.RS 21n
.rt
backward-copy-word
.RE

.sp
.ne 2
.mk
.na
.B M-yB
.ad
.RS 21n
.rt
backward-copy-word
.RE

.sp
.ne 2
.mk
.na
.B M-yf
.ad
.RS 21n
.rt
forward-copy-find
.RE

.sp
.ne 2
.mk
.na
.B M-yF
.ad
.RS 21n
.rt
backward-copy-find
.RE

.sp
.ne 2
.mk
.na
.B M-yt
.ad
.RS 21n
.rt
forward-copy-to
.RE

.sp
.ne 2
.mk
.na
.B M-yT
.ad
.RS 21n
.rt
backward-copy-to
.RE

.sp
.ne 2
.mk
.na
.B M-y;
.ad
.RS 21n
.rt
copy-refind
.RE

.sp
.ne 2
.mk
.na
.B M-y,
.ad
.RS 21n
.rt
copy-invert-refind
.RE

.sp
.ne 2
.mk
.na
.B M-y^
.ad
.RS 21n
.rt
copy-to-bol
.RE

.sp
.ne 2
.mk
.na
.B M-y0
.ad
.RS 21n
.rt
copy-to-bol
.RE

.sp
.ne 2
.mk
.na
.B M-y$
.ad
.RS 21n
.rt
copy-rest-of-line
.RE

.sp
.ne 2
.mk
.na
.B M-yy
.ad
.RS 21n
.rt
copy-line
.RE

.sp
.ne 2
.mk
.na
.B M-Y
.ad
.RS 21n
.rt
copy-line
.RE

.sp
.ne 2
.mk
.na
.B M-y|
.ad
.RS 21n
.rt
copy-to-column
.RE

.sp
.ne 2
.mk
.na
.B M-y%
.ad
.RS 21n
.rt
copy-to-parenthesis
.RE

.sp
.ne 2
.mk
.na
.B M-^E
.ad
.RS 21n
.rt
emacs-mode
.RE

.sp
.ne 2
.mk
.na
.B M-^H
.ad
.RS 21n
.rt
cursor-left
.RE

.sp
.ne 2
.mk
.na
.B M-^?
.ad
.RS 21n
.rt
cursor-left
.RE

.sp
.ne 2
.mk
.na
.B M-^L
.ad
.RS 21n
.rt
clear-screen
.RE

.sp
.ne 2
.mk
.na
.B M-^N
.ad
.RS 21n
.rt
down-history
.RE

.sp
.ne 2
.mk
.na
.B M-^P
.ad
.RS 21n
.rt
up-history
.RE

.sp
.ne 2
.mk
.na
.B M-^R
.ad
.RS 21n
.rt
redisplay
.RE

.sp
.ne 2
.mk
.na
.B M-^D
.ad
.RS 21n
.rt
list-or-eof
.RE

.sp
.ne 2
.mk
.na
.B M-^I
.ad
.RS 21n
.rt
complete-word
.RE

.sp
.ne 2
.mk
.na
\fBM-\er\fR
.ad
.RS 21n
.rt
newline
.RE

.sp
.ne 2
.mk
.na
\fBM-\en\fR
.ad
.RS 21n
.rt
newline
.RE

.sp
.ne 2
.mk
.na
.B M-^X^R
.ad
.RS 21n
.rt
read-init-files
.RE

.sp
.ne 2
.mk
.na
.B M-^Xh
.ad
.RS 21n
.rt
list-history
.RE

.sp
.ne 2
.mk
.na
\fBM-0, M-1, .\|.\|. M-9\fR
.ad
.RS 21n
.rt
digit-argument (see below)
.RE

.sp
.LP
Note that
.B ^I
is what the TAB key generates.
.SS "Entering Repeat Counts"
.sp
.LP
Many of the key binding functions described previously, take an optional
count, typed in before the target key sequence. This is interpreted as a
repeat count by most bindings. A notable exception is the goto-column binding,
which interprets the count as a column number.
.sp
.LP
By default you can specify this count argument by pressing the META key while
typing in the numeric count. This relies on the digit-argument action being
bound to 'META-0', 'META-1' etc. Once any one of these bindings has been
activated, you can optionally take your finger off the META key to type in the
rest of the number, since every numeric digit thereafter is treated as part of
the number, unless it is preceded by the literal-next binding. As soon as a
non-digit, or literal digit key is pressed the repeat count is terminated and
either causes the just typed character to be added to the line that many
times, or causes the next key binding function to be given that argument.
.sp
.LP
For example, in
.B emacs
mode, typing:
.sp
.in +2
.nf
M-12a
.fi
.in -2

.sp
.LP
causes the letter 'a' to be added to the line 12 times, whereas
.sp
.in +2
.nf
M-4M-c
.fi
.in -2

.sp
.LP
Capitalizes the next 4 words.
.sp
.LP
In
.B vi
command mode the meta modifier is automatically added to all
characters typed in, so to enter a count in
.B vi
command-mode, just
involves typing in the number, just as it does in the
.B vi
editor itself.
So for example, in vi command mode, typing:
.sp
.in +2
.nf
4w2x
.fi
.in -2

.sp
.LP
moves the cursor four words to the right, then deletes two characters.
.sp
.LP
You can also bind digit-argument to other key sequences. If these end in a
numeric digit, that digit gets appended to the current repeat count. If it
doesn't end in a numeric digit, a new repeat count is started with a value of
zero, and can be completed by typing in the number, after letting go of the
key which triggered the digit-argument action.
.SH FILES
.sp
.ne 2
.mk
.na
.B /usr/lib/libtecla.so
.ad
.RS 27n
.rt
The tecla library
.RE

.sp
.ne 2
.mk
.na
.B /usr/include/libtecla.h
.ad
.RS 27n
.rt
The tecla header file
.RE

.sp
.ne 2
.mk
.na
.B ~/.teclarc
.ad
.RS 27n
.rt
The personal tecla customization file
.RE

.SH ATTRIBUTES
.sp
.LP
See
.BR attributes (5)
for descriptions of the following attributes:
.sp

.sp
.TS
tab() box;
cw(2.75i) |cw(2.75i)
lw(2.75i) |lw(2.75i)
.
ATTRIBUTE TYPEATTRIBUTE VALUE
_
AvailabilitySUNWtecla
_
Interface StabilityEvolving
.TE

.SH SEE ALSO
.sp
.LP
.BR vi (1),
.BR cpl_complete_word (3TECLA),
.BR ef_expand_file (3TECLA),
.BR gl_get_line (3TECLA),
.BR gl_io_mode (3TECLA),
.BR libtecla (3LIB),
.BR pca_lookup_file (3TECLA),
.BR attributes (5)
